
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type CustomerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Customer"
  objects: {
    pets: PetPayload<ExtArgs>[]
    reservations: ReservationPayload<ExtArgs>[]
    payments: PaymentPayload<ExtArgs>[]
    invoices: InvoicePayload<ExtArgs>[]
    documents: DocumentPayload<ExtArgs>[]
    notifications: NotificationPreferencePayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    email: string
    firstName: string
    lastName: string
    phone: string | null
    alternatePhone: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    notes: string | null
    portalEnabled: boolean
    preferredContact: ContactMethod
    emergencyContact: string | null
    emergencyPhone: string | null
    vatTaxId: string | null
    referralSource: string | null
    tags: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["customer"]>
  composites: {}
}

/**
 * Model Customer
 * 
 */
export type Customer = runtime.Types.DefaultSelection<CustomerPayload>
export type PetPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Pet"
  objects: {
    owner: CustomerPayload<ExtArgs>
    reservations: ReservationPayload<ExtArgs>[]
    checkIns: CheckInPayload<ExtArgs>[]
    medicalRecords: MedicalRecordPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    type: PetType
    breed: string | null
    color: string | null
    birthdate: Date | null
    weight: number | null
    gender: Gender | null
    isNeutered: boolean
    microchipNumber: string | null
    rabiesTagNumber: string | null
    specialNeeds: string | null
    foodNotes: string | null
    medicationNotes: string | null
    behaviorNotes: string | null
    allergies: string | null
    idealPlayGroup: PlayGroupType | null
    vaccinationStatus: Prisma.JsonValue | null
    vaccineExpirations: Prisma.JsonValue | null
    vetName: string | null
    vetPhone: string | null
    profilePhoto: string | null
    isActive: boolean
    lastCheckIn: Date | null
    createdAt: Date
    updatedAt: Date
    customerId: string
  }, ExtArgs["result"]["pet"]>
  composites: {}
}

/**
 * Model Pet
 * 
 */
export type Pet = runtime.Types.DefaultSelection<PetPayload>
export type ReservationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Reservation"
  objects: {
    customer: CustomerPayload<ExtArgs>
    pet: PetPayload<ExtArgs>
    service: ServicePayload<ExtArgs>
    resource: ResourcePayload<ExtArgs> | null
    staffAssigned: StaffPayload<ExtArgs> | null
    addOnServices: ReservationAddOnPayload<ExtArgs>[]
    invoice: InvoicePayload<ExtArgs> | null
    checkIns: CheckInPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    startDate: Date
    endDate: Date
    status: ReservationStatus
    notes: string | null
    staffNotes: string | null
    checkInWindow: number | null
    isRecurring: boolean
    recurringPattern: string | null
    preChecked: boolean
    checkInDate: Date | null
    checkOutDate: Date | null
    earlyDropOff: boolean
    latePickup: boolean
    customPickupPerson: string | null
    confirmedBy: string | null
    cancelReason: string | null
    cancelDate: Date | null
    createdAt: Date
    updatedAt: Date
    customerId: string
    petId: string
    serviceId: string
    resourceId: string | null
    staffAssignedId: string | null
  }, ExtArgs["result"]["reservation"]>
  composites: {}
}

/**
 * Model Reservation
 * 
 */
export type Reservation = runtime.Types.DefaultSelection<ReservationPayload>
export type ServicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Service"
  objects: {
    reservations: ReservationPayload<ExtArgs>[]
    availableAddOns: AddOnServicePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    duration: number
    price: number
    color: string | null
    serviceCategory: ServiceCategory
    isActive: boolean
    capacityLimit: number | null
    requiresStaff: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["service"]>
  composites: {}
}

/**
 * Model Service
 * 
 */
export type Service = runtime.Types.DefaultSelection<ServicePayload>
export type AddOnServicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "AddOnService"
  objects: {
    service: ServicePayload<ExtArgs>
    reservationAddOns: ReservationAddOnPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    price: number
    duration: number | null
    serviceId: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["addOnService"]>
  composites: {}
}

/**
 * Model AddOnService
 * 
 */
export type AddOnService = runtime.Types.DefaultSelection<AddOnServicePayload>
export type ReservationAddOnPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ReservationAddOn"
  objects: {
    reservation: ReservationPayload<ExtArgs>
    addOn: AddOnServicePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    reservationId: string
    addOnId: string
    price: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["reservationAddOn"]>
  composites: {}
}

/**
 * Model ReservationAddOn
 * 
 */
export type ReservationAddOn = runtime.Types.DefaultSelection<ReservationAddOnPayload>
export type ResourcePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Resource"
  objects: {
    reservations: ReservationPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    type: ResourceType
    description: string | null
    capacity: number | null
    isActive: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["resource"]>
  composites: {}
}

/**
 * Model Resource
 * 
 */
export type Resource = runtime.Types.DefaultSelection<ResourcePayload>
export type StaffPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Staff"
  objects: {
    assignedReservations: ReservationPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    firstName: string
    lastName: string
    email: string
    phone: string | null
    role: string
    workSchedule: Prisma.JsonValue | null
    specialties: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["staff"]>
  composites: {}
}

/**
 * Model Staff
 * 
 */
export type Staff = runtime.Types.DefaultSelection<StaffPayload>
export type InvoicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Invoice"
  objects: {
    customer: CustomerPayload<ExtArgs>
    reservation: ReservationPayload<ExtArgs> | null
    lineItems: InvoiceLineItemPayload<ExtArgs>[]
    payments: PaymentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    invoiceNumber: string
    customerId: string
    reservationId: string | null
    issueDate: Date
    dueDate: Date
    status: InvoiceStatus
    subtotal: number
    taxRate: number
    taxAmount: number
    discount: number
    total: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["invoice"]>
  composites: {}
}

/**
 * Model Invoice
 * 
 */
export type Invoice = runtime.Types.DefaultSelection<InvoicePayload>
export type InvoiceLineItemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "InvoiceLineItem"
  objects: {
    invoice: InvoicePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    invoiceId: string
    description: string
    quantity: number
    unitPrice: number
    amount: number
    taxable: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["invoiceLineItem"]>
  composites: {}
}

/**
 * Model InvoiceLineItem
 * 
 */
export type InvoiceLineItem = runtime.Types.DefaultSelection<InvoiceLineItemPayload>
export type PaymentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Payment"
  objects: {
    invoice: InvoicePayload<ExtArgs>
    customer: CustomerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    invoiceId: string
    customerId: string
    amount: number
    method: PaymentMethod
    status: PaymentStatus
    transactionId: string | null
    paymentDate: Date
    gatewayResponse: Prisma.JsonValue | null
    refundedAmount: number
    refundReason: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["payment"]>
  composites: {}
}

/**
 * Model Payment
 * 
 */
export type Payment = runtime.Types.DefaultSelection<PaymentPayload>
export type DocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Document"
  objects: {
    customer: CustomerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    customerId: string
    title: string
    description: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    tags: string[]
    uploaded: Date
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["document"]>
  composites: {}
}

/**
 * Model Document
 * 
 */
export type Document = runtime.Types.DefaultSelection<DocumentPayload>
export type NotificationPreferencePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "NotificationPreference"
  objects: {
    customer: CustomerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    customerId: string
    emailNotifications: boolean
    smsNotifications: boolean
    pushNotifications: boolean
    marketingEmails: boolean
    appointmentReminders: boolean
    checkinNotifications: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["notificationPreference"]>
  composites: {}
}

/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = runtime.Types.DefaultSelection<NotificationPreferencePayload>
export type CheckInPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "CheckIn"
  objects: {
    pet: PetPayload<ExtArgs>
    reservation: ReservationPayload<ExtArgs> | null
    activities: ActivityPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    petId: string
    reservationId: string | null
    checkInTime: Date
    checkOutTime: Date | null
    checkInNotes: string | null
    checkOutNotes: string | null
    checkInBy: string | null
    checkOutBy: string | null
    belongingsChecklist: Prisma.JsonValue | null
    foodProvided: boolean
    medicationGiven: boolean
    medicationNotes: string | null
    behaviorDuringStay: string | null
    photosTaken: boolean
    photosShared: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["checkIn"]>
  composites: {}
}

/**
 * Model CheckIn
 * 
 */
export type CheckIn = runtime.Types.DefaultSelection<CheckInPayload>
export type ActivityPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Activity"
  objects: {
    checkIn: CheckInPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    checkInId: string
    activityType: string
    notes: string | null
    timestamp: Date
    recordedBy: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["activity"]>
  composites: {}
}

/**
 * Model Activity
 * 
 */
export type Activity = runtime.Types.DefaultSelection<ActivityPayload>
export type MedicalRecordPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "MedicalRecord"
  objects: {
    pet: PetPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    petId: string
    recordType: string
    recordDate: Date
    expirationDate: Date | null
    description: string
    veterinarian: string | null
    fileUrl: string | null
    verified: boolean
    verifiedBy: string | null
    verifiedDate: Date | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["medicalRecord"]>
  composites: {}
}

/**
 * Model MedicalRecord
 * 
 */
export type MedicalRecord = runtime.Types.DefaultSelection<MedicalRecordPayload>

/**
 * Enums
 */

export const ContactMethod: {
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  BOTH: 'BOTH',
  NONE: 'NONE'
};

export type ContactMethod = (typeof ContactMethod)[keyof typeof ContactMethod]


export const PetType: {
  DOG: 'DOG',
  CAT: 'CAT',
  BIRD: 'BIRD',
  RABBIT: 'RABBIT',
  REPTILE: 'REPTILE',
  OTHER: 'OTHER'
};

export type PetType = (typeof PetType)[keyof typeof PetType]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  UNKNOWN: 'UNKNOWN'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const PlayGroupType: {
  SMALL_DOGS: 'SMALL_DOGS',
  MEDIUM_DOGS: 'MEDIUM_DOGS',
  LARGE_DOGS: 'LARGE_DOGS',
  HIGH_ENERGY: 'HIGH_ENERGY',
  LOW_ENERGY: 'LOW_ENERGY',
  PUPPIES: 'PUPPIES',
  SENIORS: 'SENIORS',
  SPECIAL_NEEDS: 'SPECIAL_NEEDS'
};

export type PlayGroupType = (typeof PlayGroupType)[keyof typeof PlayGroupType]


export const ReservationStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CHECKED_IN: 'CHECKED_IN',
  CHECKED_OUT: 'CHECKED_OUT',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW',
  COMPLETED: 'COMPLETED'
};

export type ReservationStatus = (typeof ReservationStatus)[keyof typeof ReservationStatus]


export const ServiceCategory: {
  DAYCARE: 'DAYCARE',
  BOARDING: 'BOARDING',
  GROOMING: 'GROOMING',
  TRAINING: 'TRAINING',
  OTHER: 'OTHER'
};

export type ServiceCategory = (typeof ServiceCategory)[keyof typeof ServiceCategory]


export const ResourceType: {
  ROOM: 'ROOM',
  KENNEL: 'KENNEL',
  GROOMING_TABLE: 'GROOMING_TABLE',
  PLAYPEN: 'PLAYPEN',
  TRAINING_AREA: 'TRAINING_AREA',
  OTHER: 'OTHER'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const PaymentMethod: {
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  CASH: 'CASH',
  CHECK: 'CHECK',
  BANK_TRANSFER: 'BANK_TRANSFER',
  STORE_CREDIT: 'STORE_CREDIT',
  GIFT_CARD: 'GIFT_CARD'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.pet`: Exposes CRUD operations for the **Pet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pets
    * const pets = await prisma.pet.findMany()
    * ```
    */
  get pet(): Prisma.PetDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.addOnService`: Exposes CRUD operations for the **AddOnService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddOnServices
    * const addOnServices = await prisma.addOnService.findMany()
    * ```
    */
  get addOnService(): Prisma.AddOnServiceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.reservationAddOn`: Exposes CRUD operations for the **ReservationAddOn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReservationAddOns
    * const reservationAddOns = await prisma.reservationAddOn.findMany()
    * ```
    */
  get reservationAddOn(): Prisma.ReservationAddOnDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.invoiceLineItem`: Exposes CRUD operations for the **InvoiceLineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceLineItems
    * const invoiceLineItems = await prisma.invoiceLineItem.findMany()
    * ```
    */
  get invoiceLineItem(): Prisma.InvoiceLineItemDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.checkIn`: Exposes CRUD operations for the **CheckIn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckIns
    * const checkIns = await prisma.checkIn.findMany()
    * ```
    */
  get checkIn(): Prisma.CheckInDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.medicalRecord`: Exposes CRUD operations for the **MedicalRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalRecords
    * const medicalRecords = await prisma.medicalRecord.findMany()
    * ```
    */
  get medicalRecord(): Prisma.MedicalRecordDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Customer: 'Customer',
    Pet: 'Pet',
    Reservation: 'Reservation',
    Service: 'Service',
    AddOnService: 'AddOnService',
    ReservationAddOn: 'ReservationAddOn',
    Resource: 'Resource',
    Staff: 'Staff',
    Invoice: 'Invoice',
    InvoiceLineItem: 'InvoiceLineItem',
    Payment: 'Payment',
    Document: 'Document',
    NotificationPreference: 'NotificationPreference',
    CheckIn: 'CheckIn',
    Activity: 'Activity',
    MedicalRecord: 'MedicalRecord'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'customer' | 'pet' | 'reservation' | 'service' | 'addOnService' | 'reservationAddOn' | 'resource' | 'staff' | 'invoice' | 'invoiceLineItem' | 'payment' | 'document' | 'notificationPreference' | 'checkIn' | 'activity' | 'medicalRecord'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Customer: {
        payload: CustomerPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Pet: {
        payload: PetPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PetPayload>
          }
          findFirst: {
            args: Prisma.PetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PetPayload>
          }
          findMany: {
            args: Prisma.PetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PetPayload>[]
          }
          create: {
            args: Prisma.PetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PetPayload>
          }
          createMany: {
            args: Prisma.PetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PetPayload>
          }
          update: {
            args: Prisma.PetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PetPayload>
          }
          deleteMany: {
            args: Prisma.PetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PetPayload>
          }
          aggregate: {
            args: Prisma.PetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePet>
          }
          groupBy: {
            args: Prisma.PetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PetCountArgs<ExtArgs>,
            result: $Utils.Optional<PetCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: ReservationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>,
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: ServicePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      AddOnService: {
        payload: AddOnServicePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AddOnServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddOnServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddOnServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddOnServicePayload>
          }
          findFirst: {
            args: Prisma.AddOnServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddOnServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddOnServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddOnServicePayload>
          }
          findMany: {
            args: Prisma.AddOnServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddOnServicePayload>[]
          }
          create: {
            args: Prisma.AddOnServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddOnServicePayload>
          }
          createMany: {
            args: Prisma.AddOnServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AddOnServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddOnServicePayload>
          }
          update: {
            args: Prisma.AddOnServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddOnServicePayload>
          }
          deleteMany: {
            args: Prisma.AddOnServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AddOnServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AddOnServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddOnServicePayload>
          }
          aggregate: {
            args: Prisma.AddOnServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddOnService>
          }
          groupBy: {
            args: Prisma.AddOnServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddOnServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddOnServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<AddOnServiceCountAggregateOutputType> | number
          }
        }
      }
      ReservationAddOn: {
        payload: ReservationAddOnPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ReservationAddOnFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationAddOnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationAddOnFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationAddOnPayload>
          }
          findFirst: {
            args: Prisma.ReservationAddOnFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationAddOnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationAddOnFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationAddOnPayload>
          }
          findMany: {
            args: Prisma.ReservationAddOnFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationAddOnPayload>[]
          }
          create: {
            args: Prisma.ReservationAddOnCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationAddOnPayload>
          }
          createMany: {
            args: Prisma.ReservationAddOnCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReservationAddOnDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationAddOnPayload>
          }
          update: {
            args: Prisma.ReservationAddOnUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationAddOnPayload>
          }
          deleteMany: {
            args: Prisma.ReservationAddOnDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationAddOnUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReservationAddOnUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReservationAddOnPayload>
          }
          aggregate: {
            args: Prisma.ReservationAddOnAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReservationAddOn>
          }
          groupBy: {
            args: Prisma.ReservationAddOnGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReservationAddOnGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationAddOnCountArgs<ExtArgs>,
            result: $Utils.Optional<ReservationAddOnCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: ResourcePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>,
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      Staff: {
        payload: StaffPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>,
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: InvoicePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceLineItem: {
        payload: InvoiceLineItemPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InvoiceLineItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceLineItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceLineItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceLineItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceLineItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceLineItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceLineItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceLineItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceLineItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceLineItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceLineItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceLineItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceLineItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvoiceLineItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceLineItemPayload>
          }
          update: {
            args: Prisma.InvoiceLineItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceLineItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceLineItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceLineItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceLineItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoiceLineItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceLineItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvoiceLineItem>
          }
          groupBy: {
            args: Prisma.InvoiceLineItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceLineItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceLineItemCountArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceLineItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: PaymentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: DocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: NotificationPreferencePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      CheckIn: {
        payload: CheckInPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CheckInFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CheckInPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckInFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CheckInPayload>
          }
          findFirst: {
            args: Prisma.CheckInFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CheckInPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckInFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CheckInPayload>
          }
          findMany: {
            args: Prisma.CheckInFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CheckInPayload>[]
          }
          create: {
            args: Prisma.CheckInCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CheckInPayload>
          }
          createMany: {
            args: Prisma.CheckInCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CheckInDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CheckInPayload>
          }
          update: {
            args: Prisma.CheckInUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CheckInPayload>
          }
          deleteMany: {
            args: Prisma.CheckInDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CheckInUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CheckInUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CheckInPayload>
          }
          aggregate: {
            args: Prisma.CheckInAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCheckIn>
          }
          groupBy: {
            args: Prisma.CheckInGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CheckInGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckInCountArgs<ExtArgs>,
            result: $Utils.Optional<CheckInCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: ActivityPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>,
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      MedicalRecord: {
        payload: MedicalRecordPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.MedicalRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MedicalRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MedicalRecordPayload>
          }
          findFirst: {
            args: Prisma.MedicalRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MedicalRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MedicalRecordPayload>
          }
          findMany: {
            args: Prisma.MedicalRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MedicalRecordPayload>[]
          }
          create: {
            args: Prisma.MedicalRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MedicalRecordPayload>
          }
          createMany: {
            args: Prisma.MedicalRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MedicalRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MedicalRecordPayload>
          }
          update: {
            args: Prisma.MedicalRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MedicalRecordPayload>
          }
          deleteMany: {
            args: Prisma.MedicalRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MedicalRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MedicalRecordPayload>
          }
          aggregate: {
            args: Prisma.MedicalRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMedicalRecord>
          }
          groupBy: {
            args: Prisma.MedicalRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MedicalRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<MedicalRecordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */


  export type CustomerCountOutputType = {
    pets: number
    reservations: number
    payments: number
    invoices: number
    documents: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pets?: boolean | CustomerCountOutputTypeCountPetsArgs
    reservations?: boolean | CustomerCountOutputTypeCountReservationsArgs
    payments?: boolean | CustomerCountOutputTypeCountPaymentsArgs
    invoices?: boolean | CustomerCountOutputTypeCountInvoicesArgs
    documents?: boolean | CustomerCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPetsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PetWhereInput
  }


  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }



  /**
   * Count Type PetCountOutputType
   */


  export type PetCountOutputType = {
    reservations: number
    checkIns: number
    medicalRecords: number
  }

  export type PetCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    reservations?: boolean | PetCountOutputTypeCountReservationsArgs
    checkIns?: boolean | PetCountOutputTypeCountCheckInsArgs
    medicalRecords?: boolean | PetCountOutputTypeCountMedicalRecordsArgs
  }

  // Custom InputTypes

  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetCountOutputType
     */
    select?: PetCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountCheckInsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CheckInWhereInput
  }


  /**
   * PetCountOutputType without action
   */
  export type PetCountOutputTypeCountMedicalRecordsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
  }



  /**
   * Count Type ReservationCountOutputType
   */


  export type ReservationCountOutputType = {
    addOnServices: number
    checkIns: number
  }

  export type ReservationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    addOnServices?: boolean | ReservationCountOutputTypeCountAddOnServicesArgs
    checkIns?: boolean | ReservationCountOutputTypeCountCheckInsArgs
  }

  // Custom InputTypes

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationCountOutputType
     */
    select?: ReservationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountAddOnServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReservationAddOnWhereInput
  }


  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountCheckInsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CheckInWhereInput
  }



  /**
   * Count Type ServiceCountOutputType
   */


  export type ServiceCountOutputType = {
    reservations: number
    availableAddOns: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    reservations?: boolean | ServiceCountOutputTypeCountReservationsArgs
    availableAddOns?: boolean | ServiceCountOutputTypeCountAvailableAddOnsArgs
  }

  // Custom InputTypes

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountAvailableAddOnsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AddOnServiceWhereInput
  }



  /**
   * Count Type AddOnServiceCountOutputType
   */


  export type AddOnServiceCountOutputType = {
    reservationAddOns: number
  }

  export type AddOnServiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    reservationAddOns?: boolean | AddOnServiceCountOutputTypeCountReservationAddOnsArgs
  }

  // Custom InputTypes

  /**
   * AddOnServiceCountOutputType without action
   */
  export type AddOnServiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnServiceCountOutputType
     */
    select?: AddOnServiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AddOnServiceCountOutputType without action
   */
  export type AddOnServiceCountOutputTypeCountReservationAddOnsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReservationAddOnWhereInput
  }



  /**
   * Count Type ResourceCountOutputType
   */


  export type ResourceCountOutputType = {
    reservations: number
  }

  export type ResourceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    reservations?: boolean | ResourceCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCountOutputType
     */
    select?: ResourceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }



  /**
   * Count Type StaffCountOutputType
   */


  export type StaffCountOutputType = {
    assignedReservations: number
  }

  export type StaffCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    assignedReservations?: boolean | StaffCountOutputTypeCountAssignedReservationsArgs
  }

  // Custom InputTypes

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffCountOutputType
     */
    select?: StaffCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountAssignedReservationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }



  /**
   * Count Type InvoiceCountOutputType
   */


  export type InvoiceCountOutputType = {
    lineItems: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    lineItems?: boolean | InvoiceCountOutputTypeCountLineItemsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceLineItemWhereInput
  }


  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }



  /**
   * Count Type CheckInCountOutputType
   */


  export type CheckInCountOutputType = {
    activities: number
  }

  export type CheckInCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    activities?: boolean | CheckInCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes

  /**
   * CheckInCountOutputType without action
   */
  export type CheckInCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInCountOutputType
     */
    select?: CheckInCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CheckInCountOutputType without action
   */
  export type CheckInCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Customer
   */


  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    alternatePhone: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    notes: string | null
    portalEnabled: boolean | null
    preferredContact: ContactMethod | null
    emergencyContact: string | null
    emergencyPhone: string | null
    vatTaxId: string | null
    referralSource: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    alternatePhone: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    notes: string | null
    portalEnabled: boolean | null
    preferredContact: ContactMethod | null
    emergencyContact: string | null
    emergencyPhone: string | null
    vatTaxId: string | null
    referralSource: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    phone: number
    alternatePhone: number
    address: number
    city: number
    state: number
    zipCode: number
    notes: number
    portalEnabled: number
    preferredContact: number
    emergencyContact: number
    emergencyPhone: number
    vatTaxId: number
    referralSource: number
    tags: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    alternatePhone?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    notes?: true
    portalEnabled?: true
    preferredContact?: true
    emergencyContact?: true
    emergencyPhone?: true
    vatTaxId?: true
    referralSource?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    alternatePhone?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    notes?: true
    portalEnabled?: true
    preferredContact?: true
    emergencyContact?: true
    emergencyPhone?: true
    vatTaxId?: true
    referralSource?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    alternatePhone?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    notes?: true
    portalEnabled?: true
    preferredContact?: true
    emergencyContact?: true
    emergencyPhone?: true
    vatTaxId?: true
    referralSource?: true
    tags?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByWithAggregationInput>
    by: CustomerScalarFieldEnum[]
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }


  export type CustomerGroupByOutputType = {
    id: string
    email: string
    firstName: string
    lastName: string
    phone: string | null
    alternatePhone: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    notes: string | null
    portalEnabled: boolean
    preferredContact: ContactMethod
    emergencyContact: string | null
    emergencyPhone: string | null
    vatTaxId: string | null
    referralSource: string | null
    tags: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    alternatePhone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    notes?: boolean
    portalEnabled?: boolean
    preferredContact?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    vatTaxId?: boolean
    referralSource?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pets?: boolean | Customer$petsArgs<ExtArgs>
    reservations?: boolean | Customer$reservationsArgs<ExtArgs>
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    documents?: boolean | Customer$documentsArgs<ExtArgs>
    notifications?: boolean | NotificationPreferenceArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    alternatePhone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    notes?: boolean
    portalEnabled?: boolean
    preferredContact?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    vatTaxId?: boolean
    referralSource?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pets?: boolean | Customer$petsArgs<ExtArgs>
    reservations?: boolean | Customer$reservationsArgs<ExtArgs>
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    documents?: boolean | Customer$documentsArgs<ExtArgs>
    notifications?: boolean | NotificationPreferenceArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeArgs<ExtArgs>
  }


  type CustomerGetPayload<S extends boolean | null | undefined | CustomerArgs> = $Types.GetResult<CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customer'> extends True ? Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customer'> extends True ? Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Customers.
     *     @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    pets<T extends Customer$petsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$petsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PetPayload<ExtArgs>, T, 'findMany', never>| Null>;

    reservations<T extends Customer$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    payments<T extends Customer$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    invoices<T extends Customer$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findMany', never>| Null>;

    documents<T extends Customer$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    notifications<T extends NotificationPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, NotificationPreferenceArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Customer base type for findUnique actions
   */
  export type CustomerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUnique
   */
  export interface CustomerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CustomerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer base type for findFirst actions
   */
  export type CustomerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }

  /**
   * Customer findFirst
   */
  export interface CustomerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CustomerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }


  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: Enumerable<CustomerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer.pets
   */
  export type Customer$petsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PetInclude<ExtArgs> | null
    where?: PetWhereInput
    orderBy?: Enumerable<PetOrderByWithRelationInput>
    cursor?: PetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PetScalarFieldEnum>
  }


  /**
   * Customer.reservations
   */
  export type Customer$reservationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: Enumerable<ReservationOrderByWithRelationInput>
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }


  /**
   * Customer.payments
   */
  export type Customer$paymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Customer.invoices
   */
  export type Customer$invoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Customer.documents
   */
  export type Customer$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Customer without action
   */
  export type CustomerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
  }



  /**
   * Model Pet
   */


  export type AggregatePet = {
    _count: PetCountAggregateOutputType | null
    _avg: PetAvgAggregateOutputType | null
    _sum: PetSumAggregateOutputType | null
    _min: PetMinAggregateOutputType | null
    _max: PetMaxAggregateOutputType | null
  }

  export type PetAvgAggregateOutputType = {
    weight: number | null
  }

  export type PetSumAggregateOutputType = {
    weight: number | null
  }

  export type PetMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: PetType | null
    breed: string | null
    color: string | null
    birthdate: Date | null
    weight: number | null
    gender: Gender | null
    isNeutered: boolean | null
    microchipNumber: string | null
    rabiesTagNumber: string | null
    specialNeeds: string | null
    foodNotes: string | null
    medicationNotes: string | null
    behaviorNotes: string | null
    allergies: string | null
    idealPlayGroup: PlayGroupType | null
    vetName: string | null
    vetPhone: string | null
    profilePhoto: string | null
    isActive: boolean | null
    lastCheckIn: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
  }

  export type PetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: PetType | null
    breed: string | null
    color: string | null
    birthdate: Date | null
    weight: number | null
    gender: Gender | null
    isNeutered: boolean | null
    microchipNumber: string | null
    rabiesTagNumber: string | null
    specialNeeds: string | null
    foodNotes: string | null
    medicationNotes: string | null
    behaviorNotes: string | null
    allergies: string | null
    idealPlayGroup: PlayGroupType | null
    vetName: string | null
    vetPhone: string | null
    profilePhoto: string | null
    isActive: boolean | null
    lastCheckIn: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
  }

  export type PetCountAggregateOutputType = {
    id: number
    name: number
    type: number
    breed: number
    color: number
    birthdate: number
    weight: number
    gender: number
    isNeutered: number
    microchipNumber: number
    rabiesTagNumber: number
    specialNeeds: number
    foodNotes: number
    medicationNotes: number
    behaviorNotes: number
    allergies: number
    idealPlayGroup: number
    vaccinationStatus: number
    vaccineExpirations: number
    vetName: number
    vetPhone: number
    profilePhoto: number
    isActive: number
    lastCheckIn: number
    createdAt: number
    updatedAt: number
    customerId: number
    _all: number
  }


  export type PetAvgAggregateInputType = {
    weight?: true
  }

  export type PetSumAggregateInputType = {
    weight?: true
  }

  export type PetMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    breed?: true
    color?: true
    birthdate?: true
    weight?: true
    gender?: true
    isNeutered?: true
    microchipNumber?: true
    rabiesTagNumber?: true
    specialNeeds?: true
    foodNotes?: true
    medicationNotes?: true
    behaviorNotes?: true
    allergies?: true
    idealPlayGroup?: true
    vetName?: true
    vetPhone?: true
    profilePhoto?: true
    isActive?: true
    lastCheckIn?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
  }

  export type PetMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    breed?: true
    color?: true
    birthdate?: true
    weight?: true
    gender?: true
    isNeutered?: true
    microchipNumber?: true
    rabiesTagNumber?: true
    specialNeeds?: true
    foodNotes?: true
    medicationNotes?: true
    behaviorNotes?: true
    allergies?: true
    idealPlayGroup?: true
    vetName?: true
    vetPhone?: true
    profilePhoto?: true
    isActive?: true
    lastCheckIn?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
  }

  export type PetCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    breed?: true
    color?: true
    birthdate?: true
    weight?: true
    gender?: true
    isNeutered?: true
    microchipNumber?: true
    rabiesTagNumber?: true
    specialNeeds?: true
    foodNotes?: true
    medicationNotes?: true
    behaviorNotes?: true
    allergies?: true
    idealPlayGroup?: true
    vaccinationStatus?: true
    vaccineExpirations?: true
    vetName?: true
    vetPhone?: true
    profilePhoto?: true
    isActive?: true
    lastCheckIn?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    _all?: true
  }

  export type PetAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pet to aggregate.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: Enumerable<PetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pets
    **/
    _count?: true | PetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetMaxAggregateInputType
  }

  export type GetPetAggregateType<T extends PetAggregateArgs> = {
        [P in keyof T & keyof AggregatePet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePet[P]>
      : GetScalarType<T[P], AggregatePet[P]>
  }




  export type PetGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PetWhereInput
    orderBy?: Enumerable<PetOrderByWithAggregationInput>
    by: PetScalarFieldEnum[]
    having?: PetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetCountAggregateInputType | true
    _avg?: PetAvgAggregateInputType
    _sum?: PetSumAggregateInputType
    _min?: PetMinAggregateInputType
    _max?: PetMaxAggregateInputType
  }


  export type PetGroupByOutputType = {
    id: string
    name: string
    type: PetType
    breed: string | null
    color: string | null
    birthdate: Date | null
    weight: number | null
    gender: Gender | null
    isNeutered: boolean
    microchipNumber: string | null
    rabiesTagNumber: string | null
    specialNeeds: string | null
    foodNotes: string | null
    medicationNotes: string | null
    behaviorNotes: string | null
    allergies: string | null
    idealPlayGroup: PlayGroupType | null
    vaccinationStatus: JsonValue | null
    vaccineExpirations: JsonValue | null
    vetName: string | null
    vetPhone: string | null
    profilePhoto: string | null
    isActive: boolean
    lastCheckIn: Date | null
    createdAt: Date
    updatedAt: Date
    customerId: string
    _count: PetCountAggregateOutputType | null
    _avg: PetAvgAggregateOutputType | null
    _sum: PetSumAggregateOutputType | null
    _min: PetMinAggregateOutputType | null
    _max: PetMaxAggregateOutputType | null
  }

  type GetPetGroupByPayload<T extends PetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetGroupByOutputType[P]>
            : GetScalarType<T[P], PetGroupByOutputType[P]>
        }
      >
    >


  export type PetSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    breed?: boolean
    color?: boolean
    birthdate?: boolean
    weight?: boolean
    gender?: boolean
    isNeutered?: boolean
    microchipNumber?: boolean
    rabiesTagNumber?: boolean
    specialNeeds?: boolean
    foodNotes?: boolean
    medicationNotes?: boolean
    behaviorNotes?: boolean
    allergies?: boolean
    idealPlayGroup?: boolean
    vaccinationStatus?: boolean
    vaccineExpirations?: boolean
    vetName?: boolean
    vetPhone?: boolean
    profilePhoto?: boolean
    isActive?: boolean
    lastCheckIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    owner?: boolean | CustomerArgs<ExtArgs>
    reservations?: boolean | Pet$reservationsArgs<ExtArgs>
    checkIns?: boolean | Pet$checkInsArgs<ExtArgs>
    medicalRecords?: boolean | Pet$medicalRecordsArgs<ExtArgs>
    _count?: boolean | PetCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["pet"]>

  export type PetSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    breed?: boolean
    color?: boolean
    birthdate?: boolean
    weight?: boolean
    gender?: boolean
    isNeutered?: boolean
    microchipNumber?: boolean
    rabiesTagNumber?: boolean
    specialNeeds?: boolean
    foodNotes?: boolean
    medicationNotes?: boolean
    behaviorNotes?: boolean
    allergies?: boolean
    idealPlayGroup?: boolean
    vaccinationStatus?: boolean
    vaccineExpirations?: boolean
    vetName?: boolean
    vetPhone?: boolean
    profilePhoto?: boolean
    isActive?: boolean
    lastCheckIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
  }

  export type PetInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    owner?: boolean | CustomerArgs<ExtArgs>
    reservations?: boolean | Pet$reservationsArgs<ExtArgs>
    checkIns?: boolean | Pet$checkInsArgs<ExtArgs>
    medicalRecords?: boolean | Pet$medicalRecordsArgs<ExtArgs>
    _count?: boolean | PetCountOutputTypeArgs<ExtArgs>
  }


  type PetGetPayload<S extends boolean | null | undefined | PetArgs> = $Types.GetResult<PetPayload, S>

  type PetCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PetFindManyArgs, 'select' | 'include'> & {
      select?: PetCountAggregateInputType | true
    }

  export interface PetDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pet'], meta: { name: 'Pet' } }
    /**
     * Find zero or one Pet that matches the filter.
     * @param {PetFindUniqueArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PetFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PetFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pet'> extends True ? Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Pet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PetFindUniqueOrThrowArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Pet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetFindFirstArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PetFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PetFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pet'> extends True ? Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Pet that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetFindFirstOrThrowArgs} args - Arguments to find a Pet
     * @example
     * // Get one Pet
     * const pet = await prisma.pet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Pets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pets
     * const pets = await prisma.pet.findMany()
     * 
     * // Get first 10 Pets
     * const pets = await prisma.pet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petWithIdOnly = await prisma.pet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PetPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Pet.
     * @param {PetCreateArgs} args - Arguments to create a Pet.
     * @example
     * // Create one Pet
     * const Pet = await prisma.pet.create({
     *   data: {
     *     // ... data to create a Pet
     *   }
     * })
     * 
    **/
    create<T extends PetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PetCreateArgs<ExtArgs>>
    ): Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Pets.
     *     @param {PetCreateManyArgs} args - Arguments to create many Pets.
     *     @example
     *     // Create many Pets
     *     const pet = await prisma.pet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pet.
     * @param {PetDeleteArgs} args - Arguments to delete one Pet.
     * @example
     * // Delete one Pet
     * const Pet = await prisma.pet.delete({
     *   where: {
     *     // ... filter to delete one Pet
     *   }
     * })
     * 
    **/
    delete<T extends PetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PetDeleteArgs<ExtArgs>>
    ): Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Pet.
     * @param {PetUpdateArgs} args - Arguments to update one Pet.
     * @example
     * // Update one Pet
     * const pet = await prisma.pet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PetUpdateArgs<ExtArgs>>
    ): Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Pets.
     * @param {PetDeleteManyArgs} args - Arguments to filter Pets to delete.
     * @example
     * // Delete a few Pets
     * const { count } = await prisma.pet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pets
     * const pet = await prisma.pet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pet.
     * @param {PetUpsertArgs} args - Arguments to update or create a Pet.
     * @example
     * // Update or create a Pet
     * const pet = await prisma.pet.upsert({
     *   create: {
     *     // ... data to create a Pet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pet we want to update
     *   }
     * })
    **/
    upsert<T extends PetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PetUpsertArgs<ExtArgs>>
    ): Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetCountArgs} args - Arguments to filter Pets to count.
     * @example
     * // Count the number of Pets
     * const count = await prisma.pet.count({
     *   where: {
     *     // ... the filter for the Pets we want to count
     *   }
     * })
    **/
    count<T extends PetCountArgs>(
      args?: Subset<T, PetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetAggregateArgs>(args: Subset<T, PetAggregateArgs>): Prisma.PrismaPromise<GetPetAggregateType<T>>

    /**
     * Group by Pet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetGroupByArgs['orderBy'] }
        : { orderBy?: PetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PetClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    owner<T extends CustomerArgs<ExtArgs> = {}>(args?: Subset<T, CustomerArgs<ExtArgs>>): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    reservations<T extends Pet$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    checkIns<T extends Pet$checkInsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$checkInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'findMany', never>| Null>;

    medicalRecords<T extends Pet$medicalRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Pet$medicalRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pet base type for findUnique actions
   */
  export type PetFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where: PetWhereUniqueInput
  }

  /**
   * Pet findUnique
   */
  export interface PetFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PetFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pet findUniqueOrThrow
   */
  export type PetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where: PetWhereUniqueInput
  }


  /**
   * Pet base type for findFirst actions
   */
  export type PetFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: Enumerable<PetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pets.
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pets.
     */
    distinct?: Enumerable<PetScalarFieldEnum>
  }

  /**
   * Pet findFirst
   */
  export interface PetFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PetFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pet findFirstOrThrow
   */
  export type PetFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pet to fetch.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: Enumerable<PetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pets.
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pets.
     */
    distinct?: Enumerable<PetScalarFieldEnum>
  }


  /**
   * Pet findMany
   */
  export type PetFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter, which Pets to fetch.
     */
    where?: PetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pets to fetch.
     */
    orderBy?: Enumerable<PetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pets.
     */
    cursor?: PetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pets.
     */
    skip?: number
    distinct?: Enumerable<PetScalarFieldEnum>
  }


  /**
   * Pet create
   */
  export type PetCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * The data needed to create a Pet.
     */
    data: XOR<PetCreateInput, PetUncheckedCreateInput>
  }


  /**
   * Pet createMany
   */
  export type PetCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pets.
     */
    data: Enumerable<PetCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pet update
   */
  export type PetUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * The data needed to update a Pet.
     */
    data: XOR<PetUpdateInput, PetUncheckedUpdateInput>
    /**
     * Choose, which Pet to update.
     */
    where: PetWhereUniqueInput
  }


  /**
   * Pet updateMany
   */
  export type PetUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pets.
     */
    data: XOR<PetUpdateManyMutationInput, PetUncheckedUpdateManyInput>
    /**
     * Filter which Pets to update
     */
    where?: PetWhereInput
  }


  /**
   * Pet upsert
   */
  export type PetUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * The filter to search for the Pet to update in case it exists.
     */
    where: PetWhereUniqueInput
    /**
     * In case the Pet found by the `where` argument doesn't exist, create a new Pet with this data.
     */
    create: XOR<PetCreateInput, PetUncheckedCreateInput>
    /**
     * In case the Pet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PetUpdateInput, PetUncheckedUpdateInput>
  }


  /**
   * Pet delete
   */
  export type PetDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PetInclude<ExtArgs> | null
    /**
     * Filter which Pet to delete.
     */
    where: PetWhereUniqueInput
  }


  /**
   * Pet deleteMany
   */
  export type PetDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pets to delete
     */
    where?: PetWhereInput
  }


  /**
   * Pet.reservations
   */
  export type Pet$reservationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: Enumerable<ReservationOrderByWithRelationInput>
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }


  /**
   * Pet.checkIns
   */
  export type Pet$checkInsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
    where?: CheckInWhereInput
    orderBy?: Enumerable<CheckInOrderByWithRelationInput>
    cursor?: CheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CheckInScalarFieldEnum>
  }


  /**
   * Pet.medicalRecords
   */
  export type Pet$medicalRecordsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    where?: MedicalRecordWhereInput
    orderBy?: Enumerable<MedicalRecordOrderByWithRelationInput>
    cursor?: MedicalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MedicalRecordScalarFieldEnum>
  }


  /**
   * Pet without action
   */
  export type PetArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pet
     */
    select?: PetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PetInclude<ExtArgs> | null
  }



  /**
   * Model Reservation
   */


  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    checkInWindow: number | null
  }

  export type ReservationSumAggregateOutputType = {
    checkInWindow: number | null
  }

  export type ReservationMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    status: ReservationStatus | null
    notes: string | null
    staffNotes: string | null
    checkInWindow: number | null
    isRecurring: boolean | null
    recurringPattern: string | null
    preChecked: boolean | null
    checkInDate: Date | null
    checkOutDate: Date | null
    earlyDropOff: boolean | null
    latePickup: boolean | null
    customPickupPerson: string | null
    confirmedBy: string | null
    cancelReason: string | null
    cancelDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
    petId: string | null
    serviceId: string | null
    resourceId: string | null
    staffAssignedId: string | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    status: ReservationStatus | null
    notes: string | null
    staffNotes: string | null
    checkInWindow: number | null
    isRecurring: boolean | null
    recurringPattern: string | null
    preChecked: boolean | null
    checkInDate: Date | null
    checkOutDate: Date | null
    earlyDropOff: boolean | null
    latePickup: boolean | null
    customPickupPerson: string | null
    confirmedBy: string | null
    cancelReason: string | null
    cancelDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
    petId: string | null
    serviceId: string | null
    resourceId: string | null
    staffAssignedId: string | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    status: number
    notes: number
    staffNotes: number
    checkInWindow: number
    isRecurring: number
    recurringPattern: number
    preChecked: number
    checkInDate: number
    checkOutDate: number
    earlyDropOff: number
    latePickup: number
    customPickupPerson: number
    confirmedBy: number
    cancelReason: number
    cancelDate: number
    createdAt: number
    updatedAt: number
    customerId: number
    petId: number
    serviceId: number
    resourceId: number
    staffAssignedId: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    checkInWindow?: true
  }

  export type ReservationSumAggregateInputType = {
    checkInWindow?: true
  }

  export type ReservationMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    notes?: true
    staffNotes?: true
    checkInWindow?: true
    isRecurring?: true
    recurringPattern?: true
    preChecked?: true
    checkInDate?: true
    checkOutDate?: true
    earlyDropOff?: true
    latePickup?: true
    customPickupPerson?: true
    confirmedBy?: true
    cancelReason?: true
    cancelDate?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    petId?: true
    serviceId?: true
    resourceId?: true
    staffAssignedId?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    notes?: true
    staffNotes?: true
    checkInWindow?: true
    isRecurring?: true
    recurringPattern?: true
    preChecked?: true
    checkInDate?: true
    checkOutDate?: true
    earlyDropOff?: true
    latePickup?: true
    customPickupPerson?: true
    confirmedBy?: true
    cancelReason?: true
    cancelDate?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    petId?: true
    serviceId?: true
    resourceId?: true
    staffAssignedId?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    notes?: true
    staffNotes?: true
    checkInWindow?: true
    isRecurring?: true
    recurringPattern?: true
    preChecked?: true
    checkInDate?: true
    checkOutDate?: true
    earlyDropOff?: true
    latePickup?: true
    customPickupPerson?: true
    confirmedBy?: true
    cancelReason?: true
    cancelDate?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    petId?: true
    serviceId?: true
    resourceId?: true
    staffAssignedId?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: Enumerable<ReservationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: Enumerable<ReservationOrderByWithAggregationInput>
    by: ReservationScalarFieldEnum[]
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }


  export type ReservationGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    status: ReservationStatus
    notes: string | null
    staffNotes: string | null
    checkInWindow: number | null
    isRecurring: boolean
    recurringPattern: string | null
    preChecked: boolean
    checkInDate: Date | null
    checkOutDate: Date | null
    earlyDropOff: boolean
    latePickup: boolean
    customPickupPerson: string | null
    confirmedBy: string | null
    cancelReason: string | null
    cancelDate: Date | null
    createdAt: Date
    updatedAt: Date
    customerId: string
    petId: string
    serviceId: string
    resourceId: string | null
    staffAssignedId: string | null
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    notes?: boolean
    staffNotes?: boolean
    checkInWindow?: boolean
    isRecurring?: boolean
    recurringPattern?: boolean
    preChecked?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: boolean
    confirmedBy?: boolean
    cancelReason?: boolean
    cancelDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    petId?: boolean
    serviceId?: boolean
    resourceId?: boolean
    staffAssignedId?: boolean
    customer?: boolean | CustomerArgs<ExtArgs>
    pet?: boolean | PetArgs<ExtArgs>
    service?: boolean | ServiceArgs<ExtArgs>
    resource?: boolean | ResourceArgs<ExtArgs>
    staffAssigned?: boolean | StaffArgs<ExtArgs>
    addOnServices?: boolean | Reservation$addOnServicesArgs<ExtArgs>
    invoice?: boolean | InvoiceArgs<ExtArgs>
    checkIns?: boolean | Reservation$checkInsArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    notes?: boolean
    staffNotes?: boolean
    checkInWindow?: boolean
    isRecurring?: boolean
    recurringPattern?: boolean
    preChecked?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: boolean
    confirmedBy?: boolean
    cancelReason?: boolean
    cancelDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    petId?: boolean
    serviceId?: boolean
    resourceId?: boolean
    staffAssignedId?: boolean
  }

  export type ReservationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerArgs<ExtArgs>
    pet?: boolean | PetArgs<ExtArgs>
    service?: boolean | ServiceArgs<ExtArgs>
    resource?: boolean | ResourceArgs<ExtArgs>
    staffAssigned?: boolean | StaffArgs<ExtArgs>
    addOnServices?: boolean | Reservation$addOnServicesArgs<ExtArgs>
    invoice?: boolean | InvoiceArgs<ExtArgs>
    checkIns?: boolean | Reservation$checkInsArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeArgs<ExtArgs>
  }


  type ReservationGetPayload<S extends boolean | null | undefined | ReservationArgs> = $Types.GetResult<ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ReservationFindManyArgs, 'select' | 'include'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReservationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Reservation'> extends True ? Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Reservation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReservationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Reservation'> extends True ? Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Reservation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReservationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
    **/
    create<T extends ReservationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>
    ): Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Reservations.
     *     @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     *     @example
     *     // Create many Reservations
     *     const reservation = await prisma.reservation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReservationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
    **/
    delete<T extends ReservationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>
    ): Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReservationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>
    ): Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReservationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReservationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
    **/
    upsert<T extends ReservationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>
    ): Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    customer<T extends CustomerArgs<ExtArgs> = {}>(args?: Subset<T, CustomerArgs<ExtArgs>>): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    pet<T extends PetArgs<ExtArgs> = {}>(args?: Subset<T, PetArgs<ExtArgs>>): Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    service<T extends ServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    resource<T extends ResourceArgs<ExtArgs> = {}>(args?: Subset<T, ResourceArgs<ExtArgs>>): Prisma__ResourceClient<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    staffAssigned<T extends StaffArgs<ExtArgs> = {}>(args?: Subset<T, StaffArgs<ExtArgs>>): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    addOnServices<T extends Reservation$addOnServicesArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$addOnServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'findMany', never>| Null>;

    invoice<T extends InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    checkIns<T extends Reservation$checkInsArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$checkInsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Reservation base type for findUnique actions
   */
  export type ReservationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUnique
   */
  export interface ReservationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReservationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }


  /**
   * Reservation base type for findFirst actions
   */
  export type ReservationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: Enumerable<ReservationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }

  /**
   * Reservation findFirst
   */
  export interface ReservationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReservationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: Enumerable<ReservationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }


  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: Enumerable<ReservationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }


  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }


  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: Enumerable<ReservationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }


  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
  }


  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }


  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }


  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
  }


  /**
   * Reservation.addOnServices
   */
  export type Reservation$addOnServicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
    where?: ReservationAddOnWhereInput
    orderBy?: Enumerable<ReservationAddOnOrderByWithRelationInput>
    cursor?: ReservationAddOnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReservationAddOnScalarFieldEnum>
  }


  /**
   * Reservation.checkIns
   */
  export type Reservation$checkInsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
    where?: CheckInWhereInput
    orderBy?: Enumerable<CheckInOrderByWithRelationInput>
    cursor?: CheckInWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CheckInScalarFieldEnum>
  }


  /**
   * Reservation without action
   */
  export type ReservationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
  }



  /**
   * Model Service
   */


  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    duration: number | null
    price: number | null
    capacityLimit: number | null
  }

  export type ServiceSumAggregateOutputType = {
    duration: number | null
    price: number | null
    capacityLimit: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    duration: number | null
    price: number | null
    color: string | null
    serviceCategory: ServiceCategory | null
    isActive: boolean | null
    capacityLimit: number | null
    requiresStaff: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    duration: number | null
    price: number | null
    color: string | null
    serviceCategory: ServiceCategory | null
    isActive: boolean | null
    capacityLimit: number | null
    requiresStaff: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    duration: number
    price: number
    color: number
    serviceCategory: number
    isActive: number
    capacityLimit: number
    requiresStaff: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    duration?: true
    price?: true
    capacityLimit?: true
  }

  export type ServiceSumAggregateInputType = {
    duration?: true
    price?: true
    capacityLimit?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    price?: true
    color?: true
    serviceCategory?: true
    isActive?: true
    capacityLimit?: true
    requiresStaff?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    price?: true
    color?: true
    serviceCategory?: true
    isActive?: true
    capacityLimit?: true
    requiresStaff?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    price?: true
    color?: true
    serviceCategory?: true
    isActive?: true
    capacityLimit?: true
    requiresStaff?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: Enumerable<ServiceOrderByWithAggregationInput>
    by: ServiceScalarFieldEnum[]
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }


  export type ServiceGroupByOutputType = {
    id: string
    name: string
    description: string | null
    duration: number
    price: number
    color: string | null
    serviceCategory: ServiceCategory
    isActive: boolean
    capacityLimit: number | null
    requiresStaff: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    color?: boolean
    serviceCategory?: boolean
    isActive?: boolean
    capacityLimit?: boolean
    requiresStaff?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reservations?: boolean | Service$reservationsArgs<ExtArgs>
    availableAddOns?: boolean | Service$availableAddOnsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    price?: boolean
    color?: boolean
    serviceCategory?: boolean
    isActive?: boolean
    capacityLimit?: boolean
    requiresStaff?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    reservations?: boolean | Service$reservationsArgs<ExtArgs>
    availableAddOns?: boolean | Service$availableAddOnsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeArgs<ExtArgs>
  }


  type ServiceGetPayload<S extends boolean | null | undefined | ServiceArgs> = $Types.GetResult<ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Service'> extends True ? Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
    **/
    create<T extends ServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Services.
     *     @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const service = await prisma.service.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
    **/
    delete<T extends ServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reservations<T extends Service$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Service$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    availableAddOns<T extends Service$availableAddOnsArgs<ExtArgs> = {}>(args?: Subset<T, Service$availableAddOnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Service base type for findUnique actions
   */
  export type ServiceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUnique
   */
  export interface ServiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service base type for findFirst actions
   */
  export type ServiceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }

  /**
   * Service findFirst
   */
  export interface ServiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: Enumerable<ServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: Enumerable<ServiceScalarFieldEnum>
  }


  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }


  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: Enumerable<ServiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }


  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }


  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }


  /**
   * Service.reservations
   */
  export type Service$reservationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: Enumerable<ReservationOrderByWithRelationInput>
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }


  /**
   * Service.availableAddOns
   */
  export type Service$availableAddOnsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnService
     */
    select?: AddOnServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddOnServiceInclude<ExtArgs> | null
    where?: AddOnServiceWhereInput
    orderBy?: Enumerable<AddOnServiceOrderByWithRelationInput>
    cursor?: AddOnServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AddOnServiceScalarFieldEnum>
  }


  /**
   * Service without action
   */
  export type ServiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
  }



  /**
   * Model AddOnService
   */


  export type AggregateAddOnService = {
    _count: AddOnServiceCountAggregateOutputType | null
    _avg: AddOnServiceAvgAggregateOutputType | null
    _sum: AddOnServiceSumAggregateOutputType | null
    _min: AddOnServiceMinAggregateOutputType | null
    _max: AddOnServiceMaxAggregateOutputType | null
  }

  export type AddOnServiceAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type AddOnServiceSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type AddOnServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    duration: number | null
    serviceId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddOnServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    duration: number | null
    serviceId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddOnServiceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    duration: number
    serviceId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddOnServiceAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type AddOnServiceSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type AddOnServiceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    serviceId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddOnServiceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    serviceId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddOnServiceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    duration?: true
    serviceId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddOnServiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOnService to aggregate.
     */
    where?: AddOnServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOnServices to fetch.
     */
    orderBy?: Enumerable<AddOnServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddOnServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOnServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOnServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddOnServices
    **/
    _count?: true | AddOnServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddOnServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddOnServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddOnServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddOnServiceMaxAggregateInputType
  }

  export type GetAddOnServiceAggregateType<T extends AddOnServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateAddOnService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddOnService[P]>
      : GetScalarType<T[P], AggregateAddOnService[P]>
  }




  export type AddOnServiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AddOnServiceWhereInput
    orderBy?: Enumerable<AddOnServiceOrderByWithAggregationInput>
    by: AddOnServiceScalarFieldEnum[]
    having?: AddOnServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddOnServiceCountAggregateInputType | true
    _avg?: AddOnServiceAvgAggregateInputType
    _sum?: AddOnServiceSumAggregateInputType
    _min?: AddOnServiceMinAggregateInputType
    _max?: AddOnServiceMaxAggregateInputType
  }


  export type AddOnServiceGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    duration: number | null
    serviceId: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AddOnServiceCountAggregateOutputType | null
    _avg: AddOnServiceAvgAggregateOutputType | null
    _sum: AddOnServiceSumAggregateOutputType | null
    _min: AddOnServiceMinAggregateOutputType | null
    _max: AddOnServiceMaxAggregateOutputType | null
  }

  type GetAddOnServiceGroupByPayload<T extends AddOnServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AddOnServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddOnServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddOnServiceGroupByOutputType[P]>
            : GetScalarType<T[P], AddOnServiceGroupByOutputType[P]>
        }
      >
    >


  export type AddOnServiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    serviceId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceArgs<ExtArgs>
    reservationAddOns?: boolean | AddOnService$reservationAddOnsArgs<ExtArgs>
    _count?: boolean | AddOnServiceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["addOnService"]>

  export type AddOnServiceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    duration?: boolean
    serviceId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddOnServiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceArgs<ExtArgs>
    reservationAddOns?: boolean | AddOnService$reservationAddOnsArgs<ExtArgs>
    _count?: boolean | AddOnServiceCountOutputTypeArgs<ExtArgs>
  }


  type AddOnServiceGetPayload<S extends boolean | null | undefined | AddOnServiceArgs> = $Types.GetResult<AddOnServicePayload, S>

  type AddOnServiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AddOnServiceFindManyArgs, 'select' | 'include'> & {
      select?: AddOnServiceCountAggregateInputType | true
    }

  export interface AddOnServiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddOnService'], meta: { name: 'AddOnService' } }
    /**
     * Find zero or one AddOnService that matches the filter.
     * @param {AddOnServiceFindUniqueArgs} args - Arguments to find a AddOnService
     * @example
     * // Get one AddOnService
     * const addOnService = await prisma.addOnService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddOnServiceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddOnServiceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AddOnService'> extends True ? Prisma__AddOnServiceClient<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AddOnServiceClient<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AddOnService that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddOnServiceFindUniqueOrThrowArgs} args - Arguments to find a AddOnService
     * @example
     * // Get one AddOnService
     * const addOnService = await prisma.addOnService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddOnServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddOnServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddOnServiceClient<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AddOnService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnServiceFindFirstArgs} args - Arguments to find a AddOnService
     * @example
     * // Get one AddOnService
     * const addOnService = await prisma.addOnService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddOnServiceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddOnServiceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AddOnService'> extends True ? Prisma__AddOnServiceClient<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AddOnServiceClient<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AddOnService that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnServiceFindFirstOrThrowArgs} args - Arguments to find a AddOnService
     * @example
     * // Get one AddOnService
     * const addOnService = await prisma.addOnService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddOnServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddOnServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddOnServiceClient<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AddOnServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddOnServices
     * const addOnServices = await prisma.addOnService.findMany()
     * 
     * // Get first 10 AddOnServices
     * const addOnServices = await prisma.addOnService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addOnServiceWithIdOnly = await prisma.addOnService.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddOnServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddOnServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AddOnService.
     * @param {AddOnServiceCreateArgs} args - Arguments to create a AddOnService.
     * @example
     * // Create one AddOnService
     * const AddOnService = await prisma.addOnService.create({
     *   data: {
     *     // ... data to create a AddOnService
     *   }
     * })
     * 
    **/
    create<T extends AddOnServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AddOnServiceCreateArgs<ExtArgs>>
    ): Prisma__AddOnServiceClient<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AddOnServices.
     *     @param {AddOnServiceCreateManyArgs} args - Arguments to create many AddOnServices.
     *     @example
     *     // Create many AddOnServices
     *     const addOnService = await prisma.addOnService.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddOnServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddOnServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddOnService.
     * @param {AddOnServiceDeleteArgs} args - Arguments to delete one AddOnService.
     * @example
     * // Delete one AddOnService
     * const AddOnService = await prisma.addOnService.delete({
     *   where: {
     *     // ... filter to delete one AddOnService
     *   }
     * })
     * 
    **/
    delete<T extends AddOnServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AddOnServiceDeleteArgs<ExtArgs>>
    ): Prisma__AddOnServiceClient<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AddOnService.
     * @param {AddOnServiceUpdateArgs} args - Arguments to update one AddOnService.
     * @example
     * // Update one AddOnService
     * const addOnService = await prisma.addOnService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddOnServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AddOnServiceUpdateArgs<ExtArgs>>
    ): Prisma__AddOnServiceClient<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AddOnServices.
     * @param {AddOnServiceDeleteManyArgs} args - Arguments to filter AddOnServices to delete.
     * @example
     * // Delete a few AddOnServices
     * const { count } = await prisma.addOnService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddOnServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddOnServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddOnServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddOnServices
     * const addOnService = await prisma.addOnService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddOnServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AddOnServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddOnService.
     * @param {AddOnServiceUpsertArgs} args - Arguments to update or create a AddOnService.
     * @example
     * // Update or create a AddOnService
     * const addOnService = await prisma.addOnService.upsert({
     *   create: {
     *     // ... data to create a AddOnService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddOnService we want to update
     *   }
     * })
    **/
    upsert<T extends AddOnServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AddOnServiceUpsertArgs<ExtArgs>>
    ): Prisma__AddOnServiceClient<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AddOnServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnServiceCountArgs} args - Arguments to filter AddOnServices to count.
     * @example
     * // Count the number of AddOnServices
     * const count = await prisma.addOnService.count({
     *   where: {
     *     // ... the filter for the AddOnServices we want to count
     *   }
     * })
    **/
    count<T extends AddOnServiceCountArgs>(
      args?: Subset<T, AddOnServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddOnServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddOnService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddOnServiceAggregateArgs>(args: Subset<T, AddOnServiceAggregateArgs>): Prisma.PrismaPromise<GetAddOnServiceAggregateType<T>>

    /**
     * Group by AddOnService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddOnServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddOnServiceGroupByArgs['orderBy'] }
        : { orderBy?: AddOnServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddOnServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddOnServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AddOnService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddOnServiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    service<T extends ServiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceArgs<ExtArgs>>): Prisma__ServiceClient<$Types.GetResult<ServicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    reservationAddOns<T extends AddOnService$reservationAddOnsArgs<ExtArgs> = {}>(args?: Subset<T, AddOnService$reservationAddOnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AddOnService base type for findUnique actions
   */
  export type AddOnServiceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnService
     */
    select?: AddOnServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddOnServiceInclude<ExtArgs> | null
    /**
     * Filter, which AddOnService to fetch.
     */
    where: AddOnServiceWhereUniqueInput
  }

  /**
   * AddOnService findUnique
   */
  export interface AddOnServiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AddOnServiceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AddOnService findUniqueOrThrow
   */
  export type AddOnServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnService
     */
    select?: AddOnServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddOnServiceInclude<ExtArgs> | null
    /**
     * Filter, which AddOnService to fetch.
     */
    where: AddOnServiceWhereUniqueInput
  }


  /**
   * AddOnService base type for findFirst actions
   */
  export type AddOnServiceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnService
     */
    select?: AddOnServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddOnServiceInclude<ExtArgs> | null
    /**
     * Filter, which AddOnService to fetch.
     */
    where?: AddOnServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOnServices to fetch.
     */
    orderBy?: Enumerable<AddOnServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOnServices.
     */
    cursor?: AddOnServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOnServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOnServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOnServices.
     */
    distinct?: Enumerable<AddOnServiceScalarFieldEnum>
  }

  /**
   * AddOnService findFirst
   */
  export interface AddOnServiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AddOnServiceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AddOnService findFirstOrThrow
   */
  export type AddOnServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnService
     */
    select?: AddOnServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddOnServiceInclude<ExtArgs> | null
    /**
     * Filter, which AddOnService to fetch.
     */
    where?: AddOnServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOnServices to fetch.
     */
    orderBy?: Enumerable<AddOnServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOnServices.
     */
    cursor?: AddOnServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOnServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOnServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOnServices.
     */
    distinct?: Enumerable<AddOnServiceScalarFieldEnum>
  }


  /**
   * AddOnService findMany
   */
  export type AddOnServiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnService
     */
    select?: AddOnServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddOnServiceInclude<ExtArgs> | null
    /**
     * Filter, which AddOnServices to fetch.
     */
    where?: AddOnServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOnServices to fetch.
     */
    orderBy?: Enumerable<AddOnServiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddOnServices.
     */
    cursor?: AddOnServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOnServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOnServices.
     */
    skip?: number
    distinct?: Enumerable<AddOnServiceScalarFieldEnum>
  }


  /**
   * AddOnService create
   */
  export type AddOnServiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnService
     */
    select?: AddOnServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddOnServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a AddOnService.
     */
    data: XOR<AddOnServiceCreateInput, AddOnServiceUncheckedCreateInput>
  }


  /**
   * AddOnService createMany
   */
  export type AddOnServiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddOnServices.
     */
    data: Enumerable<AddOnServiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AddOnService update
   */
  export type AddOnServiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnService
     */
    select?: AddOnServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddOnServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a AddOnService.
     */
    data: XOR<AddOnServiceUpdateInput, AddOnServiceUncheckedUpdateInput>
    /**
     * Choose, which AddOnService to update.
     */
    where: AddOnServiceWhereUniqueInput
  }


  /**
   * AddOnService updateMany
   */
  export type AddOnServiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddOnServices.
     */
    data: XOR<AddOnServiceUpdateManyMutationInput, AddOnServiceUncheckedUpdateManyInput>
    /**
     * Filter which AddOnServices to update
     */
    where?: AddOnServiceWhereInput
  }


  /**
   * AddOnService upsert
   */
  export type AddOnServiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnService
     */
    select?: AddOnServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddOnServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the AddOnService to update in case it exists.
     */
    where: AddOnServiceWhereUniqueInput
    /**
     * In case the AddOnService found by the `where` argument doesn't exist, create a new AddOnService with this data.
     */
    create: XOR<AddOnServiceCreateInput, AddOnServiceUncheckedCreateInput>
    /**
     * In case the AddOnService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddOnServiceUpdateInput, AddOnServiceUncheckedUpdateInput>
  }


  /**
   * AddOnService delete
   */
  export type AddOnServiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnService
     */
    select?: AddOnServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddOnServiceInclude<ExtArgs> | null
    /**
     * Filter which AddOnService to delete.
     */
    where: AddOnServiceWhereUniqueInput
  }


  /**
   * AddOnService deleteMany
   */
  export type AddOnServiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOnServices to delete
     */
    where?: AddOnServiceWhereInput
  }


  /**
   * AddOnService.reservationAddOns
   */
  export type AddOnService$reservationAddOnsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
    where?: ReservationAddOnWhereInput
    orderBy?: Enumerable<ReservationAddOnOrderByWithRelationInput>
    cursor?: ReservationAddOnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReservationAddOnScalarFieldEnum>
  }


  /**
   * AddOnService without action
   */
  export type AddOnServiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOnService
     */
    select?: AddOnServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddOnServiceInclude<ExtArgs> | null
  }



  /**
   * Model ReservationAddOn
   */


  export type AggregateReservationAddOn = {
    _count: ReservationAddOnCountAggregateOutputType | null
    _avg: ReservationAddOnAvgAggregateOutputType | null
    _sum: ReservationAddOnSumAggregateOutputType | null
    _min: ReservationAddOnMinAggregateOutputType | null
    _max: ReservationAddOnMaxAggregateOutputType | null
  }

  export type ReservationAddOnAvgAggregateOutputType = {
    price: number | null
  }

  export type ReservationAddOnSumAggregateOutputType = {
    price: number | null
  }

  export type ReservationAddOnMinAggregateOutputType = {
    id: string | null
    reservationId: string | null
    addOnId: string | null
    price: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservationAddOnMaxAggregateOutputType = {
    id: string | null
    reservationId: string | null
    addOnId: string | null
    price: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservationAddOnCountAggregateOutputType = {
    id: number
    reservationId: number
    addOnId: number
    price: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReservationAddOnAvgAggregateInputType = {
    price?: true
  }

  export type ReservationAddOnSumAggregateInputType = {
    price?: true
  }

  export type ReservationAddOnMinAggregateInputType = {
    id?: true
    reservationId?: true
    addOnId?: true
    price?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservationAddOnMaxAggregateInputType = {
    id?: true
    reservationId?: true
    addOnId?: true
    price?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservationAddOnCountAggregateInputType = {
    id?: true
    reservationId?: true
    addOnId?: true
    price?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReservationAddOnAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReservationAddOn to aggregate.
     */
    where?: ReservationAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationAddOns to fetch.
     */
    orderBy?: Enumerable<ReservationAddOnOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReservationAddOns
    **/
    _count?: true | ReservationAddOnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAddOnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationAddOnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationAddOnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationAddOnMaxAggregateInputType
  }

  export type GetReservationAddOnAggregateType<T extends ReservationAddOnAggregateArgs> = {
        [P in keyof T & keyof AggregateReservationAddOn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservationAddOn[P]>
      : GetScalarType<T[P], AggregateReservationAddOn[P]>
  }




  export type ReservationAddOnGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReservationAddOnWhereInput
    orderBy?: Enumerable<ReservationAddOnOrderByWithAggregationInput>
    by: ReservationAddOnScalarFieldEnum[]
    having?: ReservationAddOnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationAddOnCountAggregateInputType | true
    _avg?: ReservationAddOnAvgAggregateInputType
    _sum?: ReservationAddOnSumAggregateInputType
    _min?: ReservationAddOnMinAggregateInputType
    _max?: ReservationAddOnMaxAggregateInputType
  }


  export type ReservationAddOnGroupByOutputType = {
    id: string
    reservationId: string
    addOnId: string
    price: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReservationAddOnCountAggregateOutputType | null
    _avg: ReservationAddOnAvgAggregateOutputType | null
    _sum: ReservationAddOnSumAggregateOutputType | null
    _min: ReservationAddOnMinAggregateOutputType | null
    _max: ReservationAddOnMaxAggregateOutputType | null
  }

  type GetReservationAddOnGroupByPayload<T extends ReservationAddOnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReservationAddOnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationAddOnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationAddOnGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationAddOnGroupByOutputType[P]>
        }
      >
    >


  export type ReservationAddOnSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reservationId?: boolean
    addOnId?: boolean
    price?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reservation?: boolean | ReservationArgs<ExtArgs>
    addOn?: boolean | AddOnServiceArgs<ExtArgs>
  }, ExtArgs["result"]["reservationAddOn"]>

  export type ReservationAddOnSelectScalar = {
    id?: boolean
    reservationId?: boolean
    addOnId?: boolean
    price?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReservationAddOnInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    reservation?: boolean | ReservationArgs<ExtArgs>
    addOn?: boolean | AddOnServiceArgs<ExtArgs>
  }


  type ReservationAddOnGetPayload<S extends boolean | null | undefined | ReservationAddOnArgs> = $Types.GetResult<ReservationAddOnPayload, S>

  type ReservationAddOnCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ReservationAddOnFindManyArgs, 'select' | 'include'> & {
      select?: ReservationAddOnCountAggregateInputType | true
    }

  export interface ReservationAddOnDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReservationAddOn'], meta: { name: 'ReservationAddOn' } }
    /**
     * Find zero or one ReservationAddOn that matches the filter.
     * @param {ReservationAddOnFindUniqueArgs} args - Arguments to find a ReservationAddOn
     * @example
     * // Get one ReservationAddOn
     * const reservationAddOn = await prisma.reservationAddOn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReservationAddOnFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReservationAddOnFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReservationAddOn'> extends True ? Prisma__ReservationAddOnClient<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ReservationAddOnClient<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ReservationAddOn that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReservationAddOnFindUniqueOrThrowArgs} args - Arguments to find a ReservationAddOn
     * @example
     * // Get one ReservationAddOn
     * const reservationAddOn = await prisma.reservationAddOn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReservationAddOnFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReservationAddOnFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReservationAddOnClient<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ReservationAddOn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAddOnFindFirstArgs} args - Arguments to find a ReservationAddOn
     * @example
     * // Get one ReservationAddOn
     * const reservationAddOn = await prisma.reservationAddOn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReservationAddOnFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReservationAddOnFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReservationAddOn'> extends True ? Prisma__ReservationAddOnClient<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ReservationAddOnClient<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ReservationAddOn that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAddOnFindFirstOrThrowArgs} args - Arguments to find a ReservationAddOn
     * @example
     * // Get one ReservationAddOn
     * const reservationAddOn = await prisma.reservationAddOn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReservationAddOnFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReservationAddOnFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReservationAddOnClient<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ReservationAddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAddOnFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReservationAddOns
     * const reservationAddOns = await prisma.reservationAddOn.findMany()
     * 
     * // Get first 10 ReservationAddOns
     * const reservationAddOns = await prisma.reservationAddOn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationAddOnWithIdOnly = await prisma.reservationAddOn.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReservationAddOnFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReservationAddOnFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ReservationAddOn.
     * @param {ReservationAddOnCreateArgs} args - Arguments to create a ReservationAddOn.
     * @example
     * // Create one ReservationAddOn
     * const ReservationAddOn = await prisma.reservationAddOn.create({
     *   data: {
     *     // ... data to create a ReservationAddOn
     *   }
     * })
     * 
    **/
    create<T extends ReservationAddOnCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReservationAddOnCreateArgs<ExtArgs>>
    ): Prisma__ReservationAddOnClient<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ReservationAddOns.
     *     @param {ReservationAddOnCreateManyArgs} args - Arguments to create many ReservationAddOns.
     *     @example
     *     // Create many ReservationAddOns
     *     const reservationAddOn = await prisma.reservationAddOn.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReservationAddOnCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReservationAddOnCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReservationAddOn.
     * @param {ReservationAddOnDeleteArgs} args - Arguments to delete one ReservationAddOn.
     * @example
     * // Delete one ReservationAddOn
     * const ReservationAddOn = await prisma.reservationAddOn.delete({
     *   where: {
     *     // ... filter to delete one ReservationAddOn
     *   }
     * })
     * 
    **/
    delete<T extends ReservationAddOnDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReservationAddOnDeleteArgs<ExtArgs>>
    ): Prisma__ReservationAddOnClient<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ReservationAddOn.
     * @param {ReservationAddOnUpdateArgs} args - Arguments to update one ReservationAddOn.
     * @example
     * // Update one ReservationAddOn
     * const reservationAddOn = await prisma.reservationAddOn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReservationAddOnUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReservationAddOnUpdateArgs<ExtArgs>>
    ): Prisma__ReservationAddOnClient<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ReservationAddOns.
     * @param {ReservationAddOnDeleteManyArgs} args - Arguments to filter ReservationAddOns to delete.
     * @example
     * // Delete a few ReservationAddOns
     * const { count } = await prisma.reservationAddOn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReservationAddOnDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReservationAddOnDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReservationAddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAddOnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReservationAddOns
     * const reservationAddOn = await prisma.reservationAddOn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReservationAddOnUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReservationAddOnUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReservationAddOn.
     * @param {ReservationAddOnUpsertArgs} args - Arguments to update or create a ReservationAddOn.
     * @example
     * // Update or create a ReservationAddOn
     * const reservationAddOn = await prisma.reservationAddOn.upsert({
     *   create: {
     *     // ... data to create a ReservationAddOn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReservationAddOn we want to update
     *   }
     * })
    **/
    upsert<T extends ReservationAddOnUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReservationAddOnUpsertArgs<ExtArgs>>
    ): Prisma__ReservationAddOnClient<$Types.GetResult<ReservationAddOnPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ReservationAddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAddOnCountArgs} args - Arguments to filter ReservationAddOns to count.
     * @example
     * // Count the number of ReservationAddOns
     * const count = await prisma.reservationAddOn.count({
     *   where: {
     *     // ... the filter for the ReservationAddOns we want to count
     *   }
     * })
    **/
    count<T extends ReservationAddOnCountArgs>(
      args?: Subset<T, ReservationAddOnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationAddOnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReservationAddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAddOnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAddOnAggregateArgs>(args: Subset<T, ReservationAddOnAggregateArgs>): Prisma.PrismaPromise<GetReservationAddOnAggregateType<T>>

    /**
     * Group by ReservationAddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAddOnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationAddOnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationAddOnGroupByArgs['orderBy'] }
        : { orderBy?: ReservationAddOnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationAddOnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationAddOnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ReservationAddOn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReservationAddOnClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reservation<T extends ReservationArgs<ExtArgs> = {}>(args?: Subset<T, ReservationArgs<ExtArgs>>): Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    addOn<T extends AddOnServiceArgs<ExtArgs> = {}>(args?: Subset<T, AddOnServiceArgs<ExtArgs>>): Prisma__AddOnServiceClient<$Types.GetResult<AddOnServicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ReservationAddOn base type for findUnique actions
   */
  export type ReservationAddOnFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ReservationAddOn to fetch.
     */
    where: ReservationAddOnWhereUniqueInput
  }

  /**
   * ReservationAddOn findUnique
   */
  export interface ReservationAddOnFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReservationAddOnFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReservationAddOn findUniqueOrThrow
   */
  export type ReservationAddOnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ReservationAddOn to fetch.
     */
    where: ReservationAddOnWhereUniqueInput
  }


  /**
   * ReservationAddOn base type for findFirst actions
   */
  export type ReservationAddOnFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ReservationAddOn to fetch.
     */
    where?: ReservationAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationAddOns to fetch.
     */
    orderBy?: Enumerable<ReservationAddOnOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReservationAddOns.
     */
    cursor?: ReservationAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReservationAddOns.
     */
    distinct?: Enumerable<ReservationAddOnScalarFieldEnum>
  }

  /**
   * ReservationAddOn findFirst
   */
  export interface ReservationAddOnFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReservationAddOnFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReservationAddOn findFirstOrThrow
   */
  export type ReservationAddOnFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ReservationAddOn to fetch.
     */
    where?: ReservationAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationAddOns to fetch.
     */
    orderBy?: Enumerable<ReservationAddOnOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReservationAddOns.
     */
    cursor?: ReservationAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReservationAddOns.
     */
    distinct?: Enumerable<ReservationAddOnScalarFieldEnum>
  }


  /**
   * ReservationAddOn findMany
   */
  export type ReservationAddOnFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ReservationAddOns to fetch.
     */
    where?: ReservationAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationAddOns to fetch.
     */
    orderBy?: Enumerable<ReservationAddOnOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReservationAddOns.
     */
    cursor?: ReservationAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationAddOns.
     */
    skip?: number
    distinct?: Enumerable<ReservationAddOnScalarFieldEnum>
  }


  /**
   * ReservationAddOn create
   */
  export type ReservationAddOnCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
    /**
     * The data needed to create a ReservationAddOn.
     */
    data: XOR<ReservationAddOnCreateInput, ReservationAddOnUncheckedCreateInput>
  }


  /**
   * ReservationAddOn createMany
   */
  export type ReservationAddOnCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReservationAddOns.
     */
    data: Enumerable<ReservationAddOnCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReservationAddOn update
   */
  export type ReservationAddOnUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
    /**
     * The data needed to update a ReservationAddOn.
     */
    data: XOR<ReservationAddOnUpdateInput, ReservationAddOnUncheckedUpdateInput>
    /**
     * Choose, which ReservationAddOn to update.
     */
    where: ReservationAddOnWhereUniqueInput
  }


  /**
   * ReservationAddOn updateMany
   */
  export type ReservationAddOnUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReservationAddOns.
     */
    data: XOR<ReservationAddOnUpdateManyMutationInput, ReservationAddOnUncheckedUpdateManyInput>
    /**
     * Filter which ReservationAddOns to update
     */
    where?: ReservationAddOnWhereInput
  }


  /**
   * ReservationAddOn upsert
   */
  export type ReservationAddOnUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
    /**
     * The filter to search for the ReservationAddOn to update in case it exists.
     */
    where: ReservationAddOnWhereUniqueInput
    /**
     * In case the ReservationAddOn found by the `where` argument doesn't exist, create a new ReservationAddOn with this data.
     */
    create: XOR<ReservationAddOnCreateInput, ReservationAddOnUncheckedCreateInput>
    /**
     * In case the ReservationAddOn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationAddOnUpdateInput, ReservationAddOnUncheckedUpdateInput>
  }


  /**
   * ReservationAddOn delete
   */
  export type ReservationAddOnDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
    /**
     * Filter which ReservationAddOn to delete.
     */
    where: ReservationAddOnWhereUniqueInput
  }


  /**
   * ReservationAddOn deleteMany
   */
  export type ReservationAddOnDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReservationAddOns to delete
     */
    where?: ReservationAddOnWhereInput
  }


  /**
   * ReservationAddOn without action
   */
  export type ReservationAddOnArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationAddOn
     */
    select?: ReservationAddOnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationAddOnInclude<ExtArgs> | null
  }



  /**
   * Model Resource
   */


  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    capacity: number | null
  }

  export type ResourceSumAggregateOutputType = {
    capacity: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: ResourceType | null
    description: string | null
    capacity: number | null
    isActive: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: ResourceType | null
    description: string | null
    capacity: number | null
    isActive: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    capacity: number
    isActive: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    capacity?: true
  }

  export type ResourceSumAggregateInputType = {
    capacity?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    capacity?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    capacity?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    capacity?: true
    isActive?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: Enumerable<ResourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: Enumerable<ResourceOrderByWithAggregationInput>
    by: ResourceScalarFieldEnum[]
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }


  export type ResourceGroupByOutputType = {
    id: string
    name: string
    type: ResourceType
    description: string | null
    capacity: number | null
    isActive: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    capacity?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reservations?: boolean | Resource$reservationsArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    capacity?: boolean
    isActive?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResourceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    reservations?: boolean | Resource$reservationsArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeArgs<ExtArgs>
  }


  type ResourceGetPayload<S extends boolean | null | undefined | ResourceArgs> = $Types.GetResult<ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ResourceFindManyArgs, 'select' | 'include'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResourceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Resource'> extends True ? Prisma__ResourceClient<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ResourceClient<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Resource that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResourceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Resource'> extends True ? Prisma__ResourceClient<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ResourceClient<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Resource that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResourceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
    **/
    create<T extends ResourceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Resources.
     *     @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     *     @example
     *     // Create many Resources
     *     const resource = await prisma.resource.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResourceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
    **/
    delete<T extends ResourceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResourceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResourceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResourceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
    **/
    upsert<T extends ResourceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>
    ): Prisma__ResourceClient<$Types.GetResult<ResourcePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reservations<T extends Resource$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Resource$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Resource base type for findUnique actions
   */
  export type ResourceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUnique
   */
  export interface ResourceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ResourceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }


  /**
   * Resource base type for findFirst actions
   */
  export type ResourceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: Enumerable<ResourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: Enumerable<ResourceScalarFieldEnum>
  }

  /**
   * Resource findFirst
   */
  export interface ResourceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ResourceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: Enumerable<ResourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: Enumerable<ResourceScalarFieldEnum>
  }


  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: Enumerable<ResourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: Enumerable<ResourceScalarFieldEnum>
  }


  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }


  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: Enumerable<ResourceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }


  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
  }


  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }


  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }


  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
  }


  /**
   * Resource.reservations
   */
  export type Resource$reservationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: Enumerable<ReservationOrderByWithRelationInput>
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }


  /**
   * Resource without action
   */
  export type ResourceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResourceInclude<ExtArgs> | null
  }



  /**
   * Model Staff
   */


  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    role: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    role: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phone: number
    role: number
    workSchedule: number
    specialties: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    workSchedule?: true
    specialties?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: Enumerable<StaffOrderByWithAggregationInput>
    by: StaffScalarFieldEnum[]
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }


  export type StaffGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    phone: string | null
    role: string
    workSchedule: JsonValue | null
    specialties: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    workSchedule?: boolean
    specialties?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedReservations?: boolean | Staff$assignedReservationsArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    workSchedule?: boolean
    specialties?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    assignedReservations?: boolean | Staff$assignedReservationsArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeArgs<ExtArgs>
  }


  type StaffGetPayload<S extends boolean | null | undefined | StaffArgs> = $Types.GetResult<StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StaffFindManyArgs, 'select' | 'include'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StaffFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Staff'> extends True ? Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Staff that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StaffFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Staff'> extends True ? Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Staff that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StaffFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<StaffPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
    **/
    create<T extends StaffCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffCreateArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Staff.
     *     @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     *     @example
     *     // Create many Staff
     *     const staff = await prisma.staff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StaffCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
    **/
    delete<T extends StaffDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StaffUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StaffDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StaffUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
    **/
    upsert<T extends StaffUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>
    ): Prisma__StaffClient<$Types.GetResult<StaffPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    assignedReservations<T extends Staff$assignedReservationsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$assignedReservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Staff base type for findUnique actions
   */
  export type StaffFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUnique
   */
  export interface StaffFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StaffFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff base type for findFirst actions
   */
  export type StaffFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: Enumerable<StaffScalarFieldEnum>
  }

  /**
   * Staff findFirst
   */
  export interface StaffFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StaffFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }


  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: Enumerable<StaffCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
  }


  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }


  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }


  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
  }


  /**
   * Staff.assignedReservations
   */
  export type Staff$assignedReservationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: Enumerable<ReservationOrderByWithRelationInput>
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }


  /**
   * Staff without action
   */
  export type StaffArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StaffInclude<ExtArgs> | null
  }



  /**
   * Model Invoice
   */


  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    discount: number | null
    total: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    discount: number | null
    total: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    customerId: string | null
    reservationId: string | null
    issueDate: Date | null
    dueDate: Date | null
    status: InvoiceStatus | null
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    discount: number | null
    total: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    customerId: string | null
    reservationId: string | null
    issueDate: Date | null
    dueDate: Date | null
    status: InvoiceStatus | null
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    discount: number | null
    total: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    customerId: number
    reservationId: number
    issueDate: number
    dueDate: number
    status: number
    subtotal: number
    taxRate: number
    taxAmount: number
    discount: number
    total: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discount?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discount?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    customerId?: true
    reservationId?: true
    issueDate?: true
    dueDate?: true
    status?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discount?: true
    total?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    customerId?: true
    reservationId?: true
    issueDate?: true
    dueDate?: true
    status?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discount?: true
    total?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    customerId?: true
    reservationId?: true
    issueDate?: true
    dueDate?: true
    status?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discount?: true
    total?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: Enumerable<InvoiceOrderByWithAggregationInput>
    by: InvoiceScalarFieldEnum[]
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }


  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    customerId: string
    reservationId: string | null
    issueDate: Date
    dueDate: Date
    status: InvoiceStatus
    subtotal: number
    taxRate: number
    taxAmount: number
    discount: number
    total: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    reservationId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    status?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discount?: boolean
    total?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerArgs<ExtArgs>
    reservation?: boolean | ReservationArgs<ExtArgs>
    lineItems?: boolean | Invoice$lineItemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    reservationId?: boolean
    issueDate?: boolean
    dueDate?: boolean
    status?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discount?: boolean
    total?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerArgs<ExtArgs>
    reservation?: boolean | ReservationArgs<ExtArgs>
    lineItems?: boolean | Invoice$lineItemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeArgs<ExtArgs>
  }


  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceArgs> = $Types.GetResult<InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoiceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Invoice'> extends True ? Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoiceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Invoice'> extends True ? Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
    **/
    create<T extends InvoiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Invoices.
     *     @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoice = await prisma.invoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
    **/
    delete<T extends InvoiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
    **/
    upsert<T extends InvoiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    customer<T extends CustomerArgs<ExtArgs> = {}>(args?: Subset<T, CustomerArgs<ExtArgs>>): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    reservation<T extends ReservationArgs<ExtArgs> = {}>(args?: Subset<T, ReservationArgs<ExtArgs>>): Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    lineItems<T extends Invoice$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'findMany', never>| Null>;

    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Invoice base type for findUnique actions
   */
  export type InvoiceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUnique
   */
  export interface InvoiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvoiceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice base type for findFirst actions
   */
  export type InvoiceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }

  /**
   * Invoice findFirst
   */
  export interface InvoiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvoiceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: Enumerable<InvoiceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: Enumerable<InvoiceScalarFieldEnum>
  }


  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }


  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: Enumerable<InvoiceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }


  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }


  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }


  /**
   * Invoice.lineItems
   */
  export type Invoice$lineItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    where?: InvoiceLineItemWhereInput
    orderBy?: Enumerable<InvoiceLineItemOrderByWithRelationInput>
    cursor?: InvoiceLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InvoiceLineItemScalarFieldEnum>
  }


  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Invoice without action
   */
  export type InvoiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
  }



  /**
   * Model InvoiceLineItem
   */


  export type AggregateInvoiceLineItem = {
    _count: InvoiceLineItemCountAggregateOutputType | null
    _avg: InvoiceLineItemAvgAggregateOutputType | null
    _sum: InvoiceLineItemSumAggregateOutputType | null
    _min: InvoiceLineItemMinAggregateOutputType | null
    _max: InvoiceLineItemMaxAggregateOutputType | null
  }

  export type InvoiceLineItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    amount: number | null
  }

  export type InvoiceLineItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    amount: number | null
  }

  export type InvoiceLineItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    amount: number | null
    taxable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceLineItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    amount: number | null
    taxable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceLineItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    quantity: number
    unitPrice: number
    amount: number
    taxable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceLineItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    amount?: true
  }

  export type InvoiceLineItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    amount?: true
  }

  export type InvoiceLineItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    taxable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceLineItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    taxable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceLineItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    amount?: true
    taxable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceLineItemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLineItem to aggregate.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: Enumerable<InvoiceLineItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceLineItems
    **/
    _count?: true | InvoiceLineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceLineItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceLineItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceLineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceLineItemMaxAggregateInputType
  }

  export type GetInvoiceLineItemAggregateType<T extends InvoiceLineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceLineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceLineItem[P]>
      : GetScalarType<T[P], AggregateInvoiceLineItem[P]>
  }




  export type InvoiceLineItemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceLineItemWhereInput
    orderBy?: Enumerable<InvoiceLineItemOrderByWithAggregationInput>
    by: InvoiceLineItemScalarFieldEnum[]
    having?: InvoiceLineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceLineItemCountAggregateInputType | true
    _avg?: InvoiceLineItemAvgAggregateInputType
    _sum?: InvoiceLineItemSumAggregateInputType
    _min?: InvoiceLineItemMinAggregateInputType
    _max?: InvoiceLineItemMaxAggregateInputType
  }


  export type InvoiceLineItemGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    quantity: number
    unitPrice: number
    amount: number
    taxable: boolean
    createdAt: Date
    updatedAt: Date
    _count: InvoiceLineItemCountAggregateOutputType | null
    _avg: InvoiceLineItemAvgAggregateOutputType | null
    _sum: InvoiceLineItemSumAggregateOutputType | null
    _min: InvoiceLineItemMinAggregateOutputType | null
    _max: InvoiceLineItemMaxAggregateOutputType | null
  }

  type GetInvoiceLineItemGroupByPayload<T extends InvoiceLineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InvoiceLineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceLineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceLineItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceLineItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceLineItemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    taxable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLineItem"]>

  export type InvoiceLineItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    amount?: boolean
    taxable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceLineItemInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceArgs<ExtArgs>
  }


  type InvoiceLineItemGetPayload<S extends boolean | null | undefined | InvoiceLineItemArgs> = $Types.GetResult<InvoiceLineItemPayload, S>

  type InvoiceLineItemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InvoiceLineItemFindManyArgs, 'select' | 'include'> & {
      select?: InvoiceLineItemCountAggregateInputType | true
    }

  export interface InvoiceLineItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceLineItem'], meta: { name: 'InvoiceLineItem' } }
    /**
     * Find zero or one InvoiceLineItem that matches the filter.
     * @param {InvoiceLineItemFindUniqueArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoiceLineItemFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InvoiceLineItemFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InvoiceLineItem'> extends True ? Prisma__InvoiceLineItemClient<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InvoiceLineItemClient<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one InvoiceLineItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvoiceLineItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvoiceLineItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceLineItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceLineItemClient<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first InvoiceLineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemFindFirstArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoiceLineItemFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InvoiceLineItemFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InvoiceLineItem'> extends True ? Prisma__InvoiceLineItemClient<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InvoiceLineItemClient<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first InvoiceLineItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceLineItem
     * @example
     * // Get one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvoiceLineItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceLineItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceLineItemClient<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more InvoiceLineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceLineItems
     * const invoiceLineItems = await prisma.invoiceLineItem.findMany()
     * 
     * // Get first 10 InvoiceLineItems
     * const invoiceLineItems = await prisma.invoiceLineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceLineItemWithIdOnly = await prisma.invoiceLineItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoiceLineItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceLineItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a InvoiceLineItem.
     * @param {InvoiceLineItemCreateArgs} args - Arguments to create a InvoiceLineItem.
     * @example
     * // Create one InvoiceLineItem
     * const InvoiceLineItem = await prisma.invoiceLineItem.create({
     *   data: {
     *     // ... data to create a InvoiceLineItem
     *   }
     * })
     * 
    **/
    create<T extends InvoiceLineItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceLineItemCreateArgs<ExtArgs>>
    ): Prisma__InvoiceLineItemClient<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many InvoiceLineItems.
     *     @param {InvoiceLineItemCreateManyArgs} args - Arguments to create many InvoiceLineItems.
     *     @example
     *     // Create many InvoiceLineItems
     *     const invoiceLineItem = await prisma.invoiceLineItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoiceLineItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceLineItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvoiceLineItem.
     * @param {InvoiceLineItemDeleteArgs} args - Arguments to delete one InvoiceLineItem.
     * @example
     * // Delete one InvoiceLineItem
     * const InvoiceLineItem = await prisma.invoiceLineItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceLineItem
     *   }
     * })
     * 
    **/
    delete<T extends InvoiceLineItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceLineItemDeleteArgs<ExtArgs>>
    ): Prisma__InvoiceLineItemClient<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one InvoiceLineItem.
     * @param {InvoiceLineItemUpdateArgs} args - Arguments to update one InvoiceLineItem.
     * @example
     * // Update one InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoiceLineItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceLineItemUpdateArgs<ExtArgs>>
    ): Prisma__InvoiceLineItemClient<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more InvoiceLineItems.
     * @param {InvoiceLineItemDeleteManyArgs} args - Arguments to filter InvoiceLineItems to delete.
     * @example
     * // Delete a few InvoiceLineItems
     * const { count } = await prisma.invoiceLineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoiceLineItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceLineItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceLineItems
     * const invoiceLineItem = await prisma.invoiceLineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoiceLineItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceLineItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceLineItem.
     * @param {InvoiceLineItemUpsertArgs} args - Arguments to update or create a InvoiceLineItem.
     * @example
     * // Update or create a InvoiceLineItem
     * const invoiceLineItem = await prisma.invoiceLineItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceLineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceLineItem we want to update
     *   }
     * })
    **/
    upsert<T extends InvoiceLineItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceLineItemUpsertArgs<ExtArgs>>
    ): Prisma__InvoiceLineItemClient<$Types.GetResult<InvoiceLineItemPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of InvoiceLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemCountArgs} args - Arguments to filter InvoiceLineItems to count.
     * @example
     * // Count the number of InvoiceLineItems
     * const count = await prisma.invoiceLineItem.count({
     *   where: {
     *     // ... the filter for the InvoiceLineItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceLineItemCountArgs>(
      args?: Subset<T, InvoiceLineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceLineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceLineItemAggregateArgs>(args: Subset<T, InvoiceLineItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceLineItemAggregateType<T>>

    /**
     * Group by InvoiceLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceLineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceLineItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceLineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceLineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceLineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceLineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvoiceLineItemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    invoice<T extends InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * InvoiceLineItem base type for findUnique actions
   */
  export type InvoiceLineItemFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where: InvoiceLineItemWhereUniqueInput
  }

  /**
   * InvoiceLineItem findUnique
   */
  export interface InvoiceLineItemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvoiceLineItemFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InvoiceLineItem findUniqueOrThrow
   */
  export type InvoiceLineItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where: InvoiceLineItemWhereUniqueInput
  }


  /**
   * InvoiceLineItem base type for findFirst actions
   */
  export type InvoiceLineItemFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: Enumerable<InvoiceLineItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLineItems.
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLineItems.
     */
    distinct?: Enumerable<InvoiceLineItemScalarFieldEnum>
  }

  /**
   * InvoiceLineItem findFirst
   */
  export interface InvoiceLineItemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InvoiceLineItemFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InvoiceLineItem findFirstOrThrow
   */
  export type InvoiceLineItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItem to fetch.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: Enumerable<InvoiceLineItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLineItems.
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLineItems.
     */
    distinct?: Enumerable<InvoiceLineItemScalarFieldEnum>
  }


  /**
   * InvoiceLineItem findMany
   */
  export type InvoiceLineItemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLineItems to fetch.
     */
    where?: InvoiceLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLineItems to fetch.
     */
    orderBy?: Enumerable<InvoiceLineItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceLineItems.
     */
    cursor?: InvoiceLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLineItems.
     */
    skip?: number
    distinct?: Enumerable<InvoiceLineItemScalarFieldEnum>
  }


  /**
   * InvoiceLineItem create
   */
  export type InvoiceLineItemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceLineItem.
     */
    data: XOR<InvoiceLineItemCreateInput, InvoiceLineItemUncheckedCreateInput>
  }


  /**
   * InvoiceLineItem createMany
   */
  export type InvoiceLineItemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceLineItems.
     */
    data: Enumerable<InvoiceLineItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InvoiceLineItem update
   */
  export type InvoiceLineItemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceLineItem.
     */
    data: XOR<InvoiceLineItemUpdateInput, InvoiceLineItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceLineItem to update.
     */
    where: InvoiceLineItemWhereUniqueInput
  }


  /**
   * InvoiceLineItem updateMany
   */
  export type InvoiceLineItemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceLineItems.
     */
    data: XOR<InvoiceLineItemUpdateManyMutationInput, InvoiceLineItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLineItems to update
     */
    where?: InvoiceLineItemWhereInput
  }


  /**
   * InvoiceLineItem upsert
   */
  export type InvoiceLineItemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceLineItem to update in case it exists.
     */
    where: InvoiceLineItemWhereUniqueInput
    /**
     * In case the InvoiceLineItem found by the `where` argument doesn't exist, create a new InvoiceLineItem with this data.
     */
    create: XOR<InvoiceLineItemCreateInput, InvoiceLineItemUncheckedCreateInput>
    /**
     * In case the InvoiceLineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceLineItemUpdateInput, InvoiceLineItemUncheckedUpdateInput>
  }


  /**
   * InvoiceLineItem delete
   */
  export type InvoiceLineItemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceLineItem to delete.
     */
    where: InvoiceLineItemWhereUniqueInput
  }


  /**
   * InvoiceLineItem deleteMany
   */
  export type InvoiceLineItemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLineItems to delete
     */
    where?: InvoiceLineItemWhereInput
  }


  /**
   * InvoiceLineItem without action
   */
  export type InvoiceLineItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLineItem
     */
    select?: InvoiceLineItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceLineItemInclude<ExtArgs> | null
  }



  /**
   * Model Payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
    refundedAmount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
    refundedAmount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    customerId: string | null
    amount: number | null
    method: PaymentMethod | null
    status: PaymentStatus | null
    transactionId: string | null
    paymentDate: Date | null
    refundedAmount: number | null
    refundReason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    customerId: string | null
    amount: number | null
    method: PaymentMethod | null
    status: PaymentStatus | null
    transactionId: string | null
    paymentDate: Date | null
    refundedAmount: number | null
    refundReason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    customerId: number
    amount: number
    method: number
    status: number
    transactionId: number
    paymentDate: number
    gatewayResponse: number
    refundedAmount: number
    refundReason: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    refundedAmount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    refundedAmount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    customerId?: true
    amount?: true
    method?: true
    status?: true
    transactionId?: true
    paymentDate?: true
    refundedAmount?: true
    refundReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    customerId?: true
    amount?: true
    method?: true
    status?: true
    transactionId?: true
    paymentDate?: true
    refundedAmount?: true
    refundReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    customerId?: true
    amount?: true
    method?: true
    status?: true
    transactionId?: true
    paymentDate?: true
    gatewayResponse?: true
    refundedAmount?: true
    refundReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByWithAggregationInput>
    by: PaymentScalarFieldEnum[]
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: string
    invoiceId: string
    customerId: string
    amount: number
    method: PaymentMethod
    status: PaymentStatus
    transactionId: string | null
    paymentDate: Date
    gatewayResponse: JsonValue | null
    refundedAmount: number
    refundReason: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    customerId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    transactionId?: boolean
    paymentDate?: boolean
    gatewayResponse?: boolean
    refundedAmount?: boolean
    refundReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceArgs<ExtArgs>
    customer?: boolean | CustomerArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    customerId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    transactionId?: boolean
    paymentDate?: boolean
    gatewayResponse?: boolean
    refundedAmount?: boolean
    refundReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceArgs<ExtArgs>
    customer?: boolean | CustomerArgs<ExtArgs>
  }


  type PaymentGetPayload<S extends boolean | null | undefined | PaymentArgs> = $Types.GetResult<PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Payment'> extends True ? Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Payment'> extends True ? Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    invoice<T extends InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    customer<T extends CustomerArgs<ExtArgs> = {}>(args?: Subset<T, CustomerArgs<ExtArgs>>): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Payment base type for findUnique actions
   */
  export type PaymentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUnique
   */
  export interface PaymentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PaymentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment base type for findFirst actions
   */
  export type PaymentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }

  /**
   * Payment findFirst
   */
  export interface PaymentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PaymentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: Enumerable<PaymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: Enumerable<PaymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment without action
   */
  export type PaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */


  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    uploaded: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    uploaded: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    customerId: number
    title: number
    description: number
    fileUrl: number
    fileType: number
    fileSize: number
    tags: number
    uploaded: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    customerId?: true
    title?: true
    description?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    uploaded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    customerId?: true
    title?: true
    description?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    uploaded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    customerId?: true
    title?: true
    description?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    tags?: true
    uploaded?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithAggregationInput>
    by: DocumentScalarFieldEnum[]
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }


  export type DocumentGroupByOutputType = {
    id: string
    customerId: string
    title: string
    description: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    tags: string[]
    uploaded: Date
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    tags?: boolean
    uploaded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    customerId?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    tags?: boolean
    uploaded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerArgs<ExtArgs>
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentArgs> = $Types.GetResult<DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    customer<T extends CustomerArgs<ExtArgs> = {}>(args?: Subset<T, CustomerArgs<ExtArgs>>): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Document base type for findUnique actions
   */
  export type DocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUnique
   */
  export interface DocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document base type for findFirst actions
   */
  export type DocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }

  /**
   * Document findFirst
   */
  export interface DocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: Enumerable<DocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model NotificationPreference
   */


  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    pushNotifications: boolean | null
    marketingEmails: boolean | null
    appointmentReminders: boolean | null
    checkinNotifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    pushNotifications: boolean | null
    marketingEmails: boolean | null
    appointmentReminders: boolean | null
    checkinNotifications: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    customerId: number
    emailNotifications: number
    smsNotifications: number
    pushNotifications: number
    marketingEmails: number
    appointmentReminders: number
    checkinNotifications: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    customerId?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    marketingEmails?: true
    appointmentReminders?: true
    checkinNotifications?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    customerId?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    marketingEmails?: true
    appointmentReminders?: true
    checkinNotifications?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    customerId?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    marketingEmails?: true
    appointmentReminders?: true
    checkinNotifications?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: Enumerable<NotificationPreferenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: Enumerable<NotificationPreferenceOrderByWithAggregationInput>
    by: NotificationPreferenceScalarFieldEnum[]
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }


  export type NotificationPreferenceGroupByOutputType = {
    id: string
    customerId: string
    emailNotifications: boolean
    smsNotifications: boolean
    pushNotifications: boolean
    marketingEmails: boolean
    appointmentReminders: boolean
    checkinNotifications: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    marketingEmails?: boolean
    appointmentReminders?: boolean
    checkinNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    customerId?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    marketingEmails?: boolean
    appointmentReminders?: boolean
    checkinNotifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerArgs<ExtArgs>
  }


  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceArgs> = $Types.GetResult<NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationPreferenceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NotificationPreference'> extends True ? Prisma__NotificationPreferenceClient<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__NotificationPreferenceClient<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one NotificationPreference that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationPreferenceClient<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationPreferenceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NotificationPreference'> extends True ? Prisma__NotificationPreferenceClient<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__NotificationPreferenceClient<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationPreferenceClient<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationPreferenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
    **/
    create<T extends NotificationPreferenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>
    ): Prisma__NotificationPreferenceClient<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many NotificationPreferences.
     *     @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     *     @example
     *     // Create many NotificationPreferences
     *     const notificationPreference = await prisma.notificationPreference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationPreferenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
    **/
    delete<T extends NotificationPreferenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>
    ): Prisma__NotificationPreferenceClient<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationPreferenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>
    ): Prisma__NotificationPreferenceClient<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationPreferenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationPreferenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationPreferenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>
    ): Prisma__NotificationPreferenceClient<$Types.GetResult<NotificationPreferencePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    customer<T extends CustomerArgs<ExtArgs> = {}>(args?: Subset<T, CustomerArgs<ExtArgs>>): Prisma__CustomerClient<$Types.GetResult<CustomerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * NotificationPreference base type for findUnique actions
   */
  export type NotificationPreferenceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUnique
   */
  export interface NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NotificationPreferenceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }


  /**
   * NotificationPreference base type for findFirst actions
   */
  export type NotificationPreferenceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: Enumerable<NotificationPreferenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: Enumerable<NotificationPreferenceScalarFieldEnum>
  }

  /**
   * NotificationPreference findFirst
   */
  export interface NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NotificationPreferenceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: Enumerable<NotificationPreferenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: Enumerable<NotificationPreferenceScalarFieldEnum>
  }


  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: Enumerable<NotificationPreferenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: Enumerable<NotificationPreferenceScalarFieldEnum>
  }


  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }


  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: Enumerable<NotificationPreferenceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }


  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
  }


  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }


  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }


  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
  }


  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }



  /**
   * Model CheckIn
   */


  export type AggregateCheckIn = {
    _count: CheckInCountAggregateOutputType | null
    _min: CheckInMinAggregateOutputType | null
    _max: CheckInMaxAggregateOutputType | null
  }

  export type CheckInMinAggregateOutputType = {
    id: string | null
    petId: string | null
    reservationId: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    checkInNotes: string | null
    checkOutNotes: string | null
    checkInBy: string | null
    checkOutBy: string | null
    foodProvided: boolean | null
    medicationGiven: boolean | null
    medicationNotes: string | null
    behaviorDuringStay: string | null
    photosTaken: boolean | null
    photosShared: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CheckInMaxAggregateOutputType = {
    id: string | null
    petId: string | null
    reservationId: string | null
    checkInTime: Date | null
    checkOutTime: Date | null
    checkInNotes: string | null
    checkOutNotes: string | null
    checkInBy: string | null
    checkOutBy: string | null
    foodProvided: boolean | null
    medicationGiven: boolean | null
    medicationNotes: string | null
    behaviorDuringStay: string | null
    photosTaken: boolean | null
    photosShared: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CheckInCountAggregateOutputType = {
    id: number
    petId: number
    reservationId: number
    checkInTime: number
    checkOutTime: number
    checkInNotes: number
    checkOutNotes: number
    checkInBy: number
    checkOutBy: number
    belongingsChecklist: number
    foodProvided: number
    medicationGiven: number
    medicationNotes: number
    behaviorDuringStay: number
    photosTaken: number
    photosShared: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CheckInMinAggregateInputType = {
    id?: true
    petId?: true
    reservationId?: true
    checkInTime?: true
    checkOutTime?: true
    checkInNotes?: true
    checkOutNotes?: true
    checkInBy?: true
    checkOutBy?: true
    foodProvided?: true
    medicationGiven?: true
    medicationNotes?: true
    behaviorDuringStay?: true
    photosTaken?: true
    photosShared?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CheckInMaxAggregateInputType = {
    id?: true
    petId?: true
    reservationId?: true
    checkInTime?: true
    checkOutTime?: true
    checkInNotes?: true
    checkOutNotes?: true
    checkInBy?: true
    checkOutBy?: true
    foodProvided?: true
    medicationGiven?: true
    medicationNotes?: true
    behaviorDuringStay?: true
    photosTaken?: true
    photosShared?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CheckInCountAggregateInputType = {
    id?: true
    petId?: true
    reservationId?: true
    checkInTime?: true
    checkOutTime?: true
    checkInNotes?: true
    checkOutNotes?: true
    checkInBy?: true
    checkOutBy?: true
    belongingsChecklist?: true
    foodProvided?: true
    medicationGiven?: true
    medicationNotes?: true
    behaviorDuringStay?: true
    photosTaken?: true
    photosShared?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CheckInAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckIn to aggregate.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: Enumerable<CheckInOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckIns
    **/
    _count?: true | CheckInCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckInMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckInMaxAggregateInputType
  }

  export type GetCheckInAggregateType<T extends CheckInAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckIn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckIn[P]>
      : GetScalarType<T[P], AggregateCheckIn[P]>
  }




  export type CheckInGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CheckInWhereInput
    orderBy?: Enumerable<CheckInOrderByWithAggregationInput>
    by: CheckInScalarFieldEnum[]
    having?: CheckInScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckInCountAggregateInputType | true
    _min?: CheckInMinAggregateInputType
    _max?: CheckInMaxAggregateInputType
  }


  export type CheckInGroupByOutputType = {
    id: string
    petId: string
    reservationId: string | null
    checkInTime: Date
    checkOutTime: Date | null
    checkInNotes: string | null
    checkOutNotes: string | null
    checkInBy: string | null
    checkOutBy: string | null
    belongingsChecklist: JsonValue | null
    foodProvided: boolean
    medicationGiven: boolean
    medicationNotes: string | null
    behaviorDuringStay: string | null
    photosTaken: boolean
    photosShared: boolean
    createdAt: Date
    updatedAt: Date
    _count: CheckInCountAggregateOutputType | null
    _min: CheckInMinAggregateOutputType | null
    _max: CheckInMaxAggregateOutputType | null
  }

  type GetCheckInGroupByPayload<T extends CheckInGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CheckInGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckInGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckInGroupByOutputType[P]>
            : GetScalarType<T[P], CheckInGroupByOutputType[P]>
        }
      >
    >


  export type CheckInSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    reservationId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    checkInNotes?: boolean
    checkOutNotes?: boolean
    checkInBy?: boolean
    checkOutBy?: boolean
    belongingsChecklist?: boolean
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: boolean
    behaviorDuringStay?: boolean
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pet?: boolean | PetArgs<ExtArgs>
    reservation?: boolean | ReservationArgs<ExtArgs>
    activities?: boolean | CheckIn$activitiesArgs<ExtArgs>
    _count?: boolean | CheckInCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["checkIn"]>

  export type CheckInSelectScalar = {
    id?: boolean
    petId?: boolean
    reservationId?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    checkInNotes?: boolean
    checkOutNotes?: boolean
    checkInBy?: boolean
    checkOutBy?: boolean
    belongingsChecklist?: boolean
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: boolean
    behaviorDuringStay?: boolean
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CheckInInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pet?: boolean | PetArgs<ExtArgs>
    reservation?: boolean | ReservationArgs<ExtArgs>
    activities?: boolean | CheckIn$activitiesArgs<ExtArgs>
    _count?: boolean | CheckInCountOutputTypeArgs<ExtArgs>
  }


  type CheckInGetPayload<S extends boolean | null | undefined | CheckInArgs> = $Types.GetResult<CheckInPayload, S>

  type CheckInCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CheckInFindManyArgs, 'select' | 'include'> & {
      select?: CheckInCountAggregateInputType | true
    }

  export interface CheckInDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckIn'], meta: { name: 'CheckIn' } }
    /**
     * Find zero or one CheckIn that matches the filter.
     * @param {CheckInFindUniqueArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CheckInFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CheckInFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CheckIn'> extends True ? Prisma__CheckInClient<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CheckInClient<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one CheckIn that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CheckInFindUniqueOrThrowArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CheckInFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckInFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CheckInClient<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first CheckIn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindFirstArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CheckInFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CheckInFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CheckIn'> extends True ? Prisma__CheckInClient<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CheckInClient<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first CheckIn that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindFirstOrThrowArgs} args - Arguments to find a CheckIn
     * @example
     * // Get one CheckIn
     * const checkIn = await prisma.checkIn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CheckInFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckInFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CheckInClient<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more CheckIns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckIns
     * const checkIns = await prisma.checkIn.findMany()
     * 
     * // Get first 10 CheckIns
     * const checkIns = await prisma.checkIn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkInWithIdOnly = await prisma.checkIn.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CheckInFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckInFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a CheckIn.
     * @param {CheckInCreateArgs} args - Arguments to create a CheckIn.
     * @example
     * // Create one CheckIn
     * const CheckIn = await prisma.checkIn.create({
     *   data: {
     *     // ... data to create a CheckIn
     *   }
     * })
     * 
    **/
    create<T extends CheckInCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CheckInCreateArgs<ExtArgs>>
    ): Prisma__CheckInClient<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many CheckIns.
     *     @param {CheckInCreateManyArgs} args - Arguments to create many CheckIns.
     *     @example
     *     // Create many CheckIns
     *     const checkIn = await prisma.checkIn.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CheckInCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckInCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CheckIn.
     * @param {CheckInDeleteArgs} args - Arguments to delete one CheckIn.
     * @example
     * // Delete one CheckIn
     * const CheckIn = await prisma.checkIn.delete({
     *   where: {
     *     // ... filter to delete one CheckIn
     *   }
     * })
     * 
    **/
    delete<T extends CheckInDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CheckInDeleteArgs<ExtArgs>>
    ): Prisma__CheckInClient<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one CheckIn.
     * @param {CheckInUpdateArgs} args - Arguments to update one CheckIn.
     * @example
     * // Update one CheckIn
     * const checkIn = await prisma.checkIn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CheckInUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CheckInUpdateArgs<ExtArgs>>
    ): Prisma__CheckInClient<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more CheckIns.
     * @param {CheckInDeleteManyArgs} args - Arguments to filter CheckIns to delete.
     * @example
     * // Delete a few CheckIns
     * const { count } = await prisma.checkIn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CheckInDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckInDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckIns
     * const checkIn = await prisma.checkIn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CheckInUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CheckInUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CheckIn.
     * @param {CheckInUpsertArgs} args - Arguments to update or create a CheckIn.
     * @example
     * // Update or create a CheckIn
     * const checkIn = await prisma.checkIn.upsert({
     *   create: {
     *     // ... data to create a CheckIn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckIn we want to update
     *   }
     * })
    **/
    upsert<T extends CheckInUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CheckInUpsertArgs<ExtArgs>>
    ): Prisma__CheckInClient<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of CheckIns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInCountArgs} args - Arguments to filter CheckIns to count.
     * @example
     * // Count the number of CheckIns
     * const count = await prisma.checkIn.count({
     *   where: {
     *     // ... the filter for the CheckIns we want to count
     *   }
     * })
    **/
    count<T extends CheckInCountArgs>(
      args?: Subset<T, CheckInCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckInCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckInAggregateArgs>(args: Subset<T, CheckInAggregateArgs>): Prisma.PrismaPromise<GetCheckInAggregateType<T>>

    /**
     * Group by CheckIn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckInGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckInGroupByArgs['orderBy'] }
        : { orderBy?: CheckInGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckInGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckInGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckIn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CheckInClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    pet<T extends PetArgs<ExtArgs> = {}>(args?: Subset<T, PetArgs<ExtArgs>>): Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    reservation<T extends ReservationArgs<ExtArgs> = {}>(args?: Subset<T, ReservationArgs<ExtArgs>>): Prisma__ReservationClient<$Types.GetResult<ReservationPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    activities<T extends CheckIn$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, CheckIn$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CheckIn base type for findUnique actions
   */
  export type CheckInFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where: CheckInWhereUniqueInput
  }

  /**
   * CheckIn findUnique
   */
  export interface CheckInFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CheckInFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CheckIn findUniqueOrThrow
   */
  export type CheckInFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where: CheckInWhereUniqueInput
  }


  /**
   * CheckIn base type for findFirst actions
   */
  export type CheckInFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: Enumerable<CheckInOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckIns.
     */
    distinct?: Enumerable<CheckInScalarFieldEnum>
  }

  /**
   * CheckIn findFirst
   */
  export interface CheckInFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CheckInFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CheckIn findFirstOrThrow
   */
  export type CheckInFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIn to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: Enumerable<CheckInOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckIns.
     */
    distinct?: Enumerable<CheckInScalarFieldEnum>
  }


  /**
   * CheckIn findMany
   */
  export type CheckInFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter, which CheckIns to fetch.
     */
    where?: CheckInWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckIns to fetch.
     */
    orderBy?: Enumerable<CheckInOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckIns.
     */
    cursor?: CheckInWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckIns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckIns.
     */
    skip?: number
    distinct?: Enumerable<CheckInScalarFieldEnum>
  }


  /**
   * CheckIn create
   */
  export type CheckInCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckIn.
     */
    data: XOR<CheckInCreateInput, CheckInUncheckedCreateInput>
  }


  /**
   * CheckIn createMany
   */
  export type CheckInCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckIns.
     */
    data: Enumerable<CheckInCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CheckIn update
   */
  export type CheckInUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckIn.
     */
    data: XOR<CheckInUpdateInput, CheckInUncheckedUpdateInput>
    /**
     * Choose, which CheckIn to update.
     */
    where: CheckInWhereUniqueInput
  }


  /**
   * CheckIn updateMany
   */
  export type CheckInUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckIns.
     */
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyInput>
    /**
     * Filter which CheckIns to update
     */
    where?: CheckInWhereInput
  }


  /**
   * CheckIn upsert
   */
  export type CheckInUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckIn to update in case it exists.
     */
    where: CheckInWhereUniqueInput
    /**
     * In case the CheckIn found by the `where` argument doesn't exist, create a new CheckIn with this data.
     */
    create: XOR<CheckInCreateInput, CheckInUncheckedCreateInput>
    /**
     * In case the CheckIn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckInUpdateInput, CheckInUncheckedUpdateInput>
  }


  /**
   * CheckIn delete
   */
  export type CheckInDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
    /**
     * Filter which CheckIn to delete.
     */
    where: CheckInWhereUniqueInput
  }


  /**
   * CheckIn deleteMany
   */
  export type CheckInDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckIns to delete
     */
    where?: CheckInWhereInput
  }


  /**
   * CheckIn.activities
   */
  export type CheckIn$activitiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ActivityScalarFieldEnum>
  }


  /**
   * CheckIn without action
   */
  export type CheckInArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckIn
     */
    select?: CheckInSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckInInclude<ExtArgs> | null
  }



  /**
   * Model Activity
   */


  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    checkInId: string | null
    activityType: string | null
    notes: string | null
    timestamp: Date | null
    recordedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    checkInId: string | null
    activityType: string | null
    notes: string | null
    timestamp: Date | null
    recordedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    checkInId: number
    activityType: number
    notes: number
    timestamp: number
    recordedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    checkInId?: true
    activityType?: true
    notes?: true
    timestamp?: true
    recordedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    checkInId?: true
    activityType?: true
    notes?: true
    timestamp?: true
    recordedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    checkInId?: true
    activityType?: true
    notes?: true
    timestamp?: true
    recordedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: Enumerable<ActivityOrderByWithAggregationInput>
    by: ActivityScalarFieldEnum[]
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }


  export type ActivityGroupByOutputType = {
    id: string
    checkInId: string
    activityType: string
    notes: string | null
    timestamp: Date
    recordedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checkInId?: boolean
    activityType?: boolean
    notes?: boolean
    timestamp?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    checkIn?: boolean | CheckInArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    checkInId?: boolean
    activityType?: boolean
    notes?: boolean
    timestamp?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActivityInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    checkIn?: boolean | CheckInArgs<ExtArgs>
  }


  type ActivityGetPayload<S extends boolean | null | undefined | ActivityArgs> = $Types.GetResult<ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ActivityFindManyArgs, 'select' | 'include'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ActivityFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Activity'> extends True ? Prisma__ActivityClient<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ActivityClient<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Activity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ActivityFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Activity'> extends True ? Prisma__ActivityClient<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ActivityClient<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Activity that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ActivityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
    **/
    create<T extends ActivityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Activities.
     *     @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     *     @example
     *     // Create many Activities
     *     const activity = await prisma.activity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ActivityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
    **/
    delete<T extends ActivityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ActivityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ActivityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ActivityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
    **/
    upsert<T extends ActivityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>
    ): Prisma__ActivityClient<$Types.GetResult<ActivityPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    checkIn<T extends CheckInArgs<ExtArgs> = {}>(args?: Subset<T, CheckInArgs<ExtArgs>>): Prisma__CheckInClient<$Types.GetResult<CheckInPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Activity base type for findUnique actions
   */
  export type ActivityFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUnique
   */
  export interface ActivityFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ActivityFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity base type for findFirst actions
   */
  export type ActivityFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: Enumerable<ActivityScalarFieldEnum>
  }

  /**
   * Activity findFirst
   */
  export interface ActivityFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ActivityFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: Enumerable<ActivityScalarFieldEnum>
  }


  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: Enumerable<ActivityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: Enumerable<ActivityScalarFieldEnum>
  }


  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }


  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: Enumerable<ActivityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
  }


  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }


  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }


  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
  }


  /**
   * Activity without action
   */
  export type ActivityArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ActivityInclude<ExtArgs> | null
  }



  /**
   * Model MedicalRecord
   */


  export type AggregateMedicalRecord = {
    _count: MedicalRecordCountAggregateOutputType | null
    _min: MedicalRecordMinAggregateOutputType | null
    _max: MedicalRecordMaxAggregateOutputType | null
  }

  export type MedicalRecordMinAggregateOutputType = {
    id: string | null
    petId: string | null
    recordType: string | null
    recordDate: Date | null
    expirationDate: Date | null
    description: string | null
    veterinarian: string | null
    fileUrl: string | null
    verified: boolean | null
    verifiedBy: string | null
    verifiedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalRecordMaxAggregateOutputType = {
    id: string | null
    petId: string | null
    recordType: string | null
    recordDate: Date | null
    expirationDate: Date | null
    description: string | null
    veterinarian: string | null
    fileUrl: string | null
    verified: boolean | null
    verifiedBy: string | null
    verifiedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalRecordCountAggregateOutputType = {
    id: number
    petId: number
    recordType: number
    recordDate: number
    expirationDate: number
    description: number
    veterinarian: number
    fileUrl: number
    verified: number
    verifiedBy: number
    verifiedDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalRecordMinAggregateInputType = {
    id?: true
    petId?: true
    recordType?: true
    recordDate?: true
    expirationDate?: true
    description?: true
    veterinarian?: true
    fileUrl?: true
    verified?: true
    verifiedBy?: true
    verifiedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalRecordMaxAggregateInputType = {
    id?: true
    petId?: true
    recordType?: true
    recordDate?: true
    expirationDate?: true
    description?: true
    veterinarian?: true
    fileUrl?: true
    verified?: true
    verifiedBy?: true
    verifiedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalRecordCountAggregateInputType = {
    id?: true
    petId?: true
    recordType?: true
    recordDate?: true
    expirationDate?: true
    description?: true
    veterinarian?: true
    fileUrl?: true
    verified?: true
    verifiedBy?: true
    verifiedDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalRecordAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecord to aggregate.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: Enumerable<MedicalRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalRecords
    **/
    _count?: true | MedicalRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalRecordMaxAggregateInputType
  }

  export type GetMedicalRecordAggregateType<T extends MedicalRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalRecord[P]>
      : GetScalarType<T[P], AggregateMedicalRecord[P]>
  }




  export type MedicalRecordGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
    orderBy?: Enumerable<MedicalRecordOrderByWithAggregationInput>
    by: MedicalRecordScalarFieldEnum[]
    having?: MedicalRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalRecordCountAggregateInputType | true
    _min?: MedicalRecordMinAggregateInputType
    _max?: MedicalRecordMaxAggregateInputType
  }


  export type MedicalRecordGroupByOutputType = {
    id: string
    petId: string
    recordType: string
    recordDate: Date
    expirationDate: Date | null
    description: string
    veterinarian: string | null
    fileUrl: string | null
    verified: boolean
    verifiedBy: string | null
    verifiedDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MedicalRecordCountAggregateOutputType | null
    _min: MedicalRecordMinAggregateOutputType | null
    _max: MedicalRecordMaxAggregateOutputType | null
  }

  type GetMedicalRecordGroupByPayload<T extends MedicalRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MedicalRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalRecordGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalRecordGroupByOutputType[P]>
        }
      >
    >


  export type MedicalRecordSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    recordType?: boolean
    recordDate?: boolean
    expirationDate?: boolean
    description?: boolean
    veterinarian?: boolean
    fileUrl?: boolean
    verified?: boolean
    verifiedBy?: boolean
    verifiedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pet?: boolean | PetArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectScalar = {
    id?: boolean
    petId?: boolean
    recordType?: boolean
    recordDate?: boolean
    expirationDate?: boolean
    description?: boolean
    veterinarian?: boolean
    fileUrl?: boolean
    verified?: boolean
    verifiedBy?: boolean
    verifiedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicalRecordInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pet?: boolean | PetArgs<ExtArgs>
  }


  type MedicalRecordGetPayload<S extends boolean | null | undefined | MedicalRecordArgs> = $Types.GetResult<MedicalRecordPayload, S>

  type MedicalRecordCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MedicalRecordFindManyArgs, 'select' | 'include'> & {
      select?: MedicalRecordCountAggregateInputType | true
    }

  export interface MedicalRecordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalRecord'], meta: { name: 'MedicalRecord' } }
    /**
     * Find zero or one MedicalRecord that matches the filter.
     * @param {MedicalRecordFindUniqueArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MedicalRecordFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MedicalRecordFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MedicalRecord'> extends True ? Prisma__MedicalRecordClient<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__MedicalRecordClient<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one MedicalRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MedicalRecordFindUniqueOrThrowArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MedicalRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MedicalRecordClient<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first MedicalRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindFirstArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MedicalRecordFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MedicalRecordFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MedicalRecord'> extends True ? Prisma__MedicalRecordClient<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__MedicalRecordClient<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first MedicalRecord that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindFirstOrThrowArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MedicalRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MedicalRecordClient<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more MedicalRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalRecords
     * const medicalRecords = await prisma.medicalRecord.findMany()
     * 
     * // Get first 10 MedicalRecords
     * const medicalRecords = await prisma.medicalRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MedicalRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a MedicalRecord.
     * @param {MedicalRecordCreateArgs} args - Arguments to create a MedicalRecord.
     * @example
     * // Create one MedicalRecord
     * const MedicalRecord = await prisma.medicalRecord.create({
     *   data: {
     *     // ... data to create a MedicalRecord
     *   }
     * })
     * 
    **/
    create<T extends MedicalRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalRecordCreateArgs<ExtArgs>>
    ): Prisma__MedicalRecordClient<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many MedicalRecords.
     *     @param {MedicalRecordCreateManyArgs} args - Arguments to create many MedicalRecords.
     *     @example
     *     // Create many MedicalRecords
     *     const medicalRecord = await prisma.medicalRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MedicalRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MedicalRecord.
     * @param {MedicalRecordDeleteArgs} args - Arguments to delete one MedicalRecord.
     * @example
     * // Delete one MedicalRecord
     * const MedicalRecord = await prisma.medicalRecord.delete({
     *   where: {
     *     // ... filter to delete one MedicalRecord
     *   }
     * })
     * 
    **/
    delete<T extends MedicalRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalRecordDeleteArgs<ExtArgs>>
    ): Prisma__MedicalRecordClient<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one MedicalRecord.
     * @param {MedicalRecordUpdateArgs} args - Arguments to update one MedicalRecord.
     * @example
     * // Update one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MedicalRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalRecordUpdateArgs<ExtArgs>>
    ): Prisma__MedicalRecordClient<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more MedicalRecords.
     * @param {MedicalRecordDeleteManyArgs} args - Arguments to filter MedicalRecords to delete.
     * @example
     * // Delete a few MedicalRecords
     * const { count } = await prisma.medicalRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MedicalRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MedicalRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MedicalRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalRecord.
     * @param {MedicalRecordUpsertArgs} args - Arguments to update or create a MedicalRecord.
     * @example
     * // Update or create a MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.upsert({
     *   create: {
     *     // ... data to create a MedicalRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalRecord we want to update
     *   }
     * })
    **/
    upsert<T extends MedicalRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MedicalRecordUpsertArgs<ExtArgs>>
    ): Prisma__MedicalRecordClient<$Types.GetResult<MedicalRecordPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordCountArgs} args - Arguments to filter MedicalRecords to count.
     * @example
     * // Count the number of MedicalRecords
     * const count = await prisma.medicalRecord.count({
     *   where: {
     *     // ... the filter for the MedicalRecords we want to count
     *   }
     * })
    **/
    count<T extends MedicalRecordCountArgs>(
      args?: Subset<T, MedicalRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalRecordAggregateArgs>(args: Subset<T, MedicalRecordAggregateArgs>): Prisma.PrismaPromise<GetMedicalRecordAggregateType<T>>

    /**
     * Group by MedicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalRecordGroupByArgs['orderBy'] }
        : { orderBy?: MedicalRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MedicalRecordClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    pet<T extends PetArgs<ExtArgs> = {}>(args?: Subset<T, PetArgs<ExtArgs>>): Prisma__PetClient<$Types.GetResult<PetPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MedicalRecord base type for findUnique actions
   */
  export type MedicalRecordFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord findUnique
   */
  export interface MedicalRecordFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MedicalRecordFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MedicalRecord findUniqueOrThrow
   */
  export type MedicalRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where: MedicalRecordWhereUniqueInput
  }


  /**
   * MedicalRecord base type for findFirst actions
   */
  export type MedicalRecordFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: Enumerable<MedicalRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: Enumerable<MedicalRecordScalarFieldEnum>
  }

  /**
   * MedicalRecord findFirst
   */
  export interface MedicalRecordFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MedicalRecordFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MedicalRecord findFirstOrThrow
   */
  export type MedicalRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: Enumerable<MedicalRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: Enumerable<MedicalRecordScalarFieldEnum>
  }


  /**
   * MedicalRecord findMany
   */
  export type MedicalRecordFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecords to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: Enumerable<MedicalRecordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    distinct?: Enumerable<MedicalRecordScalarFieldEnum>
  }


  /**
   * MedicalRecord create
   */
  export type MedicalRecordCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalRecord.
     */
    data: XOR<MedicalRecordCreateInput, MedicalRecordUncheckedCreateInput>
  }


  /**
   * MedicalRecord createMany
   */
  export type MedicalRecordCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalRecords.
     */
    data: Enumerable<MedicalRecordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MedicalRecord update
   */
  export type MedicalRecordUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalRecord.
     */
    data: XOR<MedicalRecordUpdateInput, MedicalRecordUncheckedUpdateInput>
    /**
     * Choose, which MedicalRecord to update.
     */
    where: MedicalRecordWhereUniqueInput
  }


  /**
   * MedicalRecord updateMany
   */
  export type MedicalRecordUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalRecords.
     */
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyInput>
    /**
     * Filter which MedicalRecords to update
     */
    where?: MedicalRecordWhereInput
  }


  /**
   * MedicalRecord upsert
   */
  export type MedicalRecordUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalRecord to update in case it exists.
     */
    where: MedicalRecordWhereUniqueInput
    /**
     * In case the MedicalRecord found by the `where` argument doesn't exist, create a new MedicalRecord with this data.
     */
    create: XOR<MedicalRecordCreateInput, MedicalRecordUncheckedCreateInput>
    /**
     * In case the MedicalRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalRecordUpdateInput, MedicalRecordUncheckedUpdateInput>
  }


  /**
   * MedicalRecord delete
   */
  export type MedicalRecordDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter which MedicalRecord to delete.
     */
    where: MedicalRecordWhereUniqueInput
  }


  /**
   * MedicalRecord deleteMany
   */
  export type MedicalRecordDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecords to delete
     */
    where?: MedicalRecordWhereInput
  }


  /**
   * MedicalRecord without action
   */
  export type MedicalRecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MedicalRecordInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    alternatePhone: 'alternatePhone',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    notes: 'notes',
    portalEnabled: 'portalEnabled',
    preferredContact: 'preferredContact',
    emergencyContact: 'emergencyContact',
    emergencyPhone: 'emergencyPhone',
    vatTaxId: 'vatTaxId',
    referralSource: 'referralSource',
    tags: 'tags',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const PetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    breed: 'breed',
    color: 'color',
    birthdate: 'birthdate',
    weight: 'weight',
    gender: 'gender',
    isNeutered: 'isNeutered',
    microchipNumber: 'microchipNumber',
    rabiesTagNumber: 'rabiesTagNumber',
    specialNeeds: 'specialNeeds',
    foodNotes: 'foodNotes',
    medicationNotes: 'medicationNotes',
    behaviorNotes: 'behaviorNotes',
    allergies: 'allergies',
    idealPlayGroup: 'idealPlayGroup',
    vaccinationStatus: 'vaccinationStatus',
    vaccineExpirations: 'vaccineExpirations',
    vetName: 'vetName',
    vetPhone: 'vetPhone',
    profilePhoto: 'profilePhoto',
    isActive: 'isActive',
    lastCheckIn: 'lastCheckIn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    customerId: 'customerId'
  };

  export type PetScalarFieldEnum = (typeof PetScalarFieldEnum)[keyof typeof PetScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    notes: 'notes',
    staffNotes: 'staffNotes',
    checkInWindow: 'checkInWindow',
    isRecurring: 'isRecurring',
    recurringPattern: 'recurringPattern',
    preChecked: 'preChecked',
    checkInDate: 'checkInDate',
    checkOutDate: 'checkOutDate',
    earlyDropOff: 'earlyDropOff',
    latePickup: 'latePickup',
    customPickupPerson: 'customPickupPerson',
    confirmedBy: 'confirmedBy',
    cancelReason: 'cancelReason',
    cancelDate: 'cancelDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    customerId: 'customerId',
    petId: 'petId',
    serviceId: 'serviceId',
    resourceId: 'resourceId',
    staffAssignedId: 'staffAssignedId'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    duration: 'duration',
    price: 'price',
    color: 'color',
    serviceCategory: 'serviceCategory',
    isActive: 'isActive',
    capacityLimit: 'capacityLimit',
    requiresStaff: 'requiresStaff',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const AddOnServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    duration: 'duration',
    serviceId: 'serviceId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddOnServiceScalarFieldEnum = (typeof AddOnServiceScalarFieldEnum)[keyof typeof AddOnServiceScalarFieldEnum]


  export const ReservationAddOnScalarFieldEnum: {
    id: 'id',
    reservationId: 'reservationId',
    addOnId: 'addOnId',
    price: 'price',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReservationAddOnScalarFieldEnum = (typeof ReservationAddOnScalarFieldEnum)[keyof typeof ReservationAddOnScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    capacity: 'capacity',
    isActive: 'isActive',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    role: 'role',
    workSchedule: 'workSchedule',
    specialties: 'specialties',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    customerId: 'customerId',
    reservationId: 'reservationId',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    status: 'status',
    subtotal: 'subtotal',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    discount: 'discount',
    total: 'total',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceLineItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    amount: 'amount',
    taxable: 'taxable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceLineItemScalarFieldEnum = (typeof InvoiceLineItemScalarFieldEnum)[keyof typeof InvoiceLineItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    customerId: 'customerId',
    amount: 'amount',
    method: 'method',
    status: 'status',
    transactionId: 'transactionId',
    paymentDate: 'paymentDate',
    gatewayResponse: 'gatewayResponse',
    refundedAmount: 'refundedAmount',
    refundReason: 'refundReason',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    title: 'title',
    description: 'description',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    fileSize: 'fileSize',
    tags: 'tags',
    uploaded: 'uploaded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    emailNotifications: 'emailNotifications',
    smsNotifications: 'smsNotifications',
    pushNotifications: 'pushNotifications',
    marketingEmails: 'marketingEmails',
    appointmentReminders: 'appointmentReminders',
    checkinNotifications: 'checkinNotifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const CheckInScalarFieldEnum: {
    id: 'id',
    petId: 'petId',
    reservationId: 'reservationId',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    checkInNotes: 'checkInNotes',
    checkOutNotes: 'checkOutNotes',
    checkInBy: 'checkInBy',
    checkOutBy: 'checkOutBy',
    belongingsChecklist: 'belongingsChecklist',
    foodProvided: 'foodProvided',
    medicationGiven: 'medicationGiven',
    medicationNotes: 'medicationNotes',
    behaviorDuringStay: 'behaviorDuringStay',
    photosTaken: 'photosTaken',
    photosShared: 'photosShared',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CheckInScalarFieldEnum = (typeof CheckInScalarFieldEnum)[keyof typeof CheckInScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    checkInId: 'checkInId',
    activityType: 'activityType',
    notes: 'notes',
    timestamp: 'timestamp',
    recordedBy: 'recordedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const MedicalRecordScalarFieldEnum: {
    id: 'id',
    petId: 'petId',
    recordType: 'recordType',
    recordDate: 'recordDate',
    expirationDate: 'expirationDate',
    description: 'description',
    veterinarian: 'veterinarian',
    fileUrl: 'fileUrl',
    verified: 'verified',
    verifiedBy: 'verifiedBy',
    verifiedDate: 'verifiedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalRecordScalarFieldEnum = (typeof MedicalRecordScalarFieldEnum)[keyof typeof MedicalRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: Enumerable<CustomerWhereInput>
    OR?: Enumerable<CustomerWhereInput>
    NOT?: Enumerable<CustomerWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    phone?: StringNullableFilter | string | null
    alternatePhone?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    zipCode?: StringNullableFilter | string | null
    notes?: StringNullableFilter | string | null
    portalEnabled?: BoolFilter | boolean
    preferredContact?: EnumContactMethodFilter | ContactMethod
    emergencyContact?: StringNullableFilter | string | null
    emergencyPhone?: StringNullableFilter | string | null
    vatTaxId?: StringNullableFilter | string | null
    referralSource?: StringNullableFilter | string | null
    tags?: StringNullableListFilter
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    pets?: PetListRelationFilter
    reservations?: ReservationListRelationFilter
    payments?: PaymentListRelationFilter
    invoices?: InvoiceListRelationFilter
    documents?: DocumentListRelationFilter
    notifications?: XOR<NotificationPreferenceRelationFilter, NotificationPreferenceWhereInput> | null
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    alternatePhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    portalEnabled?: SortOrder
    preferredContact?: SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    vatTaxId?: SortOrderInput | SortOrder
    referralSource?: SortOrderInput | SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pets?: PetOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    notifications?: NotificationPreferenceOrderByWithRelationInput
  }

  export type CustomerWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    alternatePhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    portalEnabled?: SortOrder
    preferredContact?: SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    vatTaxId?: SortOrderInput | SortOrder
    referralSource?: SortOrderInput | SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    phone?: StringNullableWithAggregatesFilter | string | null
    alternatePhone?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    state?: StringNullableWithAggregatesFilter | string | null
    zipCode?: StringNullableWithAggregatesFilter | string | null
    notes?: StringNullableWithAggregatesFilter | string | null
    portalEnabled?: BoolWithAggregatesFilter | boolean
    preferredContact?: EnumContactMethodWithAggregatesFilter | ContactMethod
    emergencyContact?: StringNullableWithAggregatesFilter | string | null
    emergencyPhone?: StringNullableWithAggregatesFilter | string | null
    vatTaxId?: StringNullableWithAggregatesFilter | string | null
    referralSource?: StringNullableWithAggregatesFilter | string | null
    tags?: StringNullableListFilter
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PetWhereInput = {
    AND?: Enumerable<PetWhereInput>
    OR?: Enumerable<PetWhereInput>
    NOT?: Enumerable<PetWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: EnumPetTypeFilter | PetType
    breed?: StringNullableFilter | string | null
    color?: StringNullableFilter | string | null
    birthdate?: DateTimeNullableFilter | Date | string | null
    weight?: FloatNullableFilter | number | null
    gender?: EnumGenderNullableFilter | Gender | null
    isNeutered?: BoolFilter | boolean
    microchipNumber?: StringNullableFilter | string | null
    rabiesTagNumber?: StringNullableFilter | string | null
    specialNeeds?: StringNullableFilter | string | null
    foodNotes?: StringNullableFilter | string | null
    medicationNotes?: StringNullableFilter | string | null
    behaviorNotes?: StringNullableFilter | string | null
    allergies?: StringNullableFilter | string | null
    idealPlayGroup?: EnumPlayGroupTypeNullableFilter | PlayGroupType | null
    vaccinationStatus?: JsonNullableFilter
    vaccineExpirations?: JsonNullableFilter
    vetName?: StringNullableFilter | string | null
    vetPhone?: StringNullableFilter | string | null
    profilePhoto?: StringNullableFilter | string | null
    isActive?: BoolFilter | boolean
    lastCheckIn?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    customerId?: StringFilter | string
    owner?: XOR<CustomerRelationFilter, CustomerWhereInput>
    reservations?: ReservationListRelationFilter
    checkIns?: CheckInListRelationFilter
    medicalRecords?: MedicalRecordListRelationFilter
  }

  export type PetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    breed?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    birthdate?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    isNeutered?: SortOrder
    microchipNumber?: SortOrderInput | SortOrder
    rabiesTagNumber?: SortOrderInput | SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    foodNotes?: SortOrderInput | SortOrder
    medicationNotes?: SortOrderInput | SortOrder
    behaviorNotes?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    idealPlayGroup?: SortOrderInput | SortOrder
    vaccinationStatus?: SortOrderInput | SortOrder
    vaccineExpirations?: SortOrderInput | SortOrder
    vetName?: SortOrderInput | SortOrder
    vetPhone?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastCheckIn?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    owner?: CustomerOrderByWithRelationInput
    reservations?: ReservationOrderByRelationAggregateInput
    checkIns?: CheckInOrderByRelationAggregateInput
    medicalRecords?: MedicalRecordOrderByRelationAggregateInput
  }

  export type PetWhereUniqueInput = {
    id?: string
  }

  export type PetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    breed?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    birthdate?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    isNeutered?: SortOrder
    microchipNumber?: SortOrderInput | SortOrder
    rabiesTagNumber?: SortOrderInput | SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    foodNotes?: SortOrderInput | SortOrder
    medicationNotes?: SortOrderInput | SortOrder
    behaviorNotes?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    idealPlayGroup?: SortOrderInput | SortOrder
    vaccinationStatus?: SortOrderInput | SortOrder
    vaccineExpirations?: SortOrderInput | SortOrder
    vetName?: SortOrderInput | SortOrder
    vetPhone?: SortOrderInput | SortOrder
    profilePhoto?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastCheckIn?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    _count?: PetCountOrderByAggregateInput
    _avg?: PetAvgOrderByAggregateInput
    _max?: PetMaxOrderByAggregateInput
    _min?: PetMinOrderByAggregateInput
    _sum?: PetSumOrderByAggregateInput
  }

  export type PetScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PetScalarWhereWithAggregatesInput>
    OR?: Enumerable<PetScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PetScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    type?: EnumPetTypeWithAggregatesFilter | PetType
    breed?: StringNullableWithAggregatesFilter | string | null
    color?: StringNullableWithAggregatesFilter | string | null
    birthdate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    weight?: FloatNullableWithAggregatesFilter | number | null
    gender?: EnumGenderNullableWithAggregatesFilter | Gender | null
    isNeutered?: BoolWithAggregatesFilter | boolean
    microchipNumber?: StringNullableWithAggregatesFilter | string | null
    rabiesTagNumber?: StringNullableWithAggregatesFilter | string | null
    specialNeeds?: StringNullableWithAggregatesFilter | string | null
    foodNotes?: StringNullableWithAggregatesFilter | string | null
    medicationNotes?: StringNullableWithAggregatesFilter | string | null
    behaviorNotes?: StringNullableWithAggregatesFilter | string | null
    allergies?: StringNullableWithAggregatesFilter | string | null
    idealPlayGroup?: EnumPlayGroupTypeNullableWithAggregatesFilter | PlayGroupType | null
    vaccinationStatus?: JsonNullableWithAggregatesFilter
    vaccineExpirations?: JsonNullableWithAggregatesFilter
    vetName?: StringNullableWithAggregatesFilter | string | null
    vetPhone?: StringNullableWithAggregatesFilter | string | null
    profilePhoto?: StringNullableWithAggregatesFilter | string | null
    isActive?: BoolWithAggregatesFilter | boolean
    lastCheckIn?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    customerId?: StringWithAggregatesFilter | string
  }

  export type ReservationWhereInput = {
    AND?: Enumerable<ReservationWhereInput>
    OR?: Enumerable<ReservationWhereInput>
    NOT?: Enumerable<ReservationWhereInput>
    id?: StringFilter | string
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeFilter | Date | string
    status?: EnumReservationStatusFilter | ReservationStatus
    notes?: StringNullableFilter | string | null
    staffNotes?: StringNullableFilter | string | null
    checkInWindow?: IntNullableFilter | number | null
    isRecurring?: BoolFilter | boolean
    recurringPattern?: StringNullableFilter | string | null
    preChecked?: BoolFilter | boolean
    checkInDate?: DateTimeNullableFilter | Date | string | null
    checkOutDate?: DateTimeNullableFilter | Date | string | null
    earlyDropOff?: BoolFilter | boolean
    latePickup?: BoolFilter | boolean
    customPickupPerson?: StringNullableFilter | string | null
    confirmedBy?: StringNullableFilter | string | null
    cancelReason?: StringNullableFilter | string | null
    cancelDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    customerId?: StringFilter | string
    petId?: StringFilter | string
    serviceId?: StringFilter | string
    resourceId?: StringNullableFilter | string | null
    staffAssignedId?: StringNullableFilter | string | null
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    pet?: XOR<PetRelationFilter, PetWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput> | null
    staffAssigned?: XOR<StaffRelationFilter, StaffWhereInput> | null
    addOnServices?: ReservationAddOnListRelationFilter
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput> | null
    checkIns?: CheckInListRelationFilter
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    staffNotes?: SortOrderInput | SortOrder
    checkInWindow?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurringPattern?: SortOrderInput | SortOrder
    preChecked?: SortOrder
    checkInDate?: SortOrderInput | SortOrder
    checkOutDate?: SortOrderInput | SortOrder
    earlyDropOff?: SortOrder
    latePickup?: SortOrder
    customPickupPerson?: SortOrderInput | SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    cancelDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    petId?: SortOrder
    serviceId?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    staffAssignedId?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    pet?: PetOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
    staffAssigned?: StaffOrderByWithRelationInput
    addOnServices?: ReservationAddOnOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
    checkIns?: CheckInOrderByRelationAggregateInput
  }

  export type ReservationWhereUniqueInput = {
    id?: string
  }

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    staffNotes?: SortOrderInput | SortOrder
    checkInWindow?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurringPattern?: SortOrderInput | SortOrder
    preChecked?: SortOrder
    checkInDate?: SortOrderInput | SortOrder
    checkOutDate?: SortOrderInput | SortOrder
    earlyDropOff?: SortOrder
    latePickup?: SortOrder
    customPickupPerson?: SortOrderInput | SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    cancelDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    petId?: SortOrder
    serviceId?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    staffAssignedId?: SortOrderInput | SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _avg?: ReservationAvgOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
    _sum?: ReservationSumOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReservationScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReservationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReservationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    startDate?: DateTimeWithAggregatesFilter | Date | string
    endDate?: DateTimeWithAggregatesFilter | Date | string
    status?: EnumReservationStatusWithAggregatesFilter | ReservationStatus
    notes?: StringNullableWithAggregatesFilter | string | null
    staffNotes?: StringNullableWithAggregatesFilter | string | null
    checkInWindow?: IntNullableWithAggregatesFilter | number | null
    isRecurring?: BoolWithAggregatesFilter | boolean
    recurringPattern?: StringNullableWithAggregatesFilter | string | null
    preChecked?: BoolWithAggregatesFilter | boolean
    checkInDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    checkOutDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    earlyDropOff?: BoolWithAggregatesFilter | boolean
    latePickup?: BoolWithAggregatesFilter | boolean
    customPickupPerson?: StringNullableWithAggregatesFilter | string | null
    confirmedBy?: StringNullableWithAggregatesFilter | string | null
    cancelReason?: StringNullableWithAggregatesFilter | string | null
    cancelDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    customerId?: StringWithAggregatesFilter | string
    petId?: StringWithAggregatesFilter | string
    serviceId?: StringWithAggregatesFilter | string
    resourceId?: StringNullableWithAggregatesFilter | string | null
    staffAssignedId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ServiceWhereInput = {
    AND?: Enumerable<ServiceWhereInput>
    OR?: Enumerable<ServiceWhereInput>
    NOT?: Enumerable<ServiceWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    duration?: IntFilter | number
    price?: FloatFilter | number
    color?: StringNullableFilter | string | null
    serviceCategory?: EnumServiceCategoryFilter | ServiceCategory
    isActive?: BoolFilter | boolean
    capacityLimit?: IntNullableFilter | number | null
    requiresStaff?: BoolFilter | boolean
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    reservations?: ReservationListRelationFilter
    availableAddOns?: AddOnServiceListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrder
    price?: SortOrder
    color?: SortOrderInput | SortOrder
    serviceCategory?: SortOrder
    isActive?: SortOrder
    capacityLimit?: SortOrderInput | SortOrder
    requiresStaff?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reservations?: ReservationOrderByRelationAggregateInput
    availableAddOns?: AddOnServiceOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = {
    id?: string
  }

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrder
    price?: SortOrder
    color?: SortOrderInput | SortOrder
    serviceCategory?: SortOrder
    isActive?: SortOrder
    capacityLimit?: SortOrderInput | SortOrder
    requiresStaff?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    duration?: IntWithAggregatesFilter | number
    price?: FloatWithAggregatesFilter | number
    color?: StringNullableWithAggregatesFilter | string | null
    serviceCategory?: EnumServiceCategoryWithAggregatesFilter | ServiceCategory
    isActive?: BoolWithAggregatesFilter | boolean
    capacityLimit?: IntNullableWithAggregatesFilter | number | null
    requiresStaff?: BoolWithAggregatesFilter | boolean
    notes?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AddOnServiceWhereInput = {
    AND?: Enumerable<AddOnServiceWhereInput>
    OR?: Enumerable<AddOnServiceWhereInput>
    NOT?: Enumerable<AddOnServiceWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    price?: FloatFilter | number
    duration?: IntNullableFilter | number | null
    serviceId?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    reservationAddOns?: ReservationAddOnListRelationFilter
  }

  export type AddOnServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrderInput | SortOrder
    serviceId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
    reservationAddOns?: ReservationAddOnOrderByRelationAggregateInput
  }

  export type AddOnServiceWhereUniqueInput = {
    id?: string
  }

  export type AddOnServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrderInput | SortOrder
    serviceId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddOnServiceCountOrderByAggregateInput
    _avg?: AddOnServiceAvgOrderByAggregateInput
    _max?: AddOnServiceMaxOrderByAggregateInput
    _min?: AddOnServiceMinOrderByAggregateInput
    _sum?: AddOnServiceSumOrderByAggregateInput
  }

  export type AddOnServiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddOnServiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddOnServiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddOnServiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    price?: FloatWithAggregatesFilter | number
    duration?: IntNullableWithAggregatesFilter | number | null
    serviceId?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ReservationAddOnWhereInput = {
    AND?: Enumerable<ReservationAddOnWhereInput>
    OR?: Enumerable<ReservationAddOnWhereInput>
    NOT?: Enumerable<ReservationAddOnWhereInput>
    id?: StringFilter | string
    reservationId?: StringFilter | string
    addOnId?: StringFilter | string
    price?: FloatFilter | number
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    reservation?: XOR<ReservationRelationFilter, ReservationWhereInput>
    addOn?: XOR<AddOnServiceRelationFilter, AddOnServiceWhereInput>
  }

  export type ReservationAddOnOrderByWithRelationInput = {
    id?: SortOrder
    reservationId?: SortOrder
    addOnId?: SortOrder
    price?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reservation?: ReservationOrderByWithRelationInput
    addOn?: AddOnServiceOrderByWithRelationInput
  }

  export type ReservationAddOnWhereUniqueInput = {
    id?: string
  }

  export type ReservationAddOnOrderByWithAggregationInput = {
    id?: SortOrder
    reservationId?: SortOrder
    addOnId?: SortOrder
    price?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReservationAddOnCountOrderByAggregateInput
    _avg?: ReservationAddOnAvgOrderByAggregateInput
    _max?: ReservationAddOnMaxOrderByAggregateInput
    _min?: ReservationAddOnMinOrderByAggregateInput
    _sum?: ReservationAddOnSumOrderByAggregateInput
  }

  export type ReservationAddOnScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReservationAddOnScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReservationAddOnScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReservationAddOnScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    reservationId?: StringWithAggregatesFilter | string
    addOnId?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    notes?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ResourceWhereInput = {
    AND?: Enumerable<ResourceWhereInput>
    OR?: Enumerable<ResourceWhereInput>
    NOT?: Enumerable<ResourceWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: EnumResourceTypeFilter | ResourceType
    description?: StringNullableFilter | string | null
    capacity?: IntNullableFilter | number | null
    isActive?: BoolFilter | boolean
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    reservations?: ReservationListRelationFilter
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reservations?: ReservationOrderByRelationAggregateInput
  }

  export type ResourceWhereUniqueInput = {
    id?: string
  }

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    isActive?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ResourceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ResourceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ResourceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    type?: EnumResourceTypeWithAggregatesFilter | ResourceType
    description?: StringNullableWithAggregatesFilter | string | null
    capacity?: IntNullableWithAggregatesFilter | number | null
    isActive?: BoolWithAggregatesFilter | boolean
    notes?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type StaffWhereInput = {
    AND?: Enumerable<StaffWhereInput>
    OR?: Enumerable<StaffWhereInput>
    NOT?: Enumerable<StaffWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    phone?: StringNullableFilter | string | null
    role?: StringFilter | string
    workSchedule?: JsonNullableFilter
    specialties?: StringNullableListFilter
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    assignedReservations?: ReservationListRelationFilter
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    workSchedule?: SortOrderInput | SortOrder
    specialties?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedReservations?: ReservationOrderByRelationAggregateInput
  }

  export type StaffWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    workSchedule?: SortOrderInput | SortOrder
    specialties?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StaffScalarWhereWithAggregatesInput>
    OR?: Enumerable<StaffScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StaffScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringNullableWithAggregatesFilter | string | null
    role?: StringWithAggregatesFilter | string
    workSchedule?: JsonNullableWithAggregatesFilter
    specialties?: StringNullableListFilter
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: Enumerable<InvoiceWhereInput>
    OR?: Enumerable<InvoiceWhereInput>
    NOT?: Enumerable<InvoiceWhereInput>
    id?: StringFilter | string
    invoiceNumber?: StringFilter | string
    customerId?: StringFilter | string
    reservationId?: StringNullableFilter | string | null
    issueDate?: DateTimeFilter | Date | string
    dueDate?: DateTimeFilter | Date | string
    status?: EnumInvoiceStatusFilter | InvoiceStatus
    subtotal?: FloatFilter | number
    taxRate?: FloatFilter | number
    taxAmount?: FloatFilter | number
    discount?: FloatFilter | number
    total?: FloatFilter | number
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    reservation?: XOR<ReservationRelationFilter, ReservationWhereInput> | null
    lineItems?: InvoiceLineItemListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    reservationId?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    reservation?: ReservationOrderByWithRelationInput
    lineItems?: InvoiceLineItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = {
    id?: string
    invoiceNumber?: string
    reservationId?: string
  }

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    reservationId?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvoiceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    invoiceNumber?: StringWithAggregatesFilter | string
    customerId?: StringWithAggregatesFilter | string
    reservationId?: StringNullableWithAggregatesFilter | string | null
    issueDate?: DateTimeWithAggregatesFilter | Date | string
    dueDate?: DateTimeWithAggregatesFilter | Date | string
    status?: EnumInvoiceStatusWithAggregatesFilter | InvoiceStatus
    subtotal?: FloatWithAggregatesFilter | number
    taxRate?: FloatWithAggregatesFilter | number
    taxAmount?: FloatWithAggregatesFilter | number
    discount?: FloatWithAggregatesFilter | number
    total?: FloatWithAggregatesFilter | number
    notes?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InvoiceLineItemWhereInput = {
    AND?: Enumerable<InvoiceLineItemWhereInput>
    OR?: Enumerable<InvoiceLineItemWhereInput>
    NOT?: Enumerable<InvoiceLineItemWhereInput>
    id?: StringFilter | string
    invoiceId?: StringFilter | string
    description?: StringFilter | string
    quantity?: IntFilter | number
    unitPrice?: FloatFilter | number
    amount?: FloatFilter | number
    taxable?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceLineItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    taxable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceLineItemWhereUniqueInput = {
    id?: string
  }

  export type InvoiceLineItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    taxable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceLineItemCountOrderByAggregateInput
    _avg?: InvoiceLineItemAvgOrderByAggregateInput
    _max?: InvoiceLineItemMaxOrderByAggregateInput
    _min?: InvoiceLineItemMinOrderByAggregateInput
    _sum?: InvoiceLineItemSumOrderByAggregateInput
  }

  export type InvoiceLineItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InvoiceLineItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<InvoiceLineItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InvoiceLineItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    invoiceId?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    unitPrice?: FloatWithAggregatesFilter | number
    amount?: FloatWithAggregatesFilter | number
    taxable?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PaymentWhereInput = {
    AND?: Enumerable<PaymentWhereInput>
    OR?: Enumerable<PaymentWhereInput>
    NOT?: Enumerable<PaymentWhereInput>
    id?: StringFilter | string
    invoiceId?: StringFilter | string
    customerId?: StringFilter | string
    amount?: FloatFilter | number
    method?: EnumPaymentMethodFilter | PaymentMethod
    status?: EnumPaymentStatusFilter | PaymentStatus
    transactionId?: StringNullableFilter | string | null
    paymentDate?: DateTimeFilter | Date | string
    gatewayResponse?: JsonNullableFilter
    refundedAmount?: FloatFilter | number
    refundReason?: StringNullableFilter | string | null
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    paymentDate?: SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    refundedAmount?: SortOrder
    refundReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = {
    id?: string
  }

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    paymentDate?: SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    refundedAmount?: SortOrder
    refundReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    invoiceId?: StringWithAggregatesFilter | string
    customerId?: StringWithAggregatesFilter | string
    amount?: FloatWithAggregatesFilter | number
    method?: EnumPaymentMethodWithAggregatesFilter | PaymentMethod
    status?: EnumPaymentStatusWithAggregatesFilter | PaymentStatus
    transactionId?: StringNullableWithAggregatesFilter | string | null
    paymentDate?: DateTimeWithAggregatesFilter | Date | string
    gatewayResponse?: JsonNullableWithAggregatesFilter
    refundedAmount?: FloatWithAggregatesFilter | number
    refundReason?: StringNullableWithAggregatesFilter | string | null
    notes?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DocumentWhereInput = {
    AND?: Enumerable<DocumentWhereInput>
    OR?: Enumerable<DocumentWhereInput>
    NOT?: Enumerable<DocumentWhereInput>
    id?: StringFilter | string
    customerId?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    fileUrl?: StringFilter | string
    fileType?: StringFilter | string
    fileSize?: IntFilter | number
    tags?: StringNullableListFilter
    uploaded?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    tags?: SortOrder
    uploaded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = {
    id?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    tags?: SortOrder
    uploaded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    customerId?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    fileUrl?: StringWithAggregatesFilter | string
    fileType?: StringWithAggregatesFilter | string
    fileSize?: IntWithAggregatesFilter | number
    tags?: StringNullableListFilter
    uploaded?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: Enumerable<NotificationPreferenceWhereInput>
    OR?: Enumerable<NotificationPreferenceWhereInput>
    NOT?: Enumerable<NotificationPreferenceWhereInput>
    id?: StringFilter | string
    customerId?: StringFilter | string
    emailNotifications?: BoolFilter | boolean
    smsNotifications?: BoolFilter | boolean
    pushNotifications?: BoolFilter | boolean
    marketingEmails?: BoolFilter | boolean
    appointmentReminders?: BoolFilter | boolean
    checkinNotifications?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    marketingEmails?: SortOrder
    appointmentReminders?: SortOrder
    checkinNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = {
    id?: string
    customerId?: string
  }

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    marketingEmails?: SortOrder
    appointmentReminders?: SortOrder
    checkinNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationPreferenceScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationPreferenceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationPreferenceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    customerId?: StringWithAggregatesFilter | string
    emailNotifications?: BoolWithAggregatesFilter | boolean
    smsNotifications?: BoolWithAggregatesFilter | boolean
    pushNotifications?: BoolWithAggregatesFilter | boolean
    marketingEmails?: BoolWithAggregatesFilter | boolean
    appointmentReminders?: BoolWithAggregatesFilter | boolean
    checkinNotifications?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CheckInWhereInput = {
    AND?: Enumerable<CheckInWhereInput>
    OR?: Enumerable<CheckInWhereInput>
    NOT?: Enumerable<CheckInWhereInput>
    id?: StringFilter | string
    petId?: StringFilter | string
    reservationId?: StringNullableFilter | string | null
    checkInTime?: DateTimeFilter | Date | string
    checkOutTime?: DateTimeNullableFilter | Date | string | null
    checkInNotes?: StringNullableFilter | string | null
    checkOutNotes?: StringNullableFilter | string | null
    checkInBy?: StringNullableFilter | string | null
    checkOutBy?: StringNullableFilter | string | null
    belongingsChecklist?: JsonNullableFilter
    foodProvided?: BoolFilter | boolean
    medicationGiven?: BoolFilter | boolean
    medicationNotes?: StringNullableFilter | string | null
    behaviorDuringStay?: StringNullableFilter | string | null
    photosTaken?: BoolFilter | boolean
    photosShared?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    pet?: XOR<PetRelationFilter, PetWhereInput>
    reservation?: XOR<ReservationRelationFilter, ReservationWhereInput> | null
    activities?: ActivityListRelationFilter
  }

  export type CheckInOrderByWithRelationInput = {
    id?: SortOrder
    petId?: SortOrder
    reservationId?: SortOrderInput | SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    checkInNotes?: SortOrderInput | SortOrder
    checkOutNotes?: SortOrderInput | SortOrder
    checkInBy?: SortOrderInput | SortOrder
    checkOutBy?: SortOrderInput | SortOrder
    belongingsChecklist?: SortOrderInput | SortOrder
    foodProvided?: SortOrder
    medicationGiven?: SortOrder
    medicationNotes?: SortOrderInput | SortOrder
    behaviorDuringStay?: SortOrderInput | SortOrder
    photosTaken?: SortOrder
    photosShared?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pet?: PetOrderByWithRelationInput
    reservation?: ReservationOrderByWithRelationInput
    activities?: ActivityOrderByRelationAggregateInput
  }

  export type CheckInWhereUniqueInput = {
    id?: string
  }

  export type CheckInOrderByWithAggregationInput = {
    id?: SortOrder
    petId?: SortOrder
    reservationId?: SortOrderInput | SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    checkInNotes?: SortOrderInput | SortOrder
    checkOutNotes?: SortOrderInput | SortOrder
    checkInBy?: SortOrderInput | SortOrder
    checkOutBy?: SortOrderInput | SortOrder
    belongingsChecklist?: SortOrderInput | SortOrder
    foodProvided?: SortOrder
    medicationGiven?: SortOrder
    medicationNotes?: SortOrderInput | SortOrder
    behaviorDuringStay?: SortOrderInput | SortOrder
    photosTaken?: SortOrder
    photosShared?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CheckInCountOrderByAggregateInput
    _max?: CheckInMaxOrderByAggregateInput
    _min?: CheckInMinOrderByAggregateInput
  }

  export type CheckInScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CheckInScalarWhereWithAggregatesInput>
    OR?: Enumerable<CheckInScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CheckInScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    petId?: StringWithAggregatesFilter | string
    reservationId?: StringNullableWithAggregatesFilter | string | null
    checkInTime?: DateTimeWithAggregatesFilter | Date | string
    checkOutTime?: DateTimeNullableWithAggregatesFilter | Date | string | null
    checkInNotes?: StringNullableWithAggregatesFilter | string | null
    checkOutNotes?: StringNullableWithAggregatesFilter | string | null
    checkInBy?: StringNullableWithAggregatesFilter | string | null
    checkOutBy?: StringNullableWithAggregatesFilter | string | null
    belongingsChecklist?: JsonNullableWithAggregatesFilter
    foodProvided?: BoolWithAggregatesFilter | boolean
    medicationGiven?: BoolWithAggregatesFilter | boolean
    medicationNotes?: StringNullableWithAggregatesFilter | string | null
    behaviorDuringStay?: StringNullableWithAggregatesFilter | string | null
    photosTaken?: BoolWithAggregatesFilter | boolean
    photosShared?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ActivityWhereInput = {
    AND?: Enumerable<ActivityWhereInput>
    OR?: Enumerable<ActivityWhereInput>
    NOT?: Enumerable<ActivityWhereInput>
    id?: StringFilter | string
    checkInId?: StringFilter | string
    activityType?: StringFilter | string
    notes?: StringNullableFilter | string | null
    timestamp?: DateTimeFilter | Date | string
    recordedBy?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    checkIn?: XOR<CheckInRelationFilter, CheckInWhereInput>
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    checkInId?: SortOrder
    activityType?: SortOrder
    notes?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    recordedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    checkIn?: CheckInOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = {
    id?: string
  }

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    checkInId?: SortOrder
    activityType?: SortOrder
    notes?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    recordedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    OR?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ActivityScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    checkInId?: StringWithAggregatesFilter | string
    activityType?: StringWithAggregatesFilter | string
    notes?: StringNullableWithAggregatesFilter | string | null
    timestamp?: DateTimeWithAggregatesFilter | Date | string
    recordedBy?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MedicalRecordWhereInput = {
    AND?: Enumerable<MedicalRecordWhereInput>
    OR?: Enumerable<MedicalRecordWhereInput>
    NOT?: Enumerable<MedicalRecordWhereInput>
    id?: StringFilter | string
    petId?: StringFilter | string
    recordType?: StringFilter | string
    recordDate?: DateTimeFilter | Date | string
    expirationDate?: DateTimeNullableFilter | Date | string | null
    description?: StringFilter | string
    veterinarian?: StringNullableFilter | string | null
    fileUrl?: StringNullableFilter | string | null
    verified?: BoolFilter | boolean
    verifiedBy?: StringNullableFilter | string | null
    verifiedDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    pet?: XOR<PetRelationFilter, PetWhereInput>
  }

  export type MedicalRecordOrderByWithRelationInput = {
    id?: SortOrder
    petId?: SortOrder
    recordType?: SortOrder
    recordDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    description?: SortOrder
    veterinarian?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pet?: PetOrderByWithRelationInput
  }

  export type MedicalRecordWhereUniqueInput = {
    id?: string
  }

  export type MedicalRecordOrderByWithAggregationInput = {
    id?: SortOrder
    petId?: SortOrder
    recordType?: SortOrder
    recordDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    description?: SortOrder
    veterinarian?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicalRecordCountOrderByAggregateInput
    _max?: MedicalRecordMaxOrderByAggregateInput
    _min?: MedicalRecordMinOrderByAggregateInput
  }

  export type MedicalRecordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MedicalRecordScalarWhereWithAggregatesInput>
    OR?: Enumerable<MedicalRecordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MedicalRecordScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    petId?: StringWithAggregatesFilter | string
    recordType?: StringWithAggregatesFilter | string
    recordDate?: DateTimeWithAggregatesFilter | Date | string
    expirationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    description?: StringWithAggregatesFilter | string
    veterinarian?: StringNullableWithAggregatesFilter | string | null
    fileUrl?: StringNullableWithAggregatesFilter | string | null
    verified?: BoolWithAggregatesFilter | boolean
    verifiedBy?: StringNullableWithAggregatesFilter | string | null
    verifiedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetCreateNestedManyWithoutOwnerInput
    reservations?: ReservationCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    documents?: DocumentCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetUncheckedCreateNestedManyWithoutOwnerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUpdateManyWithoutOwnerNestedInput
    reservations?: ReservationUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUncheckedUpdateManyWithoutOwnerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetCreateInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: CustomerCreateNestedOneWithoutPetsInput
    reservations?: ReservationCreateNestedManyWithoutPetInput
    checkIns?: CheckInCreateNestedManyWithoutPetInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    reservations?: ReservationUncheckedCreateNestedManyWithoutPetInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutPetInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: CustomerUpdateOneRequiredWithoutPetsNestedInput
    reservations?: ReservationUpdateManyWithoutPetNestedInput
    checkIns?: CheckInUpdateManyWithoutPetNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    reservations?: ReservationUncheckedUpdateManyWithoutPetNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutPetNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetCreateManyInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
  }

  export type PetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type ReservationCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutReservationsInput
    pet: PetCreateNestedOneWithoutReservationsInput
    service: ServiceCreateNestedOneWithoutReservationsInput
    resource?: ResourceCreateNestedOneWithoutReservationsInput
    staffAssigned?: StaffCreateNestedOneWithoutAssignedReservationsInput
    addOnServices?: ReservationAddOnCreateNestedManyWithoutReservationInput
    invoice?: InvoiceCreateNestedOneWithoutReservationInput
    checkIns?: CheckInCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    petId: string
    serviceId: string
    resourceId?: string | null
    staffAssignedId?: string | null
    addOnServices?: ReservationAddOnUncheckedCreateNestedManyWithoutReservationInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutReservationInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutReservationsNestedInput
    pet?: PetUpdateOneRequiredWithoutReservationsNestedInput
    service?: ServiceUpdateOneRequiredWithoutReservationsNestedInput
    resource?: ResourceUpdateOneWithoutReservationsNestedInput
    staffAssigned?: StaffUpdateOneWithoutAssignedReservationsNestedInput
    addOnServices?: ReservationAddOnUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    staffAssignedId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnServices?: ReservationAddOnUncheckedUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    petId: string
    serviceId: string
    resourceId?: string | null
    staffAssignedId?: string | null
  }

  export type ReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    staffAssignedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    price: number
    color?: string | null
    serviceCategory: ServiceCategory
    isActive?: boolean
    capacityLimit?: number | null
    requiresStaff?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutServiceInput
    availableAddOns?: AddOnServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    price: number
    color?: string | null
    serviceCategory: ServiceCategory
    isActive?: boolean
    capacityLimit?: number | null
    requiresStaff?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutServiceInput
    availableAddOns?: AddOnServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | ServiceCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    capacityLimit?: NullableIntFieldUpdateOperationsInput | number | null
    requiresStaff?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutServiceNestedInput
    availableAddOns?: AddOnServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | ServiceCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    capacityLimit?: NullableIntFieldUpdateOperationsInput | number | null
    requiresStaff?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutServiceNestedInput
    availableAddOns?: AddOnServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    price: number
    color?: string | null
    serviceCategory: ServiceCategory
    isActive?: boolean
    capacityLimit?: number | null
    requiresStaff?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | ServiceCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    capacityLimit?: NullableIntFieldUpdateOperationsInput | number | null
    requiresStaff?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | ServiceCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    capacityLimit?: NullableIntFieldUpdateOperationsInput | number | null
    requiresStaff?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnServiceCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutAvailableAddOnsInput
    reservationAddOns?: ReservationAddOnCreateNestedManyWithoutAddOnInput
  }

  export type AddOnServiceUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration?: number | null
    serviceId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservationAddOns?: ReservationAddOnUncheckedCreateNestedManyWithoutAddOnInput
  }

  export type AddOnServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutAvailableAddOnsNestedInput
    reservationAddOns?: ReservationAddOnUpdateManyWithoutAddOnNestedInput
  }

  export type AddOnServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservationAddOns?: ReservationAddOnUncheckedUpdateManyWithoutAddOnNestedInput
  }

  export type AddOnServiceCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration?: number | null
    serviceId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddOnServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationAddOnCreateInput = {
    id?: string
    price: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservation: ReservationCreateNestedOneWithoutAddOnServicesInput
    addOn: AddOnServiceCreateNestedOneWithoutReservationAddOnsInput
  }

  export type ReservationAddOnUncheckedCreateInput = {
    id?: string
    reservationId: string
    addOnId: string
    price: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationAddOnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservation?: ReservationUpdateOneRequiredWithoutAddOnServicesNestedInput
    addOn?: AddOnServiceUpdateOneRequiredWithoutReservationAddOnsNestedInput
  }

  export type ReservationAddOnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationAddOnCreateManyInput = {
    id?: string
    reservationId: string
    addOnId: string
    price: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationAddOnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationAddOnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateInput = {
    id?: string
    name: string
    type: ResourceType
    description?: string | null
    capacity?: number | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: string
    name: string
    type: ResourceType
    description?: string | null
    capacity?: number | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | ResourceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | ResourceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceCreateManyInput = {
    id?: string
    name: string
    type: ResourceType
    description?: string | null
    capacity?: number | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | ResourceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | ResourceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    specialties?: StaffCreatespecialtiesInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedReservations?: ReservationCreateNestedManyWithoutStaffAssignedInput
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    specialties?: StaffCreatespecialtiesInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedReservations?: ReservationUncheckedCreateNestedManyWithoutStaffAssignedInput
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    specialties?: StaffUpdatespecialtiesInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedReservations?: ReservationUpdateManyWithoutStaffAssignedNestedInput
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    specialties?: StaffUpdatespecialtiesInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedReservations?: ReservationUncheckedUpdateManyWithoutStaffAssignedNestedInput
  }

  export type StaffCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    specialties?: StaffCreatespecialtiesInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    specialties?: StaffUpdatespecialtiesInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    specialties?: StaffUpdatespecialtiesInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    reservation?: ReservationCreateNestedOneWithoutInvoiceInput
    lineItems?: InvoiceLineItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    customerId: string
    reservationId?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    reservation?: ReservationUpdateOneWithoutInvoiceNestedInput
    lineItems?: InvoiceLineItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    customerId: string
    reservationId?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemCreateInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: number
    amount: number
    taxable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutLineItemsInput
  }

  export type InvoiceLineItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    quantity?: number
    unitPrice: number
    amount: number
    taxable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutLineItemsNestedInput
  }

  export type InvoiceLineItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    quantity?: number
    unitPrice: number
    amount: number
    taxable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    method: PaymentMethod
    status?: PaymentStatus
    transactionId?: string | null
    paymentDate?: Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: number
    refundReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    customer: CustomerCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    invoiceId: string
    customerId: string
    amount: number
    method: PaymentMethod
    status?: PaymentStatus
    transactionId?: string | null
    paymentDate?: Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: number
    refundReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: FloatFieldUpdateOperationsInput | number
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: FloatFieldUpdateOperationsInput | number
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    invoiceId: string
    customerId: string
    amount: number
    method: PaymentMethod
    status?: PaymentStatus
    transactionId?: string | null
    paymentDate?: Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: number
    refundReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: FloatFieldUpdateOperationsInput | number
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: FloatFieldUpdateOperationsInput | number
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    tags?: DocumentCreatetagsInput | Enumerable<string>
    uploaded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    customerId: string
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    tags?: DocumentCreatetagsInput | Enumerable<string>
    uploaded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    tags?: DocumentUpdatetagsInput | Enumerable<string>
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    tags?: DocumentUpdatetagsInput | Enumerable<string>
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    customerId: string
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    tags?: DocumentCreatetagsInput | Enumerable<string>
    uploaded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    tags?: DocumentUpdatetagsInput | Enumerable<string>
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    tags?: DocumentUpdatetagsInput | Enumerable<string>
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    marketingEmails?: boolean
    appointmentReminders?: boolean
    checkinNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    customerId: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    marketingEmails?: boolean
    appointmentReminders?: boolean
    checkinNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    appointmentReminders?: BoolFieldUpdateOperationsInput | boolean
    checkinNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    appointmentReminders?: BoolFieldUpdateOperationsInput | boolean
    checkinNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    customerId: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    marketingEmails?: boolean
    appointmentReminders?: boolean
    checkinNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    appointmentReminders?: BoolFieldUpdateOperationsInput | boolean
    checkinNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    appointmentReminders?: BoolFieldUpdateOperationsInput | boolean
    checkinNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInCreateInput = {
    id?: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    checkInNotes?: string | null
    checkOutNotes?: string | null
    checkInBy?: string | null
    checkOutBy?: string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: string | null
    behaviorDuringStay?: string | null
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pet: PetCreateNestedOneWithoutCheckInsInput
    reservation?: ReservationCreateNestedOneWithoutCheckInsInput
    activities?: ActivityCreateNestedManyWithoutCheckInInput
  }

  export type CheckInUncheckedCreateInput = {
    id?: string
    petId: string
    reservationId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    checkInNotes?: string | null
    checkOutNotes?: string | null
    checkInBy?: string | null
    checkOutBy?: string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: string | null
    behaviorDuringStay?: string | null
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutCheckInInput
  }

  export type CheckInUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutBy?: NullableStringFieldUpdateOperationsInput | string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: BoolFieldUpdateOperationsInput | boolean
    medicationGiven?: BoolFieldUpdateOperationsInput | boolean
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorDuringStay?: NullableStringFieldUpdateOperationsInput | string | null
    photosTaken?: BoolFieldUpdateOperationsInput | boolean
    photosShared?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneRequiredWithoutCheckInsNestedInput
    reservation?: ReservationUpdateOneWithoutCheckInsNestedInput
    activities?: ActivityUpdateManyWithoutCheckInNestedInput
  }

  export type CheckInUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutBy?: NullableStringFieldUpdateOperationsInput | string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: BoolFieldUpdateOperationsInput | boolean
    medicationGiven?: BoolFieldUpdateOperationsInput | boolean
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorDuringStay?: NullableStringFieldUpdateOperationsInput | string | null
    photosTaken?: BoolFieldUpdateOperationsInput | boolean
    photosShared?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutCheckInNestedInput
  }

  export type CheckInCreateManyInput = {
    id?: string
    petId: string
    reservationId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    checkInNotes?: string | null
    checkOutNotes?: string | null
    checkInBy?: string | null
    checkOutBy?: string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: string | null
    behaviorDuringStay?: string | null
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheckInUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutBy?: NullableStringFieldUpdateOperationsInput | string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: BoolFieldUpdateOperationsInput | boolean
    medicationGiven?: BoolFieldUpdateOperationsInput | boolean
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorDuringStay?: NullableStringFieldUpdateOperationsInput | string | null
    photosTaken?: BoolFieldUpdateOperationsInput | boolean
    photosShared?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutBy?: NullableStringFieldUpdateOperationsInput | string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: BoolFieldUpdateOperationsInput | boolean
    medicationGiven?: BoolFieldUpdateOperationsInput | boolean
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorDuringStay?: NullableStringFieldUpdateOperationsInput | string | null
    photosTaken?: BoolFieldUpdateOperationsInput | boolean
    photosShared?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    activityType: string
    notes?: string | null
    timestamp?: Date | string
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checkIn: CheckInCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    checkInId: string
    activityType: string
    notes?: string | null
    timestamp?: Date | string
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: CheckInUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInId?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    checkInId: string
    activityType: string
    notes?: string | null
    timestamp?: Date | string
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInId?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordCreateInput = {
    id?: string
    recordType: string
    recordDate: Date | string
    expirationDate?: Date | string | null
    description: string
    veterinarian?: string | null
    fileUrl?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pet: PetCreateNestedOneWithoutMedicalRecordsInput
  }

  export type MedicalRecordUncheckedCreateInput = {
    id?: string
    petId: string
    recordType: string
    recordDate: Date | string
    expirationDate?: Date | string | null
    description: string
    veterinarian?: string | null
    fileUrl?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    veterinarian?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneRequiredWithoutMedicalRecordsNestedInput
  }

  export type MedicalRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    veterinarian?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordCreateManyInput = {
    id?: string
    petId: string
    recordType: string
    recordDate: Date | string
    expirationDate?: Date | string | null
    description: string
    veterinarian?: string | null
    fileUrl?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    veterinarian?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    veterinarian?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type EnumContactMethodFilter = {
    equals?: ContactMethod
    in?: Enumerable<ContactMethod>
    notIn?: Enumerable<ContactMethod>
    not?: NestedEnumContactMethodFilter | ContactMethod
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type PetListRelationFilter = {
    every?: PetWhereInput
    some?: PetWhereInput
    none?: PetWhereInput
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type NotificationPreferenceRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    alternatePhone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    notes?: SortOrder
    portalEnabled?: SortOrder
    preferredContact?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    vatTaxId?: SortOrder
    referralSource?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    alternatePhone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    notes?: SortOrder
    portalEnabled?: SortOrder
    preferredContact?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    vatTaxId?: SortOrder
    referralSource?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    alternatePhone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    notes?: SortOrder
    portalEnabled?: SortOrder
    preferredContact?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    vatTaxId?: SortOrder
    referralSource?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EnumContactMethodWithAggregatesFilter = {
    equals?: ContactMethod
    in?: Enumerable<ContactMethod>
    notIn?: Enumerable<ContactMethod>
    not?: NestedEnumContactMethodWithAggregatesFilter | ContactMethod
    _count?: NestedIntFilter
    _min?: NestedEnumContactMethodFilter
    _max?: NestedEnumContactMethodFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type EnumPetTypeFilter = {
    equals?: PetType
    in?: Enumerable<PetType>
    notIn?: Enumerable<PetType>
    not?: NestedEnumPetTypeFilter | PetType
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type EnumGenderNullableFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableFilter | Gender | null
  }

  export type EnumPlayGroupTypeNullableFilter = {
    equals?: PlayGroupType | null
    in?: Enumerable<PlayGroupType> | null
    notIn?: Enumerable<PlayGroupType> | null
    not?: NestedEnumPlayGroupTypeNullableFilter | PlayGroupType | null
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type CheckInListRelationFilter = {
    every?: CheckInWhereInput
    some?: CheckInWhereInput
    none?: CheckInWhereInput
  }

  export type MedicalRecordListRelationFilter = {
    every?: MedicalRecordWhereInput
    some?: MedicalRecordWhereInput
    none?: MedicalRecordWhereInput
  }

  export type CheckInOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    breed?: SortOrder
    color?: SortOrder
    birthdate?: SortOrder
    weight?: SortOrder
    gender?: SortOrder
    isNeutered?: SortOrder
    microchipNumber?: SortOrder
    rabiesTagNumber?: SortOrder
    specialNeeds?: SortOrder
    foodNotes?: SortOrder
    medicationNotes?: SortOrder
    behaviorNotes?: SortOrder
    allergies?: SortOrder
    idealPlayGroup?: SortOrder
    vaccinationStatus?: SortOrder
    vaccineExpirations?: SortOrder
    vetName?: SortOrder
    vetPhone?: SortOrder
    profilePhoto?: SortOrder
    isActive?: SortOrder
    lastCheckIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
  }

  export type PetAvgOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type PetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    breed?: SortOrder
    color?: SortOrder
    birthdate?: SortOrder
    weight?: SortOrder
    gender?: SortOrder
    isNeutered?: SortOrder
    microchipNumber?: SortOrder
    rabiesTagNumber?: SortOrder
    specialNeeds?: SortOrder
    foodNotes?: SortOrder
    medicationNotes?: SortOrder
    behaviorNotes?: SortOrder
    allergies?: SortOrder
    idealPlayGroup?: SortOrder
    vetName?: SortOrder
    vetPhone?: SortOrder
    profilePhoto?: SortOrder
    isActive?: SortOrder
    lastCheckIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
  }

  export type PetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    breed?: SortOrder
    color?: SortOrder
    birthdate?: SortOrder
    weight?: SortOrder
    gender?: SortOrder
    isNeutered?: SortOrder
    microchipNumber?: SortOrder
    rabiesTagNumber?: SortOrder
    specialNeeds?: SortOrder
    foodNotes?: SortOrder
    medicationNotes?: SortOrder
    behaviorNotes?: SortOrder
    allergies?: SortOrder
    idealPlayGroup?: SortOrder
    vetName?: SortOrder
    vetPhone?: SortOrder
    profilePhoto?: SortOrder
    isActive?: SortOrder
    lastCheckIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
  }

  export type PetSumOrderByAggregateInput = {
    weight?: SortOrder
  }

  export type EnumPetTypeWithAggregatesFilter = {
    equals?: PetType
    in?: Enumerable<PetType>
    notIn?: Enumerable<PetType>
    not?: NestedEnumPetTypeWithAggregatesFilter | PetType
    _count?: NestedIntFilter
    _min?: NestedEnumPetTypeFilter
    _max?: NestedEnumPetTypeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type EnumGenderNullableWithAggregatesFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter | Gender | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderNullableFilter
    _max?: NestedEnumGenderNullableFilter
  }

  export type EnumPlayGroupTypeNullableWithAggregatesFilter = {
    equals?: PlayGroupType | null
    in?: Enumerable<PlayGroupType> | null
    notIn?: Enumerable<PlayGroupType> | null
    not?: NestedEnumPlayGroupTypeNullableWithAggregatesFilter | PlayGroupType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPlayGroupTypeNullableFilter
    _max?: NestedEnumPlayGroupTypeNullableFilter
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type EnumReservationStatusFilter = {
    equals?: ReservationStatus
    in?: Enumerable<ReservationStatus>
    notIn?: Enumerable<ReservationStatus>
    not?: NestedEnumReservationStatusFilter | ReservationStatus
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type PetRelationFilter = {
    is?: PetWhereInput | null
    isNot?: PetWhereInput | null
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type ResourceRelationFilter = {
    is?: ResourceWhereInput | null
    isNot?: ResourceWhereInput | null
  }

  export type StaffRelationFilter = {
    is?: StaffWhereInput | null
    isNot?: StaffWhereInput | null
  }

  export type ReservationAddOnListRelationFilter = {
    every?: ReservationAddOnWhereInput
    some?: ReservationAddOnWhereInput
    none?: ReservationAddOnWhereInput
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type ReservationAddOnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    staffNotes?: SortOrder
    checkInWindow?: SortOrder
    isRecurring?: SortOrder
    recurringPattern?: SortOrder
    preChecked?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    earlyDropOff?: SortOrder
    latePickup?: SortOrder
    customPickupPerson?: SortOrder
    confirmedBy?: SortOrder
    cancelReason?: SortOrder
    cancelDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    petId?: SortOrder
    serviceId?: SortOrder
    resourceId?: SortOrder
    staffAssignedId?: SortOrder
  }

  export type ReservationAvgOrderByAggregateInput = {
    checkInWindow?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    staffNotes?: SortOrder
    checkInWindow?: SortOrder
    isRecurring?: SortOrder
    recurringPattern?: SortOrder
    preChecked?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    earlyDropOff?: SortOrder
    latePickup?: SortOrder
    customPickupPerson?: SortOrder
    confirmedBy?: SortOrder
    cancelReason?: SortOrder
    cancelDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    petId?: SortOrder
    serviceId?: SortOrder
    resourceId?: SortOrder
    staffAssignedId?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    staffNotes?: SortOrder
    checkInWindow?: SortOrder
    isRecurring?: SortOrder
    recurringPattern?: SortOrder
    preChecked?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    earlyDropOff?: SortOrder
    latePickup?: SortOrder
    customPickupPerson?: SortOrder
    confirmedBy?: SortOrder
    cancelReason?: SortOrder
    cancelDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    petId?: SortOrder
    serviceId?: SortOrder
    resourceId?: SortOrder
    staffAssignedId?: SortOrder
  }

  export type ReservationSumOrderByAggregateInput = {
    checkInWindow?: SortOrder
  }

  export type EnumReservationStatusWithAggregatesFilter = {
    equals?: ReservationStatus
    in?: Enumerable<ReservationStatus>
    notIn?: Enumerable<ReservationStatus>
    not?: NestedEnumReservationStatusWithAggregatesFilter | ReservationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumReservationStatusFilter
    _max?: NestedEnumReservationStatusFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type EnumServiceCategoryFilter = {
    equals?: ServiceCategory
    in?: Enumerable<ServiceCategory>
    notIn?: Enumerable<ServiceCategory>
    not?: NestedEnumServiceCategoryFilter | ServiceCategory
  }

  export type AddOnServiceListRelationFilter = {
    every?: AddOnServiceWhereInput
    some?: AddOnServiceWhereInput
    none?: AddOnServiceWhereInput
  }

  export type AddOnServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    color?: SortOrder
    serviceCategory?: SortOrder
    isActive?: SortOrder
    capacityLimit?: SortOrder
    requiresStaff?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
    capacityLimit?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    color?: SortOrder
    serviceCategory?: SortOrder
    isActive?: SortOrder
    capacityLimit?: SortOrder
    requiresStaff?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    color?: SortOrder
    serviceCategory?: SortOrder
    isActive?: SortOrder
    capacityLimit?: SortOrder
    requiresStaff?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
    capacityLimit?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type EnumServiceCategoryWithAggregatesFilter = {
    equals?: ServiceCategory
    in?: Enumerable<ServiceCategory>
    notIn?: Enumerable<ServiceCategory>
    not?: NestedEnumServiceCategoryWithAggregatesFilter | ServiceCategory
    _count?: NestedIntFilter
    _min?: NestedEnumServiceCategoryFilter
    _max?: NestedEnumServiceCategoryFilter
  }

  export type AddOnServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    serviceId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddOnServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type AddOnServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    serviceId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddOnServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    serviceId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddOnServiceSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type ReservationRelationFilter = {
    is?: ReservationWhereInput | null
    isNot?: ReservationWhereInput | null
  }

  export type AddOnServiceRelationFilter = {
    is?: AddOnServiceWhereInput | null
    isNot?: AddOnServiceWhereInput | null
  }

  export type ReservationAddOnCountOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    addOnId?: SortOrder
    price?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationAddOnAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ReservationAddOnMaxOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    addOnId?: SortOrder
    price?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationAddOnMinOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    addOnId?: SortOrder
    price?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationAddOnSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumResourceTypeFilter = {
    equals?: ResourceType
    in?: Enumerable<ResourceType>
    notIn?: Enumerable<ResourceType>
    not?: NestedEnumResourceTypeFilter | ResourceType
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    capacity?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    capacity?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    capacity?: SortOrder
    isActive?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type EnumResourceTypeWithAggregatesFilter = {
    equals?: ResourceType
    in?: Enumerable<ResourceType>
    notIn?: Enumerable<ResourceType>
    not?: NestedEnumResourceTypeWithAggregatesFilter | ResourceType
    _count?: NestedIntFilter
    _min?: NestedEnumResourceTypeFilter
    _max?: NestedEnumResourceTypeFilter
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    workSchedule?: SortOrder
    specialties?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInvoiceStatusFilter = {
    equals?: InvoiceStatus
    in?: Enumerable<InvoiceStatus>
    notIn?: Enumerable<InvoiceStatus>
    not?: NestedEnumInvoiceStatusFilter | InvoiceStatus
  }

  export type InvoiceLineItemListRelationFilter = {
    every?: InvoiceLineItemWhereInput
    some?: InvoiceLineItemWhereInput
    none?: InvoiceLineItemWhereInput
  }

  export type InvoiceLineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    reservationId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    reservationId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    reservationId?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    total?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter = {
    equals?: InvoiceStatus
    in?: Enumerable<InvoiceStatus>
    notIn?: Enumerable<InvoiceStatus>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter | InvoiceStatus
    _count?: NestedIntFilter
    _min?: NestedEnumInvoiceStatusFilter
    _max?: NestedEnumInvoiceStatusFilter
  }

  export type InvoiceLineItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    taxable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLineItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceLineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    taxable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLineItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
    taxable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceLineItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    amount?: SortOrder
  }

  export type EnumPaymentMethodFilter = {
    equals?: PaymentMethod
    in?: Enumerable<PaymentMethod>
    notIn?: Enumerable<PaymentMethod>
    not?: NestedEnumPaymentMethodFilter | PaymentMethod
  }

  export type EnumPaymentStatusFilter = {
    equals?: PaymentStatus
    in?: Enumerable<PaymentStatus>
    notIn?: Enumerable<PaymentStatus>
    not?: NestedEnumPaymentStatusFilter | PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    paymentDate?: SortOrder
    gatewayResponse?: SortOrder
    refundedAmount?: SortOrder
    refundReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    refundedAmount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    paymentDate?: SortOrder
    refundedAmount?: SortOrder
    refundReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    customerId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    paymentDate?: SortOrder
    refundedAmount?: SortOrder
    refundReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    refundedAmount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter = {
    equals?: PaymentMethod
    in?: Enumerable<PaymentMethod>
    notIn?: Enumerable<PaymentMethod>
    not?: NestedEnumPaymentMethodWithAggregatesFilter | PaymentMethod
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentMethodFilter
    _max?: NestedEnumPaymentMethodFilter
  }

  export type EnumPaymentStatusWithAggregatesFilter = {
    equals?: PaymentStatus
    in?: Enumerable<PaymentStatus>
    notIn?: Enumerable<PaymentStatus>
    not?: NestedEnumPaymentStatusWithAggregatesFilter | PaymentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentStatusFilter
    _max?: NestedEnumPaymentStatusFilter
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    tags?: SortOrder
    uploaded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    uploaded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    uploaded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    marketingEmails?: SortOrder
    appointmentReminders?: SortOrder
    checkinNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    marketingEmails?: SortOrder
    appointmentReminders?: SortOrder
    checkinNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    marketingEmails?: SortOrder
    appointmentReminders?: SortOrder
    checkinNotifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckInCountOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    reservationId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    checkInNotes?: SortOrder
    checkOutNotes?: SortOrder
    checkInBy?: SortOrder
    checkOutBy?: SortOrder
    belongingsChecklist?: SortOrder
    foodProvided?: SortOrder
    medicationGiven?: SortOrder
    medicationNotes?: SortOrder
    behaviorDuringStay?: SortOrder
    photosTaken?: SortOrder
    photosShared?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheckInMaxOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    reservationId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    checkInNotes?: SortOrder
    checkOutNotes?: SortOrder
    checkInBy?: SortOrder
    checkOutBy?: SortOrder
    foodProvided?: SortOrder
    medicationGiven?: SortOrder
    medicationNotes?: SortOrder
    behaviorDuringStay?: SortOrder
    photosTaken?: SortOrder
    photosShared?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheckInMinOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    reservationId?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    checkInNotes?: SortOrder
    checkOutNotes?: SortOrder
    checkInBy?: SortOrder
    checkOutBy?: SortOrder
    foodProvided?: SortOrder
    medicationGiven?: SortOrder
    medicationNotes?: SortOrder
    behaviorDuringStay?: SortOrder
    photosTaken?: SortOrder
    photosShared?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheckInRelationFilter = {
    is?: CheckInWhereInput | null
    isNot?: CheckInWhereInput | null
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    checkInId?: SortOrder
    activityType?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    checkInId?: SortOrder
    activityType?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    checkInId?: SortOrder
    activityType?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalRecordCountOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    recordType?: SortOrder
    recordDate?: SortOrder
    expirationDate?: SortOrder
    description?: SortOrder
    veterinarian?: SortOrder
    fileUrl?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrder
    verifiedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    recordType?: SortOrder
    recordDate?: SortOrder
    expirationDate?: SortOrder
    description?: SortOrder
    veterinarian?: SortOrder
    fileUrl?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrder
    verifiedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalRecordMinOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    recordType?: SortOrder
    recordDate?: SortOrder
    expirationDate?: SortOrder
    description?: SortOrder
    veterinarian?: SortOrder
    fileUrl?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrder
    verifiedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerCreatetagsInput = {
    set: Enumerable<string>
  }

  export type PetCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<PetCreateWithoutOwnerInput>, Enumerable<PetUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<PetCreateOrConnectWithoutOwnerInput>
    createMany?: PetCreateManyOwnerInputEnvelope
    connect?: Enumerable<PetWhereUniqueInput>
  }

  export type ReservationCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutCustomerInput>, Enumerable<ReservationUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutCustomerInput>
    createMany?: ReservationCreateManyCustomerInputEnvelope
    connect?: Enumerable<ReservationWhereUniqueInput>
  }

  export type PaymentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCustomerInput>, Enumerable<PaymentUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCustomerInput>
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type InvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutCustomerInput>, Enumerable<InvoiceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutCustomerInput>
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type DocumentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutCustomerInput>, Enumerable<DocumentUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutCustomerInput>
    createMany?: DocumentCreateManyCustomerInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type NotificationPreferenceCreateNestedOneWithoutCustomerInput = {
    create?: XOR<NotificationPreferenceCreateWithoutCustomerInput, NotificationPreferenceUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutCustomerInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type PetUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<PetCreateWithoutOwnerInput>, Enumerable<PetUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<PetCreateOrConnectWithoutOwnerInput>
    createMany?: PetCreateManyOwnerInputEnvelope
    connect?: Enumerable<PetWhereUniqueInput>
  }

  export type ReservationUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutCustomerInput>, Enumerable<ReservationUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutCustomerInput>
    createMany?: ReservationCreateManyCustomerInputEnvelope
    connect?: Enumerable<ReservationWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCustomerInput>, Enumerable<PaymentUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCustomerInput>
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutCustomerInput>, Enumerable<InvoiceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutCustomerInput>
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: Enumerable<InvoiceWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutCustomerInput>, Enumerable<DocumentUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutCustomerInput>
    createMany?: DocumentCreateManyCustomerInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutCustomerInput = {
    create?: XOR<NotificationPreferenceCreateWithoutCustomerInput, NotificationPreferenceUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutCustomerInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumContactMethodFieldUpdateOperationsInput = {
    set?: ContactMethod
  }

  export type CustomerUpdatetagsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PetUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<PetCreateWithoutOwnerInput>, Enumerable<PetUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<PetCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<PetUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: PetCreateManyOwnerInputEnvelope
    set?: Enumerable<PetWhereUniqueInput>
    disconnect?: Enumerable<PetWhereUniqueInput>
    delete?: Enumerable<PetWhereUniqueInput>
    connect?: Enumerable<PetWhereUniqueInput>
    update?: Enumerable<PetUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<PetUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<PetScalarWhereInput>
  }

  export type ReservationUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutCustomerInput>, Enumerable<ReservationUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<ReservationUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: ReservationCreateManyCustomerInputEnvelope
    set?: Enumerable<ReservationWhereUniqueInput>
    disconnect?: Enumerable<ReservationWhereUniqueInput>
    delete?: Enumerable<ReservationWhereUniqueInput>
    connect?: Enumerable<ReservationWhereUniqueInput>
    update?: Enumerable<ReservationUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<ReservationUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<ReservationScalarWhereInput>
  }

  export type PaymentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCustomerInput>, Enumerable<PaymentUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type InvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutCustomerInput>, Enumerable<InvoiceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type DocumentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutCustomerInput>, Enumerable<DocumentUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: DocumentCreateManyCustomerInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type NotificationPreferenceUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutCustomerInput, NotificationPreferenceUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutCustomerInput
    upsert?: NotificationPreferenceUpsertWithoutCustomerInput
    disconnect?: boolean
    delete?: boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<NotificationPreferenceUpdateWithoutCustomerInput, NotificationPreferenceUncheckedUpdateWithoutCustomerInput>
  }

  export type PetUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<PetCreateWithoutOwnerInput>, Enumerable<PetUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<PetCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<PetUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: PetCreateManyOwnerInputEnvelope
    set?: Enumerable<PetWhereUniqueInput>
    disconnect?: Enumerable<PetWhereUniqueInput>
    delete?: Enumerable<PetWhereUniqueInput>
    connect?: Enumerable<PetWhereUniqueInput>
    update?: Enumerable<PetUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<PetUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<PetScalarWhereInput>
  }

  export type ReservationUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutCustomerInput>, Enumerable<ReservationUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<ReservationUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: ReservationCreateManyCustomerInputEnvelope
    set?: Enumerable<ReservationWhereUniqueInput>
    disconnect?: Enumerable<ReservationWhereUniqueInput>
    delete?: Enumerable<ReservationWhereUniqueInput>
    connect?: Enumerable<ReservationWhereUniqueInput>
    update?: Enumerable<ReservationUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<ReservationUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<ReservationScalarWhereInput>
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutCustomerInput>, Enumerable<PaymentUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<InvoiceCreateWithoutCustomerInput>, Enumerable<InvoiceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<InvoiceCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<InvoiceUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: Enumerable<InvoiceWhereUniqueInput>
    disconnect?: Enumerable<InvoiceWhereUniqueInput>
    delete?: Enumerable<InvoiceWhereUniqueInput>
    connect?: Enumerable<InvoiceWhereUniqueInput>
    update?: Enumerable<InvoiceUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<InvoiceUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<InvoiceScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutCustomerInput>, Enumerable<DocumentUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: DocumentCreateManyCustomerInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutCustomerInput, NotificationPreferenceUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutCustomerInput
    upsert?: NotificationPreferenceUpsertWithoutCustomerInput
    disconnect?: boolean
    delete?: boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<NotificationPreferenceUpdateWithoutCustomerInput, NotificationPreferenceUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerCreateNestedOneWithoutPetsInput = {
    create?: XOR<CustomerCreateWithoutPetsInput, CustomerUncheckedCreateWithoutPetsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPetsInput
    connect?: CustomerWhereUniqueInput
  }

  export type ReservationCreateNestedManyWithoutPetInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutPetInput>, Enumerable<ReservationUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutPetInput>
    createMany?: ReservationCreateManyPetInputEnvelope
    connect?: Enumerable<ReservationWhereUniqueInput>
  }

  export type CheckInCreateNestedManyWithoutPetInput = {
    create?: XOR<Enumerable<CheckInCreateWithoutPetInput>, Enumerable<CheckInUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<CheckInCreateOrConnectWithoutPetInput>
    createMany?: CheckInCreateManyPetInputEnvelope
    connect?: Enumerable<CheckInWhereUniqueInput>
  }

  export type MedicalRecordCreateNestedManyWithoutPetInput = {
    create?: XOR<Enumerable<MedicalRecordCreateWithoutPetInput>, Enumerable<MedicalRecordUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<MedicalRecordCreateOrConnectWithoutPetInput>
    createMany?: MedicalRecordCreateManyPetInputEnvelope
    connect?: Enumerable<MedicalRecordWhereUniqueInput>
  }

  export type ReservationUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutPetInput>, Enumerable<ReservationUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutPetInput>
    createMany?: ReservationCreateManyPetInputEnvelope
    connect?: Enumerable<ReservationWhereUniqueInput>
  }

  export type CheckInUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<Enumerable<CheckInCreateWithoutPetInput>, Enumerable<CheckInUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<CheckInCreateOrConnectWithoutPetInput>
    createMany?: CheckInCreateManyPetInputEnvelope
    connect?: Enumerable<CheckInWhereUniqueInput>
  }

  export type MedicalRecordUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<Enumerable<MedicalRecordCreateWithoutPetInput>, Enumerable<MedicalRecordUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<MedicalRecordCreateOrConnectWithoutPetInput>
    createMany?: MedicalRecordCreateManyPetInputEnvelope
    connect?: Enumerable<MedicalRecordWhereUniqueInput>
  }

  export type EnumPetTypeFieldUpdateOperationsInput = {
    set?: PetType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: Gender | null
  }

  export type NullableEnumPlayGroupTypeFieldUpdateOperationsInput = {
    set?: PlayGroupType | null
  }

  export type CustomerUpdateOneRequiredWithoutPetsNestedInput = {
    create?: XOR<CustomerCreateWithoutPetsInput, CustomerUncheckedCreateWithoutPetsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPetsInput
    upsert?: CustomerUpsertWithoutPetsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutPetsInput, CustomerUncheckedUpdateWithoutPetsInput>
  }

  export type ReservationUpdateManyWithoutPetNestedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutPetInput>, Enumerable<ReservationUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutPetInput>
    upsert?: Enumerable<ReservationUpsertWithWhereUniqueWithoutPetInput>
    createMany?: ReservationCreateManyPetInputEnvelope
    set?: Enumerable<ReservationWhereUniqueInput>
    disconnect?: Enumerable<ReservationWhereUniqueInput>
    delete?: Enumerable<ReservationWhereUniqueInput>
    connect?: Enumerable<ReservationWhereUniqueInput>
    update?: Enumerable<ReservationUpdateWithWhereUniqueWithoutPetInput>
    updateMany?: Enumerable<ReservationUpdateManyWithWhereWithoutPetInput>
    deleteMany?: Enumerable<ReservationScalarWhereInput>
  }

  export type CheckInUpdateManyWithoutPetNestedInput = {
    create?: XOR<Enumerable<CheckInCreateWithoutPetInput>, Enumerable<CheckInUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<CheckInCreateOrConnectWithoutPetInput>
    upsert?: Enumerable<CheckInUpsertWithWhereUniqueWithoutPetInput>
    createMany?: CheckInCreateManyPetInputEnvelope
    set?: Enumerable<CheckInWhereUniqueInput>
    disconnect?: Enumerable<CheckInWhereUniqueInput>
    delete?: Enumerable<CheckInWhereUniqueInput>
    connect?: Enumerable<CheckInWhereUniqueInput>
    update?: Enumerable<CheckInUpdateWithWhereUniqueWithoutPetInput>
    updateMany?: Enumerable<CheckInUpdateManyWithWhereWithoutPetInput>
    deleteMany?: Enumerable<CheckInScalarWhereInput>
  }

  export type MedicalRecordUpdateManyWithoutPetNestedInput = {
    create?: XOR<Enumerable<MedicalRecordCreateWithoutPetInput>, Enumerable<MedicalRecordUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<MedicalRecordCreateOrConnectWithoutPetInput>
    upsert?: Enumerable<MedicalRecordUpsertWithWhereUniqueWithoutPetInput>
    createMany?: MedicalRecordCreateManyPetInputEnvelope
    set?: Enumerable<MedicalRecordWhereUniqueInput>
    disconnect?: Enumerable<MedicalRecordWhereUniqueInput>
    delete?: Enumerable<MedicalRecordWhereUniqueInput>
    connect?: Enumerable<MedicalRecordWhereUniqueInput>
    update?: Enumerable<MedicalRecordUpdateWithWhereUniqueWithoutPetInput>
    updateMany?: Enumerable<MedicalRecordUpdateManyWithWhereWithoutPetInput>
    deleteMany?: Enumerable<MedicalRecordScalarWhereInput>
  }

  export type ReservationUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutPetInput>, Enumerable<ReservationUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutPetInput>
    upsert?: Enumerable<ReservationUpsertWithWhereUniqueWithoutPetInput>
    createMany?: ReservationCreateManyPetInputEnvelope
    set?: Enumerable<ReservationWhereUniqueInput>
    disconnect?: Enumerable<ReservationWhereUniqueInput>
    delete?: Enumerable<ReservationWhereUniqueInput>
    connect?: Enumerable<ReservationWhereUniqueInput>
    update?: Enumerable<ReservationUpdateWithWhereUniqueWithoutPetInput>
    updateMany?: Enumerable<ReservationUpdateManyWithWhereWithoutPetInput>
    deleteMany?: Enumerable<ReservationScalarWhereInput>
  }

  export type CheckInUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<Enumerable<CheckInCreateWithoutPetInput>, Enumerable<CheckInUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<CheckInCreateOrConnectWithoutPetInput>
    upsert?: Enumerable<CheckInUpsertWithWhereUniqueWithoutPetInput>
    createMany?: CheckInCreateManyPetInputEnvelope
    set?: Enumerable<CheckInWhereUniqueInput>
    disconnect?: Enumerable<CheckInWhereUniqueInput>
    delete?: Enumerable<CheckInWhereUniqueInput>
    connect?: Enumerable<CheckInWhereUniqueInput>
    update?: Enumerable<CheckInUpdateWithWhereUniqueWithoutPetInput>
    updateMany?: Enumerable<CheckInUpdateManyWithWhereWithoutPetInput>
    deleteMany?: Enumerable<CheckInScalarWhereInput>
  }

  export type MedicalRecordUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<Enumerable<MedicalRecordCreateWithoutPetInput>, Enumerable<MedicalRecordUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<MedicalRecordCreateOrConnectWithoutPetInput>
    upsert?: Enumerable<MedicalRecordUpsertWithWhereUniqueWithoutPetInput>
    createMany?: MedicalRecordCreateManyPetInputEnvelope
    set?: Enumerable<MedicalRecordWhereUniqueInput>
    disconnect?: Enumerable<MedicalRecordWhereUniqueInput>
    delete?: Enumerable<MedicalRecordWhereUniqueInput>
    connect?: Enumerable<MedicalRecordWhereUniqueInput>
    update?: Enumerable<MedicalRecordUpdateWithWhereUniqueWithoutPetInput>
    updateMany?: Enumerable<MedicalRecordUpdateManyWithWhereWithoutPetInput>
    deleteMany?: Enumerable<MedicalRecordScalarWhereInput>
  }

  export type CustomerCreateNestedOneWithoutReservationsInput = {
    create?: XOR<CustomerCreateWithoutReservationsInput, CustomerUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReservationsInput
    connect?: CustomerWhereUniqueInput
  }

  export type PetCreateNestedOneWithoutReservationsInput = {
    create?: XOR<PetCreateWithoutReservationsInput, PetUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PetCreateOrConnectWithoutReservationsInput
    connect?: PetWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutReservationsInput = {
    create?: XOR<ServiceCreateWithoutReservationsInput, ServiceUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutReservationsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutReservationsInput = {
    create?: XOR<ResourceCreateWithoutReservationsInput, ResourceUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutReservationsInput
    connect?: ResourceWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutAssignedReservationsInput = {
    create?: XOR<StaffCreateWithoutAssignedReservationsInput, StaffUncheckedCreateWithoutAssignedReservationsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutAssignedReservationsInput
    connect?: StaffWhereUniqueInput
  }

  export type ReservationAddOnCreateNestedManyWithoutReservationInput = {
    create?: XOR<Enumerable<ReservationAddOnCreateWithoutReservationInput>, Enumerable<ReservationAddOnUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<ReservationAddOnCreateOrConnectWithoutReservationInput>
    createMany?: ReservationAddOnCreateManyReservationInputEnvelope
    connect?: Enumerable<ReservationAddOnWhereUniqueInput>
  }

  export type InvoiceCreateNestedOneWithoutReservationInput = {
    create?: XOR<InvoiceCreateWithoutReservationInput, InvoiceUncheckedCreateWithoutReservationInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutReservationInput
    connect?: InvoiceWhereUniqueInput
  }

  export type CheckInCreateNestedManyWithoutReservationInput = {
    create?: XOR<Enumerable<CheckInCreateWithoutReservationInput>, Enumerable<CheckInUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<CheckInCreateOrConnectWithoutReservationInput>
    createMany?: CheckInCreateManyReservationInputEnvelope
    connect?: Enumerable<CheckInWhereUniqueInput>
  }

  export type ReservationAddOnUncheckedCreateNestedManyWithoutReservationInput = {
    create?: XOR<Enumerable<ReservationAddOnCreateWithoutReservationInput>, Enumerable<ReservationAddOnUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<ReservationAddOnCreateOrConnectWithoutReservationInput>
    createMany?: ReservationAddOnCreateManyReservationInputEnvelope
    connect?: Enumerable<ReservationAddOnWhereUniqueInput>
  }

  export type InvoiceUncheckedCreateNestedOneWithoutReservationInput = {
    create?: XOR<InvoiceCreateWithoutReservationInput, InvoiceUncheckedCreateWithoutReservationInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutReservationInput
    connect?: InvoiceWhereUniqueInput
  }

  export type CheckInUncheckedCreateNestedManyWithoutReservationInput = {
    create?: XOR<Enumerable<CheckInCreateWithoutReservationInput>, Enumerable<CheckInUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<CheckInCreateOrConnectWithoutReservationInput>
    createMany?: CheckInCreateManyReservationInputEnvelope
    connect?: Enumerable<CheckInWhereUniqueInput>
  }

  export type EnumReservationStatusFieldUpdateOperationsInput = {
    set?: ReservationStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<CustomerCreateWithoutReservationsInput, CustomerUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReservationsInput
    upsert?: CustomerUpsertWithoutReservationsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutReservationsInput, CustomerUncheckedUpdateWithoutReservationsInput>
  }

  export type PetUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<PetCreateWithoutReservationsInput, PetUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PetCreateOrConnectWithoutReservationsInput
    upsert?: PetUpsertWithoutReservationsInput
    connect?: PetWhereUniqueInput
    update?: XOR<PetUpdateWithoutReservationsInput, PetUncheckedUpdateWithoutReservationsInput>
  }

  export type ServiceUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<ServiceCreateWithoutReservationsInput, ServiceUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutReservationsInput
    upsert?: ServiceUpsertWithoutReservationsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<ServiceUpdateWithoutReservationsInput, ServiceUncheckedUpdateWithoutReservationsInput>
  }

  export type ResourceUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<ResourceCreateWithoutReservationsInput, ResourceUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutReservationsInput
    upsert?: ResourceUpsertWithoutReservationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ResourceWhereUniqueInput
    update?: XOR<ResourceUpdateWithoutReservationsInput, ResourceUncheckedUpdateWithoutReservationsInput>
  }

  export type StaffUpdateOneWithoutAssignedReservationsNestedInput = {
    create?: XOR<StaffCreateWithoutAssignedReservationsInput, StaffUncheckedCreateWithoutAssignedReservationsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutAssignedReservationsInput
    upsert?: StaffUpsertWithoutAssignedReservationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<StaffUpdateWithoutAssignedReservationsInput, StaffUncheckedUpdateWithoutAssignedReservationsInput>
  }

  export type ReservationAddOnUpdateManyWithoutReservationNestedInput = {
    create?: XOR<Enumerable<ReservationAddOnCreateWithoutReservationInput>, Enumerable<ReservationAddOnUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<ReservationAddOnCreateOrConnectWithoutReservationInput>
    upsert?: Enumerable<ReservationAddOnUpsertWithWhereUniqueWithoutReservationInput>
    createMany?: ReservationAddOnCreateManyReservationInputEnvelope
    set?: Enumerable<ReservationAddOnWhereUniqueInput>
    disconnect?: Enumerable<ReservationAddOnWhereUniqueInput>
    delete?: Enumerable<ReservationAddOnWhereUniqueInput>
    connect?: Enumerable<ReservationAddOnWhereUniqueInput>
    update?: Enumerable<ReservationAddOnUpdateWithWhereUniqueWithoutReservationInput>
    updateMany?: Enumerable<ReservationAddOnUpdateManyWithWhereWithoutReservationInput>
    deleteMany?: Enumerable<ReservationAddOnScalarWhereInput>
  }

  export type InvoiceUpdateOneWithoutReservationNestedInput = {
    create?: XOR<InvoiceCreateWithoutReservationInput, InvoiceUncheckedCreateWithoutReservationInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutReservationInput
    upsert?: InvoiceUpsertWithoutReservationInput
    disconnect?: boolean
    delete?: boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<InvoiceUpdateWithoutReservationInput, InvoiceUncheckedUpdateWithoutReservationInput>
  }

  export type CheckInUpdateManyWithoutReservationNestedInput = {
    create?: XOR<Enumerable<CheckInCreateWithoutReservationInput>, Enumerable<CheckInUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<CheckInCreateOrConnectWithoutReservationInput>
    upsert?: Enumerable<CheckInUpsertWithWhereUniqueWithoutReservationInput>
    createMany?: CheckInCreateManyReservationInputEnvelope
    set?: Enumerable<CheckInWhereUniqueInput>
    disconnect?: Enumerable<CheckInWhereUniqueInput>
    delete?: Enumerable<CheckInWhereUniqueInput>
    connect?: Enumerable<CheckInWhereUniqueInput>
    update?: Enumerable<CheckInUpdateWithWhereUniqueWithoutReservationInput>
    updateMany?: Enumerable<CheckInUpdateManyWithWhereWithoutReservationInput>
    deleteMany?: Enumerable<CheckInScalarWhereInput>
  }

  export type ReservationAddOnUncheckedUpdateManyWithoutReservationNestedInput = {
    create?: XOR<Enumerable<ReservationAddOnCreateWithoutReservationInput>, Enumerable<ReservationAddOnUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<ReservationAddOnCreateOrConnectWithoutReservationInput>
    upsert?: Enumerable<ReservationAddOnUpsertWithWhereUniqueWithoutReservationInput>
    createMany?: ReservationAddOnCreateManyReservationInputEnvelope
    set?: Enumerable<ReservationAddOnWhereUniqueInput>
    disconnect?: Enumerable<ReservationAddOnWhereUniqueInput>
    delete?: Enumerable<ReservationAddOnWhereUniqueInput>
    connect?: Enumerable<ReservationAddOnWhereUniqueInput>
    update?: Enumerable<ReservationAddOnUpdateWithWhereUniqueWithoutReservationInput>
    updateMany?: Enumerable<ReservationAddOnUpdateManyWithWhereWithoutReservationInput>
    deleteMany?: Enumerable<ReservationAddOnScalarWhereInput>
  }

  export type InvoiceUncheckedUpdateOneWithoutReservationNestedInput = {
    create?: XOR<InvoiceCreateWithoutReservationInput, InvoiceUncheckedCreateWithoutReservationInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutReservationInput
    upsert?: InvoiceUpsertWithoutReservationInput
    disconnect?: boolean
    delete?: boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<InvoiceUpdateWithoutReservationInput, InvoiceUncheckedUpdateWithoutReservationInput>
  }

  export type CheckInUncheckedUpdateManyWithoutReservationNestedInput = {
    create?: XOR<Enumerable<CheckInCreateWithoutReservationInput>, Enumerable<CheckInUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<CheckInCreateOrConnectWithoutReservationInput>
    upsert?: Enumerable<CheckInUpsertWithWhereUniqueWithoutReservationInput>
    createMany?: CheckInCreateManyReservationInputEnvelope
    set?: Enumerable<CheckInWhereUniqueInput>
    disconnect?: Enumerable<CheckInWhereUniqueInput>
    delete?: Enumerable<CheckInWhereUniqueInput>
    connect?: Enumerable<CheckInWhereUniqueInput>
    update?: Enumerable<CheckInUpdateWithWhereUniqueWithoutReservationInput>
    updateMany?: Enumerable<CheckInUpdateManyWithWhereWithoutReservationInput>
    deleteMany?: Enumerable<CheckInScalarWhereInput>
  }

  export type ReservationCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutServiceInput>, Enumerable<ReservationUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutServiceInput>
    createMany?: ReservationCreateManyServiceInputEnvelope
    connect?: Enumerable<ReservationWhereUniqueInput>
  }

  export type AddOnServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<AddOnServiceCreateWithoutServiceInput>, Enumerable<AddOnServiceUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<AddOnServiceCreateOrConnectWithoutServiceInput>
    createMany?: AddOnServiceCreateManyServiceInputEnvelope
    connect?: Enumerable<AddOnServiceWhereUniqueInput>
  }

  export type ReservationUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutServiceInput>, Enumerable<ReservationUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutServiceInput>
    createMany?: ReservationCreateManyServiceInputEnvelope
    connect?: Enumerable<ReservationWhereUniqueInput>
  }

  export type AddOnServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<Enumerable<AddOnServiceCreateWithoutServiceInput>, Enumerable<AddOnServiceUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<AddOnServiceCreateOrConnectWithoutServiceInput>
    createMany?: AddOnServiceCreateManyServiceInputEnvelope
    connect?: Enumerable<AddOnServiceWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumServiceCategoryFieldUpdateOperationsInput = {
    set?: ServiceCategory
  }

  export type ReservationUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutServiceInput>, Enumerable<ReservationUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ReservationUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ReservationCreateManyServiceInputEnvelope
    set?: Enumerable<ReservationWhereUniqueInput>
    disconnect?: Enumerable<ReservationWhereUniqueInput>
    delete?: Enumerable<ReservationWhereUniqueInput>
    connect?: Enumerable<ReservationWhereUniqueInput>
    update?: Enumerable<ReservationUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ReservationUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ReservationScalarWhereInput>
  }

  export type AddOnServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<AddOnServiceCreateWithoutServiceInput>, Enumerable<AddOnServiceUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<AddOnServiceCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<AddOnServiceUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: AddOnServiceCreateManyServiceInputEnvelope
    set?: Enumerable<AddOnServiceWhereUniqueInput>
    disconnect?: Enumerable<AddOnServiceWhereUniqueInput>
    delete?: Enumerable<AddOnServiceWhereUniqueInput>
    connect?: Enumerable<AddOnServiceWhereUniqueInput>
    update?: Enumerable<AddOnServiceUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<AddOnServiceUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<AddOnServiceScalarWhereInput>
  }

  export type ReservationUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutServiceInput>, Enumerable<ReservationUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<ReservationUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: ReservationCreateManyServiceInputEnvelope
    set?: Enumerable<ReservationWhereUniqueInput>
    disconnect?: Enumerable<ReservationWhereUniqueInput>
    delete?: Enumerable<ReservationWhereUniqueInput>
    connect?: Enumerable<ReservationWhereUniqueInput>
    update?: Enumerable<ReservationUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<ReservationUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<ReservationScalarWhereInput>
  }

  export type AddOnServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<Enumerable<AddOnServiceCreateWithoutServiceInput>, Enumerable<AddOnServiceUncheckedCreateWithoutServiceInput>>
    connectOrCreate?: Enumerable<AddOnServiceCreateOrConnectWithoutServiceInput>
    upsert?: Enumerable<AddOnServiceUpsertWithWhereUniqueWithoutServiceInput>
    createMany?: AddOnServiceCreateManyServiceInputEnvelope
    set?: Enumerable<AddOnServiceWhereUniqueInput>
    disconnect?: Enumerable<AddOnServiceWhereUniqueInput>
    delete?: Enumerable<AddOnServiceWhereUniqueInput>
    connect?: Enumerable<AddOnServiceWhereUniqueInput>
    update?: Enumerable<AddOnServiceUpdateWithWhereUniqueWithoutServiceInput>
    updateMany?: Enumerable<AddOnServiceUpdateManyWithWhereWithoutServiceInput>
    deleteMany?: Enumerable<AddOnServiceScalarWhereInput>
  }

  export type ServiceCreateNestedOneWithoutAvailableAddOnsInput = {
    create?: XOR<ServiceCreateWithoutAvailableAddOnsInput, ServiceUncheckedCreateWithoutAvailableAddOnsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAvailableAddOnsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ReservationAddOnCreateNestedManyWithoutAddOnInput = {
    create?: XOR<Enumerable<ReservationAddOnCreateWithoutAddOnInput>, Enumerable<ReservationAddOnUncheckedCreateWithoutAddOnInput>>
    connectOrCreate?: Enumerable<ReservationAddOnCreateOrConnectWithoutAddOnInput>
    createMany?: ReservationAddOnCreateManyAddOnInputEnvelope
    connect?: Enumerable<ReservationAddOnWhereUniqueInput>
  }

  export type ReservationAddOnUncheckedCreateNestedManyWithoutAddOnInput = {
    create?: XOR<Enumerable<ReservationAddOnCreateWithoutAddOnInput>, Enumerable<ReservationAddOnUncheckedCreateWithoutAddOnInput>>
    connectOrCreate?: Enumerable<ReservationAddOnCreateOrConnectWithoutAddOnInput>
    createMany?: ReservationAddOnCreateManyAddOnInputEnvelope
    connect?: Enumerable<ReservationAddOnWhereUniqueInput>
  }

  export type ServiceUpdateOneRequiredWithoutAvailableAddOnsNestedInput = {
    create?: XOR<ServiceCreateWithoutAvailableAddOnsInput, ServiceUncheckedCreateWithoutAvailableAddOnsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAvailableAddOnsInput
    upsert?: ServiceUpsertWithoutAvailableAddOnsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<ServiceUpdateWithoutAvailableAddOnsInput, ServiceUncheckedUpdateWithoutAvailableAddOnsInput>
  }

  export type ReservationAddOnUpdateManyWithoutAddOnNestedInput = {
    create?: XOR<Enumerable<ReservationAddOnCreateWithoutAddOnInput>, Enumerable<ReservationAddOnUncheckedCreateWithoutAddOnInput>>
    connectOrCreate?: Enumerable<ReservationAddOnCreateOrConnectWithoutAddOnInput>
    upsert?: Enumerable<ReservationAddOnUpsertWithWhereUniqueWithoutAddOnInput>
    createMany?: ReservationAddOnCreateManyAddOnInputEnvelope
    set?: Enumerable<ReservationAddOnWhereUniqueInput>
    disconnect?: Enumerable<ReservationAddOnWhereUniqueInput>
    delete?: Enumerable<ReservationAddOnWhereUniqueInput>
    connect?: Enumerable<ReservationAddOnWhereUniqueInput>
    update?: Enumerable<ReservationAddOnUpdateWithWhereUniqueWithoutAddOnInput>
    updateMany?: Enumerable<ReservationAddOnUpdateManyWithWhereWithoutAddOnInput>
    deleteMany?: Enumerable<ReservationAddOnScalarWhereInput>
  }

  export type ReservationAddOnUncheckedUpdateManyWithoutAddOnNestedInput = {
    create?: XOR<Enumerable<ReservationAddOnCreateWithoutAddOnInput>, Enumerable<ReservationAddOnUncheckedCreateWithoutAddOnInput>>
    connectOrCreate?: Enumerable<ReservationAddOnCreateOrConnectWithoutAddOnInput>
    upsert?: Enumerable<ReservationAddOnUpsertWithWhereUniqueWithoutAddOnInput>
    createMany?: ReservationAddOnCreateManyAddOnInputEnvelope
    set?: Enumerable<ReservationAddOnWhereUniqueInput>
    disconnect?: Enumerable<ReservationAddOnWhereUniqueInput>
    delete?: Enumerable<ReservationAddOnWhereUniqueInput>
    connect?: Enumerable<ReservationAddOnWhereUniqueInput>
    update?: Enumerable<ReservationAddOnUpdateWithWhereUniqueWithoutAddOnInput>
    updateMany?: Enumerable<ReservationAddOnUpdateManyWithWhereWithoutAddOnInput>
    deleteMany?: Enumerable<ReservationAddOnScalarWhereInput>
  }

  export type ReservationCreateNestedOneWithoutAddOnServicesInput = {
    create?: XOR<ReservationCreateWithoutAddOnServicesInput, ReservationUncheckedCreateWithoutAddOnServicesInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutAddOnServicesInput
    connect?: ReservationWhereUniqueInput
  }

  export type AddOnServiceCreateNestedOneWithoutReservationAddOnsInput = {
    create?: XOR<AddOnServiceCreateWithoutReservationAddOnsInput, AddOnServiceUncheckedCreateWithoutReservationAddOnsInput>
    connectOrCreate?: AddOnServiceCreateOrConnectWithoutReservationAddOnsInput
    connect?: AddOnServiceWhereUniqueInput
  }

  export type ReservationUpdateOneRequiredWithoutAddOnServicesNestedInput = {
    create?: XOR<ReservationCreateWithoutAddOnServicesInput, ReservationUncheckedCreateWithoutAddOnServicesInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutAddOnServicesInput
    upsert?: ReservationUpsertWithoutAddOnServicesInput
    connect?: ReservationWhereUniqueInput
    update?: XOR<ReservationUpdateWithoutAddOnServicesInput, ReservationUncheckedUpdateWithoutAddOnServicesInput>
  }

  export type AddOnServiceUpdateOneRequiredWithoutReservationAddOnsNestedInput = {
    create?: XOR<AddOnServiceCreateWithoutReservationAddOnsInput, AddOnServiceUncheckedCreateWithoutReservationAddOnsInput>
    connectOrCreate?: AddOnServiceCreateOrConnectWithoutReservationAddOnsInput
    upsert?: AddOnServiceUpsertWithoutReservationAddOnsInput
    connect?: AddOnServiceWhereUniqueInput
    update?: XOR<AddOnServiceUpdateWithoutReservationAddOnsInput, AddOnServiceUncheckedUpdateWithoutReservationAddOnsInput>
  }

  export type ReservationCreateNestedManyWithoutResourceInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutResourceInput>, Enumerable<ReservationUncheckedCreateWithoutResourceInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutResourceInput>
    createMany?: ReservationCreateManyResourceInputEnvelope
    connect?: Enumerable<ReservationWhereUniqueInput>
  }

  export type ReservationUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutResourceInput>, Enumerable<ReservationUncheckedCreateWithoutResourceInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutResourceInput>
    createMany?: ReservationCreateManyResourceInputEnvelope
    connect?: Enumerable<ReservationWhereUniqueInput>
  }

  export type EnumResourceTypeFieldUpdateOperationsInput = {
    set?: ResourceType
  }

  export type ReservationUpdateManyWithoutResourceNestedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutResourceInput>, Enumerable<ReservationUncheckedCreateWithoutResourceInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutResourceInput>
    upsert?: Enumerable<ReservationUpsertWithWhereUniqueWithoutResourceInput>
    createMany?: ReservationCreateManyResourceInputEnvelope
    set?: Enumerable<ReservationWhereUniqueInput>
    disconnect?: Enumerable<ReservationWhereUniqueInput>
    delete?: Enumerable<ReservationWhereUniqueInput>
    connect?: Enumerable<ReservationWhereUniqueInput>
    update?: Enumerable<ReservationUpdateWithWhereUniqueWithoutResourceInput>
    updateMany?: Enumerable<ReservationUpdateManyWithWhereWithoutResourceInput>
    deleteMany?: Enumerable<ReservationScalarWhereInput>
  }

  export type ReservationUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutResourceInput>, Enumerable<ReservationUncheckedCreateWithoutResourceInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutResourceInput>
    upsert?: Enumerable<ReservationUpsertWithWhereUniqueWithoutResourceInput>
    createMany?: ReservationCreateManyResourceInputEnvelope
    set?: Enumerable<ReservationWhereUniqueInput>
    disconnect?: Enumerable<ReservationWhereUniqueInput>
    delete?: Enumerable<ReservationWhereUniqueInput>
    connect?: Enumerable<ReservationWhereUniqueInput>
    update?: Enumerable<ReservationUpdateWithWhereUniqueWithoutResourceInput>
    updateMany?: Enumerable<ReservationUpdateManyWithWhereWithoutResourceInput>
    deleteMany?: Enumerable<ReservationScalarWhereInput>
  }

  export type StaffCreatespecialtiesInput = {
    set: Enumerable<string>
  }

  export type ReservationCreateNestedManyWithoutStaffAssignedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutStaffAssignedInput>, Enumerable<ReservationUncheckedCreateWithoutStaffAssignedInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutStaffAssignedInput>
    createMany?: ReservationCreateManyStaffAssignedInputEnvelope
    connect?: Enumerable<ReservationWhereUniqueInput>
  }

  export type ReservationUncheckedCreateNestedManyWithoutStaffAssignedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutStaffAssignedInput>, Enumerable<ReservationUncheckedCreateWithoutStaffAssignedInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutStaffAssignedInput>
    createMany?: ReservationCreateManyStaffAssignedInputEnvelope
    connect?: Enumerable<ReservationWhereUniqueInput>
  }

  export type StaffUpdatespecialtiesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ReservationUpdateManyWithoutStaffAssignedNestedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutStaffAssignedInput>, Enumerable<ReservationUncheckedCreateWithoutStaffAssignedInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutStaffAssignedInput>
    upsert?: Enumerable<ReservationUpsertWithWhereUniqueWithoutStaffAssignedInput>
    createMany?: ReservationCreateManyStaffAssignedInputEnvelope
    set?: Enumerable<ReservationWhereUniqueInput>
    disconnect?: Enumerable<ReservationWhereUniqueInput>
    delete?: Enumerable<ReservationWhereUniqueInput>
    connect?: Enumerable<ReservationWhereUniqueInput>
    update?: Enumerable<ReservationUpdateWithWhereUniqueWithoutStaffAssignedInput>
    updateMany?: Enumerable<ReservationUpdateManyWithWhereWithoutStaffAssignedInput>
    deleteMany?: Enumerable<ReservationScalarWhereInput>
  }

  export type ReservationUncheckedUpdateManyWithoutStaffAssignedNestedInput = {
    create?: XOR<Enumerable<ReservationCreateWithoutStaffAssignedInput>, Enumerable<ReservationUncheckedCreateWithoutStaffAssignedInput>>
    connectOrCreate?: Enumerable<ReservationCreateOrConnectWithoutStaffAssignedInput>
    upsert?: Enumerable<ReservationUpsertWithWhereUniqueWithoutStaffAssignedInput>
    createMany?: ReservationCreateManyStaffAssignedInputEnvelope
    set?: Enumerable<ReservationWhereUniqueInput>
    disconnect?: Enumerable<ReservationWhereUniqueInput>
    delete?: Enumerable<ReservationWhereUniqueInput>
    connect?: Enumerable<ReservationWhereUniqueInput>
    update?: Enumerable<ReservationUpdateWithWhereUniqueWithoutStaffAssignedInput>
    updateMany?: Enumerable<ReservationUpdateManyWithWhereWithoutStaffAssignedInput>
    deleteMany?: Enumerable<ReservationScalarWhereInput>
  }

  export type CustomerCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type ReservationCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<ReservationCreateWithoutInvoiceInput, ReservationUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutInvoiceInput
    connect?: ReservationWhereUniqueInput
  }

  export type InvoiceLineItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<InvoiceLineItemCreateWithoutInvoiceInput>, Enumerable<InvoiceLineItemUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceLineItemCreateOrConnectWithoutInvoiceInput>
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    connect?: Enumerable<InvoiceLineItemWhereUniqueInput>
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutInvoiceInput>, Enumerable<PaymentUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutInvoiceInput>
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<InvoiceLineItemCreateWithoutInvoiceInput>, Enumerable<InvoiceLineItemUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceLineItemCreateOrConnectWithoutInvoiceInput>
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    connect?: Enumerable<InvoiceLineItemWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutInvoiceInput>, Enumerable<PaymentUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutInvoiceInput>
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: InvoiceStatus
  }

  export type CustomerUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    upsert?: CustomerUpsertWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type ReservationUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<ReservationCreateWithoutInvoiceInput, ReservationUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutInvoiceInput
    upsert?: ReservationUpsertWithoutInvoiceInput
    disconnect?: boolean
    delete?: boolean
    connect?: ReservationWhereUniqueInput
    update?: XOR<ReservationUpdateWithoutInvoiceInput, ReservationUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceLineItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<InvoiceLineItemCreateWithoutInvoiceInput>, Enumerable<InvoiceLineItemUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceLineItemCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    set?: Enumerable<InvoiceLineItemWhereUniqueInput>
    disconnect?: Enumerable<InvoiceLineItemWhereUniqueInput>
    delete?: Enumerable<InvoiceLineItemWhereUniqueInput>
    connect?: Enumerable<InvoiceLineItemWhereUniqueInput>
    update?: Enumerable<InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<InvoiceLineItemScalarWhereInput>
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutInvoiceInput>, Enumerable<PaymentUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<InvoiceLineItemCreateWithoutInvoiceInput>, Enumerable<InvoiceLineItemUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<InvoiceLineItemCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: InvoiceLineItemCreateManyInvoiceInputEnvelope
    set?: Enumerable<InvoiceLineItemWhereUniqueInput>
    disconnect?: Enumerable<InvoiceLineItemWhereUniqueInput>
    delete?: Enumerable<InvoiceLineItemWhereUniqueInput>
    connect?: Enumerable<InvoiceLineItemWhereUniqueInput>
    update?: Enumerable<InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<InvoiceLineItemScalarWhereInput>
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutInvoiceInput>, Enumerable<PaymentUncheckedCreateWithoutInvoiceInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutInvoiceInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutInvoiceInput>
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    connect?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutInvoiceInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutInvoiceInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type InvoiceCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLineItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutLineItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLineItemsInput
    upsert?: InvoiceUpsertWithoutLineItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<InvoiceUpdateWithoutLineItemsInput, InvoiceUncheckedUpdateWithoutLineItemsInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: PaymentStatus
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type CustomerUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    upsert?: CustomerUpsertWithoutPaymentsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
  }

  export type DocumentCreatetagsInput = {
    set: Enumerable<string>
  }

  export type CustomerCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<CustomerCreateWithoutDocumentsInput, CustomerUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDocumentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type DocumentUpdatetagsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type CustomerUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<CustomerCreateWithoutDocumentsInput, CustomerUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDocumentsInput
    upsert?: CustomerUpsertWithoutDocumentsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutDocumentsInput, CustomerUncheckedUpdateWithoutDocumentsInput>
  }

  export type CustomerCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CustomerCreateWithoutNotificationsInput, CustomerUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutNotificationsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<CustomerCreateWithoutNotificationsInput, CustomerUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutNotificationsInput
    upsert?: CustomerUpsertWithoutNotificationsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutNotificationsInput, CustomerUncheckedUpdateWithoutNotificationsInput>
  }

  export type PetCreateNestedOneWithoutCheckInsInput = {
    create?: XOR<PetCreateWithoutCheckInsInput, PetUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: PetCreateOrConnectWithoutCheckInsInput
    connect?: PetWhereUniqueInput
  }

  export type ReservationCreateNestedOneWithoutCheckInsInput = {
    create?: XOR<ReservationCreateWithoutCheckInsInput, ReservationUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutCheckInsInput
    connect?: ReservationWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutCheckInInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutCheckInInput>, Enumerable<ActivityUncheckedCreateWithoutCheckInInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutCheckInInput>
    createMany?: ActivityCreateManyCheckInInputEnvelope
    connect?: Enumerable<ActivityWhereUniqueInput>
  }

  export type ActivityUncheckedCreateNestedManyWithoutCheckInInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutCheckInInput>, Enumerable<ActivityUncheckedCreateWithoutCheckInInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutCheckInInput>
    createMany?: ActivityCreateManyCheckInInputEnvelope
    connect?: Enumerable<ActivityWhereUniqueInput>
  }

  export type PetUpdateOneRequiredWithoutCheckInsNestedInput = {
    create?: XOR<PetCreateWithoutCheckInsInput, PetUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: PetCreateOrConnectWithoutCheckInsInput
    upsert?: PetUpsertWithoutCheckInsInput
    connect?: PetWhereUniqueInput
    update?: XOR<PetUpdateWithoutCheckInsInput, PetUncheckedUpdateWithoutCheckInsInput>
  }

  export type ReservationUpdateOneWithoutCheckInsNestedInput = {
    create?: XOR<ReservationCreateWithoutCheckInsInput, ReservationUncheckedCreateWithoutCheckInsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutCheckInsInput
    upsert?: ReservationUpsertWithoutCheckInsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ReservationWhereUniqueInput
    update?: XOR<ReservationUpdateWithoutCheckInsInput, ReservationUncheckedUpdateWithoutCheckInsInput>
  }

  export type ActivityUpdateManyWithoutCheckInNestedInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutCheckInInput>, Enumerable<ActivityUncheckedCreateWithoutCheckInInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutCheckInInput>
    upsert?: Enumerable<ActivityUpsertWithWhereUniqueWithoutCheckInInput>
    createMany?: ActivityCreateManyCheckInInputEnvelope
    set?: Enumerable<ActivityWhereUniqueInput>
    disconnect?: Enumerable<ActivityWhereUniqueInput>
    delete?: Enumerable<ActivityWhereUniqueInput>
    connect?: Enumerable<ActivityWhereUniqueInput>
    update?: Enumerable<ActivityUpdateWithWhereUniqueWithoutCheckInInput>
    updateMany?: Enumerable<ActivityUpdateManyWithWhereWithoutCheckInInput>
    deleteMany?: Enumerable<ActivityScalarWhereInput>
  }

  export type ActivityUncheckedUpdateManyWithoutCheckInNestedInput = {
    create?: XOR<Enumerable<ActivityCreateWithoutCheckInInput>, Enumerable<ActivityUncheckedCreateWithoutCheckInInput>>
    connectOrCreate?: Enumerable<ActivityCreateOrConnectWithoutCheckInInput>
    upsert?: Enumerable<ActivityUpsertWithWhereUniqueWithoutCheckInInput>
    createMany?: ActivityCreateManyCheckInInputEnvelope
    set?: Enumerable<ActivityWhereUniqueInput>
    disconnect?: Enumerable<ActivityWhereUniqueInput>
    delete?: Enumerable<ActivityWhereUniqueInput>
    connect?: Enumerable<ActivityWhereUniqueInput>
    update?: Enumerable<ActivityUpdateWithWhereUniqueWithoutCheckInInput>
    updateMany?: Enumerable<ActivityUpdateManyWithWhereWithoutCheckInInput>
    deleteMany?: Enumerable<ActivityScalarWhereInput>
  }

  export type CheckInCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<CheckInCreateWithoutActivitiesInput, CheckInUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CheckInCreateOrConnectWithoutActivitiesInput
    connect?: CheckInWhereUniqueInput
  }

  export type CheckInUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<CheckInCreateWithoutActivitiesInput, CheckInUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CheckInCreateOrConnectWithoutActivitiesInput
    upsert?: CheckInUpsertWithoutActivitiesInput
    connect?: CheckInWhereUniqueInput
    update?: XOR<CheckInUpdateWithoutActivitiesInput, CheckInUncheckedUpdateWithoutActivitiesInput>
  }

  export type PetCreateNestedOneWithoutMedicalRecordsInput = {
    create?: XOR<PetCreateWithoutMedicalRecordsInput, PetUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: PetCreateOrConnectWithoutMedicalRecordsInput
    connect?: PetWhereUniqueInput
  }

  export type PetUpdateOneRequiredWithoutMedicalRecordsNestedInput = {
    create?: XOR<PetCreateWithoutMedicalRecordsInput, PetUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: PetCreateOrConnectWithoutMedicalRecordsInput
    upsert?: PetUpsertWithoutMedicalRecordsInput
    connect?: PetWhereUniqueInput
    update?: XOR<PetUpdateWithoutMedicalRecordsInput, PetUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumContactMethodFilter = {
    equals?: ContactMethod
    in?: Enumerable<ContactMethod>
    notIn?: Enumerable<ContactMethod>
    not?: NestedEnumContactMethodFilter | ContactMethod
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumContactMethodWithAggregatesFilter = {
    equals?: ContactMethod
    in?: Enumerable<ContactMethod>
    notIn?: Enumerable<ContactMethod>
    not?: NestedEnumContactMethodWithAggregatesFilter | ContactMethod
    _count?: NestedIntFilter
    _min?: NestedEnumContactMethodFilter
    _max?: NestedEnumContactMethodFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumPetTypeFilter = {
    equals?: PetType
    in?: Enumerable<PetType>
    notIn?: Enumerable<PetType>
    not?: NestedEnumPetTypeFilter | PetType
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumGenderNullableFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableFilter | Gender | null
  }

  export type NestedEnumPlayGroupTypeNullableFilter = {
    equals?: PlayGroupType | null
    in?: Enumerable<PlayGroupType> | null
    notIn?: Enumerable<PlayGroupType> | null
    not?: NestedEnumPlayGroupTypeNullableFilter | PlayGroupType | null
  }

  export type NestedEnumPetTypeWithAggregatesFilter = {
    equals?: PetType
    in?: Enumerable<PetType>
    notIn?: Enumerable<PetType>
    not?: NestedEnumPetTypeWithAggregatesFilter | PetType
    _count?: NestedIntFilter
    _min?: NestedEnumPetTypeFilter
    _max?: NestedEnumPetTypeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedEnumGenderNullableWithAggregatesFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter | Gender | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderNullableFilter
    _max?: NestedEnumGenderNullableFilter
  }

  export type NestedEnumPlayGroupTypeNullableWithAggregatesFilter = {
    equals?: PlayGroupType | null
    in?: Enumerable<PlayGroupType> | null
    notIn?: Enumerable<PlayGroupType> | null
    not?: NestedEnumPlayGroupTypeNullableWithAggregatesFilter | PlayGroupType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumPlayGroupTypeNullableFilter
    _max?: NestedEnumPlayGroupTypeNullableFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedEnumReservationStatusFilter = {
    equals?: ReservationStatus
    in?: Enumerable<ReservationStatus>
    notIn?: Enumerable<ReservationStatus>
    not?: NestedEnumReservationStatusFilter | ReservationStatus
  }

  export type NestedEnumReservationStatusWithAggregatesFilter = {
    equals?: ReservationStatus
    in?: Enumerable<ReservationStatus>
    notIn?: Enumerable<ReservationStatus>
    not?: NestedEnumReservationStatusWithAggregatesFilter | ReservationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumReservationStatusFilter
    _max?: NestedEnumReservationStatusFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumServiceCategoryFilter = {
    equals?: ServiceCategory
    in?: Enumerable<ServiceCategory>
    notIn?: Enumerable<ServiceCategory>
    not?: NestedEnumServiceCategoryFilter | ServiceCategory
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedEnumServiceCategoryWithAggregatesFilter = {
    equals?: ServiceCategory
    in?: Enumerable<ServiceCategory>
    notIn?: Enumerable<ServiceCategory>
    not?: NestedEnumServiceCategoryWithAggregatesFilter | ServiceCategory
    _count?: NestedIntFilter
    _min?: NestedEnumServiceCategoryFilter
    _max?: NestedEnumServiceCategoryFilter
  }

  export type NestedEnumResourceTypeFilter = {
    equals?: ResourceType
    in?: Enumerable<ResourceType>
    notIn?: Enumerable<ResourceType>
    not?: NestedEnumResourceTypeFilter | ResourceType
  }

  export type NestedEnumResourceTypeWithAggregatesFilter = {
    equals?: ResourceType
    in?: Enumerable<ResourceType>
    notIn?: Enumerable<ResourceType>
    not?: NestedEnumResourceTypeWithAggregatesFilter | ResourceType
    _count?: NestedIntFilter
    _min?: NestedEnumResourceTypeFilter
    _max?: NestedEnumResourceTypeFilter
  }

  export type NestedEnumInvoiceStatusFilter = {
    equals?: InvoiceStatus
    in?: Enumerable<InvoiceStatus>
    notIn?: Enumerable<InvoiceStatus>
    not?: NestedEnumInvoiceStatusFilter | InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter = {
    equals?: InvoiceStatus
    in?: Enumerable<InvoiceStatus>
    notIn?: Enumerable<InvoiceStatus>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter | InvoiceStatus
    _count?: NestedIntFilter
    _min?: NestedEnumInvoiceStatusFilter
    _max?: NestedEnumInvoiceStatusFilter
  }

  export type NestedEnumPaymentMethodFilter = {
    equals?: PaymentMethod
    in?: Enumerable<PaymentMethod>
    notIn?: Enumerable<PaymentMethod>
    not?: NestedEnumPaymentMethodFilter | PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter = {
    equals?: PaymentStatus
    in?: Enumerable<PaymentStatus>
    notIn?: Enumerable<PaymentStatus>
    not?: NestedEnumPaymentStatusFilter | PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter = {
    equals?: PaymentMethod
    in?: Enumerable<PaymentMethod>
    notIn?: Enumerable<PaymentMethod>
    not?: NestedEnumPaymentMethodWithAggregatesFilter | PaymentMethod
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentMethodFilter
    _max?: NestedEnumPaymentMethodFilter
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter = {
    equals?: PaymentStatus
    in?: Enumerable<PaymentStatus>
    notIn?: Enumerable<PaymentStatus>
    not?: NestedEnumPaymentStatusWithAggregatesFilter | PaymentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumPaymentStatusFilter
    _max?: NestedEnumPaymentStatusFilter
  }

  export type PetCreateWithoutOwnerInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutPetInput
    checkIns?: CheckInCreateNestedManyWithoutPetInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutPetInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutPetInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutOwnerInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutOwnerInput, PetUncheckedCreateWithoutOwnerInput>
  }

  export type PetCreateManyOwnerInputEnvelope = {
    data: Enumerable<PetCreateManyOwnerInput>
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutCustomerInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pet: PetCreateNestedOneWithoutReservationsInput
    service: ServiceCreateNestedOneWithoutReservationsInput
    resource?: ResourceCreateNestedOneWithoutReservationsInput
    staffAssigned?: StaffCreateNestedOneWithoutAssignedReservationsInput
    addOnServices?: ReservationAddOnCreateNestedManyWithoutReservationInput
    invoice?: InvoiceCreateNestedOneWithoutReservationInput
    checkIns?: CheckInCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutCustomerInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    petId: string
    serviceId: string
    resourceId?: string | null
    staffAssignedId?: string | null
    addOnServices?: ReservationAddOnUncheckedCreateNestedManyWithoutReservationInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutReservationInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutCustomerInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutCustomerInput, ReservationUncheckedCreateWithoutCustomerInput>
  }

  export type ReservationCreateManyCustomerInputEnvelope = {
    data: Enumerable<ReservationCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCustomerInput = {
    id?: string
    amount: number
    method: PaymentMethod
    status?: PaymentStatus
    transactionId?: string | null
    paymentDate?: Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: number
    refundReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCustomerInput = {
    id?: string
    invoiceId: string
    amount: number
    method: PaymentMethod
    status?: PaymentStatus
    transactionId?: string | null
    paymentDate?: Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: number
    refundReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentCreateManyCustomerInputEnvelope = {
    data: Enumerable<PaymentCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCustomerInput = {
    id?: string
    invoiceNumber: string
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservation?: ReservationCreateNestedOneWithoutInvoiceInput
    lineItems?: InvoiceLineItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    invoiceNumber: string
    reservationId?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceCreateManyCustomerInputEnvelope = {
    data: Enumerable<InvoiceCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutCustomerInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    tags?: DocumentCreatetagsInput | Enumerable<string>
    uploaded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutCustomerInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    tags?: DocumentCreatetagsInput | Enumerable<string>
    uploaded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutCustomerInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCustomerInput, DocumentUncheckedCreateWithoutCustomerInput>
  }

  export type DocumentCreateManyCustomerInputEnvelope = {
    data: Enumerable<DocumentCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutCustomerInput = {
    id?: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    marketingEmails?: boolean
    appointmentReminders?: boolean
    checkinNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutCustomerInput = {
    id?: string
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    marketingEmails?: boolean
    appointmentReminders?: boolean
    checkinNotifications?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutCustomerInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutCustomerInput, NotificationPreferenceUncheckedCreateWithoutCustomerInput>
  }

  export type PetUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PetWhereUniqueInput
    update: XOR<PetUpdateWithoutOwnerInput, PetUncheckedUpdateWithoutOwnerInput>
    create: XOR<PetCreateWithoutOwnerInput, PetUncheckedCreateWithoutOwnerInput>
  }

  export type PetUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PetWhereUniqueInput
    data: XOR<PetUpdateWithoutOwnerInput, PetUncheckedUpdateWithoutOwnerInput>
  }

  export type PetUpdateManyWithWhereWithoutOwnerInput = {
    where: PetScalarWhereInput
    data: XOR<PetUpdateManyMutationInput, PetUncheckedUpdateManyWithoutPetsInput>
  }

  export type PetScalarWhereInput = {
    AND?: Enumerable<PetScalarWhereInput>
    OR?: Enumerable<PetScalarWhereInput>
    NOT?: Enumerable<PetScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: EnumPetTypeFilter | PetType
    breed?: StringNullableFilter | string | null
    color?: StringNullableFilter | string | null
    birthdate?: DateTimeNullableFilter | Date | string | null
    weight?: FloatNullableFilter | number | null
    gender?: EnumGenderNullableFilter | Gender | null
    isNeutered?: BoolFilter | boolean
    microchipNumber?: StringNullableFilter | string | null
    rabiesTagNumber?: StringNullableFilter | string | null
    specialNeeds?: StringNullableFilter | string | null
    foodNotes?: StringNullableFilter | string | null
    medicationNotes?: StringNullableFilter | string | null
    behaviorNotes?: StringNullableFilter | string | null
    allergies?: StringNullableFilter | string | null
    idealPlayGroup?: EnumPlayGroupTypeNullableFilter | PlayGroupType | null
    vaccinationStatus?: JsonNullableFilter
    vaccineExpirations?: JsonNullableFilter
    vetName?: StringNullableFilter | string | null
    vetPhone?: StringNullableFilter | string | null
    profilePhoto?: StringNullableFilter | string | null
    isActive?: BoolFilter | boolean
    lastCheckIn?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    customerId?: StringFilter | string
  }

  export type ReservationUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutCustomerInput, ReservationUncheckedUpdateWithoutCustomerInput>
    create: XOR<ReservationCreateWithoutCustomerInput, ReservationUncheckedCreateWithoutCustomerInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutCustomerInput, ReservationUncheckedUpdateWithoutCustomerInput>
  }

  export type ReservationUpdateManyWithWhereWithoutCustomerInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutReservationsInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: Enumerable<ReservationScalarWhereInput>
    OR?: Enumerable<ReservationScalarWhereInput>
    NOT?: Enumerable<ReservationScalarWhereInput>
    id?: StringFilter | string
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeFilter | Date | string
    status?: EnumReservationStatusFilter | ReservationStatus
    notes?: StringNullableFilter | string | null
    staffNotes?: StringNullableFilter | string | null
    checkInWindow?: IntNullableFilter | number | null
    isRecurring?: BoolFilter | boolean
    recurringPattern?: StringNullableFilter | string | null
    preChecked?: BoolFilter | boolean
    checkInDate?: DateTimeNullableFilter | Date | string | null
    checkOutDate?: DateTimeNullableFilter | Date | string | null
    earlyDropOff?: BoolFilter | boolean
    latePickup?: BoolFilter | boolean
    customPickupPerson?: StringNullableFilter | string | null
    confirmedBy?: StringNullableFilter | string | null
    cancelReason?: StringNullableFilter | string | null
    cancelDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    customerId?: StringFilter | string
    petId?: StringFilter | string
    serviceId?: StringFilter | string
    resourceId?: StringNullableFilter | string | null
    staffAssignedId?: StringNullableFilter | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCustomerInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentsInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: Enumerable<PaymentScalarWhereInput>
    OR?: Enumerable<PaymentScalarWhereInput>
    NOT?: Enumerable<PaymentScalarWhereInput>
    id?: StringFilter | string
    invoiceId?: StringFilter | string
    customerId?: StringFilter | string
    amount?: FloatFilter | number
    method?: EnumPaymentMethodFilter | PaymentMethod
    status?: EnumPaymentStatusFilter | PaymentStatus
    transactionId?: StringNullableFilter | string | null
    paymentDate?: DateTimeFilter | Date | string
    gatewayResponse?: JsonNullableFilter
    refundedAmount?: FloatFilter | number
    refundReason?: StringNullableFilter | string | null
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: Enumerable<InvoiceScalarWhereInput>
    OR?: Enumerable<InvoiceScalarWhereInput>
    NOT?: Enumerable<InvoiceScalarWhereInput>
    id?: StringFilter | string
    invoiceNumber?: StringFilter | string
    customerId?: StringFilter | string
    reservationId?: StringNullableFilter | string | null
    issueDate?: DateTimeFilter | Date | string
    dueDate?: DateTimeFilter | Date | string
    status?: EnumInvoiceStatusFilter | InvoiceStatus
    subtotal?: FloatFilter | number
    taxRate?: FloatFilter | number
    taxAmount?: FloatFilter | number
    discount?: FloatFilter | number
    total?: FloatFilter | number
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutCustomerInput, DocumentUncheckedUpdateWithoutCustomerInput>
    create: XOR<DocumentCreateWithoutCustomerInput, DocumentUncheckedCreateWithoutCustomerInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutCustomerInput, DocumentUncheckedUpdateWithoutCustomerInput>
  }

  export type DocumentUpdateManyWithWhereWithoutCustomerInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: Enumerable<DocumentScalarWhereInput>
    OR?: Enumerable<DocumentScalarWhereInput>
    NOT?: Enumerable<DocumentScalarWhereInput>
    id?: StringFilter | string
    customerId?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    fileUrl?: StringFilter | string
    fileType?: StringFilter | string
    fileSize?: IntFilter | number
    tags?: StringNullableListFilter
    uploaded?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type NotificationPreferenceUpsertWithoutCustomerInput = {
    update: XOR<NotificationPreferenceUpdateWithoutCustomerInput, NotificationPreferenceUncheckedUpdateWithoutCustomerInput>
    create: XOR<NotificationPreferenceCreateWithoutCustomerInput, NotificationPreferenceUncheckedCreateWithoutCustomerInput>
  }

  export type NotificationPreferenceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    appointmentReminders?: BoolFieldUpdateOperationsInput | boolean
    checkinNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    appointmentReminders?: BoolFieldUpdateOperationsInput | boolean
    checkinNotifications?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateWithoutPetsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    documents?: DocumentCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPetsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPetsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPetsInput, CustomerUncheckedCreateWithoutPetsInput>
  }

  export type ReservationCreateWithoutPetInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutReservationsInput
    service: ServiceCreateNestedOneWithoutReservationsInput
    resource?: ResourceCreateNestedOneWithoutReservationsInput
    staffAssigned?: StaffCreateNestedOneWithoutAssignedReservationsInput
    addOnServices?: ReservationAddOnCreateNestedManyWithoutReservationInput
    invoice?: InvoiceCreateNestedOneWithoutReservationInput
    checkIns?: CheckInCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutPetInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    serviceId: string
    resourceId?: string | null
    staffAssignedId?: string | null
    addOnServices?: ReservationAddOnUncheckedCreateNestedManyWithoutReservationInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutReservationInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutPetInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutPetInput, ReservationUncheckedCreateWithoutPetInput>
  }

  export type ReservationCreateManyPetInputEnvelope = {
    data: Enumerable<ReservationCreateManyPetInput>
    skipDuplicates?: boolean
  }

  export type CheckInCreateWithoutPetInput = {
    id?: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    checkInNotes?: string | null
    checkOutNotes?: string | null
    checkInBy?: string | null
    checkOutBy?: string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: string | null
    behaviorDuringStay?: string | null
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservation?: ReservationCreateNestedOneWithoutCheckInsInput
    activities?: ActivityCreateNestedManyWithoutCheckInInput
  }

  export type CheckInUncheckedCreateWithoutPetInput = {
    id?: string
    reservationId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    checkInNotes?: string | null
    checkOutNotes?: string | null
    checkInBy?: string | null
    checkOutBy?: string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: string | null
    behaviorDuringStay?: string | null
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutCheckInInput
  }

  export type CheckInCreateOrConnectWithoutPetInput = {
    where: CheckInWhereUniqueInput
    create: XOR<CheckInCreateWithoutPetInput, CheckInUncheckedCreateWithoutPetInput>
  }

  export type CheckInCreateManyPetInputEnvelope = {
    data: Enumerable<CheckInCreateManyPetInput>
    skipDuplicates?: boolean
  }

  export type MedicalRecordCreateWithoutPetInput = {
    id?: string
    recordType: string
    recordDate: Date | string
    expirationDate?: Date | string | null
    description: string
    veterinarian?: string | null
    fileUrl?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordUncheckedCreateWithoutPetInput = {
    id?: string
    recordType: string
    recordDate: Date | string
    expirationDate?: Date | string | null
    description: string
    veterinarian?: string | null
    fileUrl?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordCreateOrConnectWithoutPetInput = {
    where: MedicalRecordWhereUniqueInput
    create: XOR<MedicalRecordCreateWithoutPetInput, MedicalRecordUncheckedCreateWithoutPetInput>
  }

  export type MedicalRecordCreateManyPetInputEnvelope = {
    data: Enumerable<MedicalRecordCreateManyPetInput>
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutPetsInput = {
    update: XOR<CustomerUpdateWithoutPetsInput, CustomerUncheckedUpdateWithoutPetsInput>
    create: XOR<CustomerCreateWithoutPetsInput, CustomerUncheckedCreateWithoutPetsInput>
  }

  export type CustomerUpdateWithoutPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutCustomerNestedInput
  }

  export type ReservationUpsertWithWhereUniqueWithoutPetInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutPetInput, ReservationUncheckedUpdateWithoutPetInput>
    create: XOR<ReservationCreateWithoutPetInput, ReservationUncheckedCreateWithoutPetInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutPetInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutPetInput, ReservationUncheckedUpdateWithoutPetInput>
  }

  export type ReservationUpdateManyWithWhereWithoutPetInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutReservationsInput>
  }

  export type CheckInUpsertWithWhereUniqueWithoutPetInput = {
    where: CheckInWhereUniqueInput
    update: XOR<CheckInUpdateWithoutPetInput, CheckInUncheckedUpdateWithoutPetInput>
    create: XOR<CheckInCreateWithoutPetInput, CheckInUncheckedCreateWithoutPetInput>
  }

  export type CheckInUpdateWithWhereUniqueWithoutPetInput = {
    where: CheckInWhereUniqueInput
    data: XOR<CheckInUpdateWithoutPetInput, CheckInUncheckedUpdateWithoutPetInput>
  }

  export type CheckInUpdateManyWithWhereWithoutPetInput = {
    where: CheckInScalarWhereInput
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyWithoutCheckInsInput>
  }

  export type CheckInScalarWhereInput = {
    AND?: Enumerable<CheckInScalarWhereInput>
    OR?: Enumerable<CheckInScalarWhereInput>
    NOT?: Enumerable<CheckInScalarWhereInput>
    id?: StringFilter | string
    petId?: StringFilter | string
    reservationId?: StringNullableFilter | string | null
    checkInTime?: DateTimeFilter | Date | string
    checkOutTime?: DateTimeNullableFilter | Date | string | null
    checkInNotes?: StringNullableFilter | string | null
    checkOutNotes?: StringNullableFilter | string | null
    checkInBy?: StringNullableFilter | string | null
    checkOutBy?: StringNullableFilter | string | null
    belongingsChecklist?: JsonNullableFilter
    foodProvided?: BoolFilter | boolean
    medicationGiven?: BoolFilter | boolean
    medicationNotes?: StringNullableFilter | string | null
    behaviorDuringStay?: StringNullableFilter | string | null
    photosTaken?: BoolFilter | boolean
    photosShared?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MedicalRecordUpsertWithWhereUniqueWithoutPetInput = {
    where: MedicalRecordWhereUniqueInput
    update: XOR<MedicalRecordUpdateWithoutPetInput, MedicalRecordUncheckedUpdateWithoutPetInput>
    create: XOR<MedicalRecordCreateWithoutPetInput, MedicalRecordUncheckedCreateWithoutPetInput>
  }

  export type MedicalRecordUpdateWithWhereUniqueWithoutPetInput = {
    where: MedicalRecordWhereUniqueInput
    data: XOR<MedicalRecordUpdateWithoutPetInput, MedicalRecordUncheckedUpdateWithoutPetInput>
  }

  export type MedicalRecordUpdateManyWithWhereWithoutPetInput = {
    where: MedicalRecordScalarWhereInput
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyWithoutMedicalRecordsInput>
  }

  export type MedicalRecordScalarWhereInput = {
    AND?: Enumerable<MedicalRecordScalarWhereInput>
    OR?: Enumerable<MedicalRecordScalarWhereInput>
    NOT?: Enumerable<MedicalRecordScalarWhereInput>
    id?: StringFilter | string
    petId?: StringFilter | string
    recordType?: StringFilter | string
    recordDate?: DateTimeFilter | Date | string
    expirationDate?: DateTimeNullableFilter | Date | string | null
    description?: StringFilter | string
    veterinarian?: StringNullableFilter | string | null
    fileUrl?: StringNullableFilter | string | null
    verified?: BoolFilter | boolean
    verifiedBy?: StringNullableFilter | string | null
    verifiedDate?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomerCreateWithoutReservationsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetCreateNestedManyWithoutOwnerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    documents?: DocumentCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutReservationsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetUncheckedCreateNestedManyWithoutOwnerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutReservationsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutReservationsInput, CustomerUncheckedCreateWithoutReservationsInput>
  }

  export type PetCreateWithoutReservationsInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: CustomerCreateNestedOneWithoutPetsInput
    checkIns?: CheckInCreateNestedManyWithoutPetInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutReservationsInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    checkIns?: CheckInUncheckedCreateNestedManyWithoutPetInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutReservationsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutReservationsInput, PetUncheckedCreateWithoutReservationsInput>
  }

  export type ServiceCreateWithoutReservationsInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    price: number
    color?: string | null
    serviceCategory: ServiceCategory
    isActive?: boolean
    capacityLimit?: number | null
    requiresStaff?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availableAddOns?: AddOnServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutReservationsInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    price: number
    color?: string | null
    serviceCategory: ServiceCategory
    isActive?: boolean
    capacityLimit?: number | null
    requiresStaff?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availableAddOns?: AddOnServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutReservationsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutReservationsInput, ServiceUncheckedCreateWithoutReservationsInput>
  }

  export type ResourceCreateWithoutReservationsInput = {
    id?: string
    name: string
    type: ResourceType
    description?: string | null
    capacity?: number | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUncheckedCreateWithoutReservationsInput = {
    id?: string
    name: string
    type: ResourceType
    description?: string | null
    capacity?: number | null
    isActive?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceCreateOrConnectWithoutReservationsInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutReservationsInput, ResourceUncheckedCreateWithoutReservationsInput>
  }

  export type StaffCreateWithoutAssignedReservationsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    specialties?: StaffCreatespecialtiesInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUncheckedCreateWithoutAssignedReservationsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone?: string | null
    role: string
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    specialties?: StaffCreatespecialtiesInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateOrConnectWithoutAssignedReservationsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutAssignedReservationsInput, StaffUncheckedCreateWithoutAssignedReservationsInput>
  }

  export type ReservationAddOnCreateWithoutReservationInput = {
    id?: string
    price: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addOn: AddOnServiceCreateNestedOneWithoutReservationAddOnsInput
  }

  export type ReservationAddOnUncheckedCreateWithoutReservationInput = {
    id?: string
    addOnId: string
    price: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationAddOnCreateOrConnectWithoutReservationInput = {
    where: ReservationAddOnWhereUniqueInput
    create: XOR<ReservationAddOnCreateWithoutReservationInput, ReservationAddOnUncheckedCreateWithoutReservationInput>
  }

  export type ReservationAddOnCreateManyReservationInputEnvelope = {
    data: Enumerable<ReservationAddOnCreateManyReservationInput>
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutReservationInput = {
    id?: string
    invoiceNumber: string
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    lineItems?: InvoiceLineItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutReservationInput = {
    id?: string
    invoiceNumber: string
    customerId: string
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutReservationInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutReservationInput, InvoiceUncheckedCreateWithoutReservationInput>
  }

  export type CheckInCreateWithoutReservationInput = {
    id?: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    checkInNotes?: string | null
    checkOutNotes?: string | null
    checkInBy?: string | null
    checkOutBy?: string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: string | null
    behaviorDuringStay?: string | null
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pet: PetCreateNestedOneWithoutCheckInsInput
    activities?: ActivityCreateNestedManyWithoutCheckInInput
  }

  export type CheckInUncheckedCreateWithoutReservationInput = {
    id?: string
    petId: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    checkInNotes?: string | null
    checkOutNotes?: string | null
    checkInBy?: string | null
    checkOutBy?: string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: string | null
    behaviorDuringStay?: string | null
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutCheckInInput
  }

  export type CheckInCreateOrConnectWithoutReservationInput = {
    where: CheckInWhereUniqueInput
    create: XOR<CheckInCreateWithoutReservationInput, CheckInUncheckedCreateWithoutReservationInput>
  }

  export type CheckInCreateManyReservationInputEnvelope = {
    data: Enumerable<CheckInCreateManyReservationInput>
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutReservationsInput = {
    update: XOR<CustomerUpdateWithoutReservationsInput, CustomerUncheckedUpdateWithoutReservationsInput>
    create: XOR<CustomerCreateWithoutReservationsInput, CustomerUncheckedCreateWithoutReservationsInput>
  }

  export type CustomerUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUpdateManyWithoutOwnerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUncheckedUpdateManyWithoutOwnerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutCustomerNestedInput
  }

  export type PetUpsertWithoutReservationsInput = {
    update: XOR<PetUpdateWithoutReservationsInput, PetUncheckedUpdateWithoutReservationsInput>
    create: XOR<PetCreateWithoutReservationsInput, PetUncheckedCreateWithoutReservationsInput>
  }

  export type PetUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: CustomerUpdateOneRequiredWithoutPetsNestedInput
    checkIns?: CheckInUpdateManyWithoutPetNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    checkIns?: CheckInUncheckedUpdateManyWithoutPetNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type ServiceUpsertWithoutReservationsInput = {
    update: XOR<ServiceUpdateWithoutReservationsInput, ServiceUncheckedUpdateWithoutReservationsInput>
    create: XOR<ServiceCreateWithoutReservationsInput, ServiceUncheckedCreateWithoutReservationsInput>
  }

  export type ServiceUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | ServiceCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    capacityLimit?: NullableIntFieldUpdateOperationsInput | number | null
    requiresStaff?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableAddOns?: AddOnServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | ServiceCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    capacityLimit?: NullableIntFieldUpdateOperationsInput | number | null
    requiresStaff?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableAddOns?: AddOnServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ResourceUpsertWithoutReservationsInput = {
    update: XOR<ResourceUpdateWithoutReservationsInput, ResourceUncheckedUpdateWithoutReservationsInput>
    create: XOR<ResourceCreateWithoutReservationsInput, ResourceUncheckedCreateWithoutReservationsInput>
  }

  export type ResourceUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | ResourceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | ResourceType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUpsertWithoutAssignedReservationsInput = {
    update: XOR<StaffUpdateWithoutAssignedReservationsInput, StaffUncheckedUpdateWithoutAssignedReservationsInput>
    create: XOR<StaffCreateWithoutAssignedReservationsInput, StaffUncheckedCreateWithoutAssignedReservationsInput>
  }

  export type StaffUpdateWithoutAssignedReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    specialties?: StaffUpdatespecialtiesInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateWithoutAssignedReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    workSchedule?: NullableJsonNullValueInput | InputJsonValue
    specialties?: StaffUpdatespecialtiesInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationAddOnUpsertWithWhereUniqueWithoutReservationInput = {
    where: ReservationAddOnWhereUniqueInput
    update: XOR<ReservationAddOnUpdateWithoutReservationInput, ReservationAddOnUncheckedUpdateWithoutReservationInput>
    create: XOR<ReservationAddOnCreateWithoutReservationInput, ReservationAddOnUncheckedCreateWithoutReservationInput>
  }

  export type ReservationAddOnUpdateWithWhereUniqueWithoutReservationInput = {
    where: ReservationAddOnWhereUniqueInput
    data: XOR<ReservationAddOnUpdateWithoutReservationInput, ReservationAddOnUncheckedUpdateWithoutReservationInput>
  }

  export type ReservationAddOnUpdateManyWithWhereWithoutReservationInput = {
    where: ReservationAddOnScalarWhereInput
    data: XOR<ReservationAddOnUpdateManyMutationInput, ReservationAddOnUncheckedUpdateManyWithoutAddOnServicesInput>
  }

  export type ReservationAddOnScalarWhereInput = {
    AND?: Enumerable<ReservationAddOnScalarWhereInput>
    OR?: Enumerable<ReservationAddOnScalarWhereInput>
    NOT?: Enumerable<ReservationAddOnScalarWhereInput>
    id?: StringFilter | string
    reservationId?: StringFilter | string
    addOnId?: StringFilter | string
    price?: FloatFilter | number
    notes?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type InvoiceUpsertWithoutReservationInput = {
    update: XOR<InvoiceUpdateWithoutReservationInput, InvoiceUncheckedUpdateWithoutReservationInput>
    create: XOR<InvoiceCreateWithoutReservationInput, InvoiceUncheckedCreateWithoutReservationInput>
  }

  export type InvoiceUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    lineItems?: InvoiceLineItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CheckInUpsertWithWhereUniqueWithoutReservationInput = {
    where: CheckInWhereUniqueInput
    update: XOR<CheckInUpdateWithoutReservationInput, CheckInUncheckedUpdateWithoutReservationInput>
    create: XOR<CheckInCreateWithoutReservationInput, CheckInUncheckedCreateWithoutReservationInput>
  }

  export type CheckInUpdateWithWhereUniqueWithoutReservationInput = {
    where: CheckInWhereUniqueInput
    data: XOR<CheckInUpdateWithoutReservationInput, CheckInUncheckedUpdateWithoutReservationInput>
  }

  export type CheckInUpdateManyWithWhereWithoutReservationInput = {
    where: CheckInScalarWhereInput
    data: XOR<CheckInUpdateManyMutationInput, CheckInUncheckedUpdateManyWithoutCheckInsInput>
  }

  export type ReservationCreateWithoutServiceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutReservationsInput
    pet: PetCreateNestedOneWithoutReservationsInput
    resource?: ResourceCreateNestedOneWithoutReservationsInput
    staffAssigned?: StaffCreateNestedOneWithoutAssignedReservationsInput
    addOnServices?: ReservationAddOnCreateNestedManyWithoutReservationInput
    invoice?: InvoiceCreateNestedOneWithoutReservationInput
    checkIns?: CheckInCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutServiceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    petId: string
    resourceId?: string | null
    staffAssignedId?: string | null
    addOnServices?: ReservationAddOnUncheckedCreateNestedManyWithoutReservationInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutReservationInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutServiceInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutServiceInput, ReservationUncheckedCreateWithoutServiceInput>
  }

  export type ReservationCreateManyServiceInputEnvelope = {
    data: Enumerable<ReservationCreateManyServiceInput>
    skipDuplicates?: boolean
  }

  export type AddOnServiceCreateWithoutServiceInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservationAddOns?: ReservationAddOnCreateNestedManyWithoutAddOnInput
  }

  export type AddOnServiceUncheckedCreateWithoutServiceInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservationAddOns?: ReservationAddOnUncheckedCreateNestedManyWithoutAddOnInput
  }

  export type AddOnServiceCreateOrConnectWithoutServiceInput = {
    where: AddOnServiceWhereUniqueInput
    create: XOR<AddOnServiceCreateWithoutServiceInput, AddOnServiceUncheckedCreateWithoutServiceInput>
  }

  export type AddOnServiceCreateManyServiceInputEnvelope = {
    data: Enumerable<AddOnServiceCreateManyServiceInput>
    skipDuplicates?: boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutServiceInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutServiceInput, ReservationUncheckedUpdateWithoutServiceInput>
    create: XOR<ReservationCreateWithoutServiceInput, ReservationUncheckedCreateWithoutServiceInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutServiceInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutServiceInput, ReservationUncheckedUpdateWithoutServiceInput>
  }

  export type ReservationUpdateManyWithWhereWithoutServiceInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutReservationsInput>
  }

  export type AddOnServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: AddOnServiceWhereUniqueInput
    update: XOR<AddOnServiceUpdateWithoutServiceInput, AddOnServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<AddOnServiceCreateWithoutServiceInput, AddOnServiceUncheckedCreateWithoutServiceInput>
  }

  export type AddOnServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: AddOnServiceWhereUniqueInput
    data: XOR<AddOnServiceUpdateWithoutServiceInput, AddOnServiceUncheckedUpdateWithoutServiceInput>
  }

  export type AddOnServiceUpdateManyWithWhereWithoutServiceInput = {
    where: AddOnServiceScalarWhereInput
    data: XOR<AddOnServiceUpdateManyMutationInput, AddOnServiceUncheckedUpdateManyWithoutAvailableAddOnsInput>
  }

  export type AddOnServiceScalarWhereInput = {
    AND?: Enumerable<AddOnServiceScalarWhereInput>
    OR?: Enumerable<AddOnServiceScalarWhereInput>
    NOT?: Enumerable<AddOnServiceScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    price?: FloatFilter | number
    duration?: IntNullableFilter | number | null
    serviceId?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ServiceCreateWithoutAvailableAddOnsInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    price: number
    color?: string | null
    serviceCategory: ServiceCategory
    isActive?: boolean
    capacityLimit?: number | null
    requiresStaff?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutAvailableAddOnsInput = {
    id?: string
    name: string
    description?: string | null
    duration: number
    price: number
    color?: string | null
    serviceCategory: ServiceCategory
    isActive?: boolean
    capacityLimit?: number | null
    requiresStaff?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutAvailableAddOnsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAvailableAddOnsInput, ServiceUncheckedCreateWithoutAvailableAddOnsInput>
  }

  export type ReservationAddOnCreateWithoutAddOnInput = {
    id?: string
    price: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservation: ReservationCreateNestedOneWithoutAddOnServicesInput
  }

  export type ReservationAddOnUncheckedCreateWithoutAddOnInput = {
    id?: string
    reservationId: string
    price: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationAddOnCreateOrConnectWithoutAddOnInput = {
    where: ReservationAddOnWhereUniqueInput
    create: XOR<ReservationAddOnCreateWithoutAddOnInput, ReservationAddOnUncheckedCreateWithoutAddOnInput>
  }

  export type ReservationAddOnCreateManyAddOnInputEnvelope = {
    data: Enumerable<ReservationAddOnCreateManyAddOnInput>
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithoutAvailableAddOnsInput = {
    update: XOR<ServiceUpdateWithoutAvailableAddOnsInput, ServiceUncheckedUpdateWithoutAvailableAddOnsInput>
    create: XOR<ServiceCreateWithoutAvailableAddOnsInput, ServiceUncheckedCreateWithoutAvailableAddOnsInput>
  }

  export type ServiceUpdateWithoutAvailableAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | ServiceCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    capacityLimit?: NullableIntFieldUpdateOperationsInput | number | null
    requiresStaff?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAvailableAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | ServiceCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    capacityLimit?: NullableIntFieldUpdateOperationsInput | number | null
    requiresStaff?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ReservationAddOnUpsertWithWhereUniqueWithoutAddOnInput = {
    where: ReservationAddOnWhereUniqueInput
    update: XOR<ReservationAddOnUpdateWithoutAddOnInput, ReservationAddOnUncheckedUpdateWithoutAddOnInput>
    create: XOR<ReservationAddOnCreateWithoutAddOnInput, ReservationAddOnUncheckedCreateWithoutAddOnInput>
  }

  export type ReservationAddOnUpdateWithWhereUniqueWithoutAddOnInput = {
    where: ReservationAddOnWhereUniqueInput
    data: XOR<ReservationAddOnUpdateWithoutAddOnInput, ReservationAddOnUncheckedUpdateWithoutAddOnInput>
  }

  export type ReservationAddOnUpdateManyWithWhereWithoutAddOnInput = {
    where: ReservationAddOnScalarWhereInput
    data: XOR<ReservationAddOnUpdateManyMutationInput, ReservationAddOnUncheckedUpdateManyWithoutReservationAddOnsInput>
  }

  export type ReservationCreateWithoutAddOnServicesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutReservationsInput
    pet: PetCreateNestedOneWithoutReservationsInput
    service: ServiceCreateNestedOneWithoutReservationsInput
    resource?: ResourceCreateNestedOneWithoutReservationsInput
    staffAssigned?: StaffCreateNestedOneWithoutAssignedReservationsInput
    invoice?: InvoiceCreateNestedOneWithoutReservationInput
    checkIns?: CheckInCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutAddOnServicesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    petId: string
    serviceId: string
    resourceId?: string | null
    staffAssignedId?: string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutReservationInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutAddOnServicesInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutAddOnServicesInput, ReservationUncheckedCreateWithoutAddOnServicesInput>
  }

  export type AddOnServiceCreateWithoutReservationAddOnsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutAvailableAddOnsInput
  }

  export type AddOnServiceUncheckedCreateWithoutReservationAddOnsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration?: number | null
    serviceId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddOnServiceCreateOrConnectWithoutReservationAddOnsInput = {
    where: AddOnServiceWhereUniqueInput
    create: XOR<AddOnServiceCreateWithoutReservationAddOnsInput, AddOnServiceUncheckedCreateWithoutReservationAddOnsInput>
  }

  export type ReservationUpsertWithoutAddOnServicesInput = {
    update: XOR<ReservationUpdateWithoutAddOnServicesInput, ReservationUncheckedUpdateWithoutAddOnServicesInput>
    create: XOR<ReservationCreateWithoutAddOnServicesInput, ReservationUncheckedCreateWithoutAddOnServicesInput>
  }

  export type ReservationUpdateWithoutAddOnServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutReservationsNestedInput
    pet?: PetUpdateOneRequiredWithoutReservationsNestedInput
    service?: ServiceUpdateOneRequiredWithoutReservationsNestedInput
    resource?: ResourceUpdateOneWithoutReservationsNestedInput
    staffAssigned?: StaffUpdateOneWithoutAssignedReservationsNestedInput
    invoice?: InvoiceUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutAddOnServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    staffAssignedId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type AddOnServiceUpsertWithoutReservationAddOnsInput = {
    update: XOR<AddOnServiceUpdateWithoutReservationAddOnsInput, AddOnServiceUncheckedUpdateWithoutReservationAddOnsInput>
    create: XOR<AddOnServiceCreateWithoutReservationAddOnsInput, AddOnServiceUncheckedCreateWithoutReservationAddOnsInput>
  }

  export type AddOnServiceUpdateWithoutReservationAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutAvailableAddOnsNestedInput
  }

  export type AddOnServiceUncheckedUpdateWithoutReservationAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateWithoutResourceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutReservationsInput
    pet: PetCreateNestedOneWithoutReservationsInput
    service: ServiceCreateNestedOneWithoutReservationsInput
    staffAssigned?: StaffCreateNestedOneWithoutAssignedReservationsInput
    addOnServices?: ReservationAddOnCreateNestedManyWithoutReservationInput
    invoice?: InvoiceCreateNestedOneWithoutReservationInput
    checkIns?: CheckInCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutResourceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    petId: string
    serviceId: string
    staffAssignedId?: string | null
    addOnServices?: ReservationAddOnUncheckedCreateNestedManyWithoutReservationInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutReservationInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutResourceInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutResourceInput, ReservationUncheckedCreateWithoutResourceInput>
  }

  export type ReservationCreateManyResourceInputEnvelope = {
    data: Enumerable<ReservationCreateManyResourceInput>
    skipDuplicates?: boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutResourceInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutResourceInput, ReservationUncheckedUpdateWithoutResourceInput>
    create: XOR<ReservationCreateWithoutResourceInput, ReservationUncheckedCreateWithoutResourceInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutResourceInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutResourceInput, ReservationUncheckedUpdateWithoutResourceInput>
  }

  export type ReservationUpdateManyWithWhereWithoutResourceInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutReservationsInput>
  }

  export type ReservationCreateWithoutStaffAssignedInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutReservationsInput
    pet: PetCreateNestedOneWithoutReservationsInput
    service: ServiceCreateNestedOneWithoutReservationsInput
    resource?: ResourceCreateNestedOneWithoutReservationsInput
    addOnServices?: ReservationAddOnCreateNestedManyWithoutReservationInput
    invoice?: InvoiceCreateNestedOneWithoutReservationInput
    checkIns?: CheckInCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutStaffAssignedInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    petId: string
    serviceId: string
    resourceId?: string | null
    addOnServices?: ReservationAddOnUncheckedCreateNestedManyWithoutReservationInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutReservationInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutStaffAssignedInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutStaffAssignedInput, ReservationUncheckedCreateWithoutStaffAssignedInput>
  }

  export type ReservationCreateManyStaffAssignedInputEnvelope = {
    data: Enumerable<ReservationCreateManyStaffAssignedInput>
    skipDuplicates?: boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutStaffAssignedInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutStaffAssignedInput, ReservationUncheckedUpdateWithoutStaffAssignedInput>
    create: XOR<ReservationCreateWithoutStaffAssignedInput, ReservationUncheckedCreateWithoutStaffAssignedInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutStaffAssignedInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutStaffAssignedInput, ReservationUncheckedUpdateWithoutStaffAssignedInput>
  }

  export type ReservationUpdateManyWithWhereWithoutStaffAssignedInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutAssignedReservationsInput>
  }

  export type CustomerCreateWithoutInvoicesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetCreateNestedManyWithoutOwnerInput
    reservations?: ReservationCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    documents?: DocumentCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutInvoicesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetUncheckedCreateNestedManyWithoutOwnerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
  }

  export type ReservationCreateWithoutInvoiceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutReservationsInput
    pet: PetCreateNestedOneWithoutReservationsInput
    service: ServiceCreateNestedOneWithoutReservationsInput
    resource?: ResourceCreateNestedOneWithoutReservationsInput
    staffAssigned?: StaffCreateNestedOneWithoutAssignedReservationsInput
    addOnServices?: ReservationAddOnCreateNestedManyWithoutReservationInput
    checkIns?: CheckInCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutInvoiceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    petId: string
    serviceId: string
    resourceId?: string | null
    staffAssignedId?: string | null
    addOnServices?: ReservationAddOnUncheckedCreateNestedManyWithoutReservationInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutInvoiceInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutInvoiceInput, ReservationUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: number
    amount: number
    taxable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: number
    amount: number
    taxable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceLineItemWhereUniqueInput
    create: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineItemCreateManyInvoiceInputEnvelope = {
    data: Enumerable<InvoiceLineItemCreateManyInvoiceInput>
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    amount: number
    method: PaymentMethod
    status?: PaymentStatus
    transactionId?: string | null
    paymentDate?: Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: number
    refundReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    customerId: string
    amount: number
    method: PaymentMethod
    status?: PaymentStatus
    transactionId?: string | null
    paymentDate?: Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: number
    refundReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: Enumerable<PaymentCreateManyInvoiceInput>
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutInvoicesInput = {
    update: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
  }

  export type CustomerUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUpdateManyWithoutOwnerNestedInput
    reservations?: ReservationUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUncheckedUpdateManyWithoutOwnerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutCustomerNestedInput
  }

  export type ReservationUpsertWithoutInvoiceInput = {
    update: XOR<ReservationUpdateWithoutInvoiceInput, ReservationUncheckedUpdateWithoutInvoiceInput>
    create: XOR<ReservationCreateWithoutInvoiceInput, ReservationUncheckedCreateWithoutInvoiceInput>
  }

  export type ReservationUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutReservationsNestedInput
    pet?: PetUpdateOneRequiredWithoutReservationsNestedInput
    service?: ServiceUpdateOneRequiredWithoutReservationsNestedInput
    resource?: ResourceUpdateOneWithoutReservationsNestedInput
    staffAssigned?: StaffUpdateOneWithoutAssignedReservationsNestedInput
    addOnServices?: ReservationAddOnUpdateManyWithoutReservationNestedInput
    checkIns?: CheckInUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    staffAssignedId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnServices?: ReservationAddOnUncheckedUpdateManyWithoutReservationNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type InvoiceLineItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineItemWhereUniqueInput
    update: XOR<InvoiceLineItemUpdateWithoutInvoiceInput, InvoiceLineItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceLineItemCreateWithoutInvoiceInput, InvoiceLineItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineItemWhereUniqueInput
    data: XOR<InvoiceLineItemUpdateWithoutInvoiceInput, InvoiceLineItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceLineItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceLineItemScalarWhereInput
    data: XOR<InvoiceLineItemUpdateManyMutationInput, InvoiceLineItemUncheckedUpdateManyWithoutLineItemsInput>
  }

  export type InvoiceLineItemScalarWhereInput = {
    AND?: Enumerable<InvoiceLineItemScalarWhereInput>
    OR?: Enumerable<InvoiceLineItemScalarWhereInput>
    NOT?: Enumerable<InvoiceLineItemScalarWhereInput>
    id?: StringFilter | string
    invoiceId?: StringFilter | string
    description?: StringFilter | string
    quantity?: IntFilter | number
    unitPrice?: FloatFilter | number
    amount?: FloatFilter | number
    taxable?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentsInput>
  }

  export type InvoiceCreateWithoutLineItemsInput = {
    id?: string
    invoiceNumber: string
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    reservation?: ReservationCreateNestedOneWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLineItemsInput = {
    id?: string
    invoiceNumber: string
    customerId: string
    reservationId?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLineItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
  }

  export type InvoiceUpsertWithoutLineItemsInput = {
    update: XOR<InvoiceUpdateWithoutLineItemsInput, InvoiceUncheckedUpdateWithoutLineItemsInput>
    create: XOR<InvoiceCreateWithoutLineItemsInput, InvoiceUncheckedCreateWithoutLineItemsInput>
  }

  export type InvoiceUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    reservation?: ReservationUpdateOneWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    reservation?: ReservationCreateNestedOneWithoutInvoiceInput
    lineItems?: InvoiceLineItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    customerId: string
    reservationId?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: InvoiceLineItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type CustomerCreateWithoutPaymentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetCreateNestedManyWithoutOwnerInput
    reservations?: ReservationCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    documents?: DocumentCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetUncheckedCreateNestedManyWithoutOwnerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPaymentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    reservation?: ReservationUpdateOneWithoutInvoiceNestedInput
    lineItems?: InvoiceLineItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerUpsertWithoutPaymentsInput = {
    update: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
  }

  export type CustomerUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUpdateManyWithoutOwnerNestedInput
    reservations?: ReservationUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUncheckedUpdateManyWithoutOwnerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutDocumentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetCreateNestedManyWithoutOwnerInput
    reservations?: ReservationCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutDocumentsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetUncheckedCreateNestedManyWithoutOwnerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    notifications?: NotificationPreferenceUncheckedCreateNestedOneWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutDocumentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutDocumentsInput, CustomerUncheckedCreateWithoutDocumentsInput>
  }

  export type CustomerUpsertWithoutDocumentsInput = {
    update: XOR<CustomerUpdateWithoutDocumentsInput, CustomerUncheckedUpdateWithoutDocumentsInput>
    create: XOR<CustomerCreateWithoutDocumentsInput, CustomerUncheckedCreateWithoutDocumentsInput>
  }

  export type CustomerUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUpdateManyWithoutOwnerNestedInput
    reservations?: ReservationUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUncheckedUpdateManyWithoutOwnerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    notifications?: NotificationPreferenceUncheckedUpdateOneWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutNotificationsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetCreateNestedManyWithoutOwnerInput
    reservations?: ReservationCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    documents?: DocumentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    phone?: string | null
    alternatePhone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    notes?: string | null
    portalEnabled?: boolean
    preferredContact?: ContactMethod
    emergencyContact?: string | null
    emergencyPhone?: string | null
    vatTaxId?: string | null
    referralSource?: string | null
    tags?: CustomerCreatetagsInput | Enumerable<string>
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pets?: PetUncheckedCreateNestedManyWithoutOwnerInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutNotificationsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutNotificationsInput, CustomerUncheckedCreateWithoutNotificationsInput>
  }

  export type CustomerUpsertWithoutNotificationsInput = {
    update: XOR<CustomerUpdateWithoutNotificationsInput, CustomerUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CustomerCreateWithoutNotificationsInput, CustomerUncheckedCreateWithoutNotificationsInput>
  }

  export type CustomerUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUpdateManyWithoutOwnerNestedInput
    reservations?: ReservationUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alternatePhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portalEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredContact?: EnumContactMethodFieldUpdateOperationsInput | ContactMethod
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    vatTaxId?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CustomerUpdatetagsInput | Enumerable<string>
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pets?: PetUncheckedUpdateManyWithoutOwnerNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PetCreateWithoutCheckInsInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: CustomerCreateNestedOneWithoutPetsInput
    reservations?: ReservationCreateNestedManyWithoutPetInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutCheckInsInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    reservations?: ReservationUncheckedCreateNestedManyWithoutPetInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutCheckInsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutCheckInsInput, PetUncheckedCreateWithoutCheckInsInput>
  }

  export type ReservationCreateWithoutCheckInsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutReservationsInput
    pet: PetCreateNestedOneWithoutReservationsInput
    service: ServiceCreateNestedOneWithoutReservationsInput
    resource?: ResourceCreateNestedOneWithoutReservationsInput
    staffAssigned?: StaffCreateNestedOneWithoutAssignedReservationsInput
    addOnServices?: ReservationAddOnCreateNestedManyWithoutReservationInput
    invoice?: InvoiceCreateNestedOneWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutCheckInsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    petId: string
    serviceId: string
    resourceId?: string | null
    staffAssignedId?: string | null
    addOnServices?: ReservationAddOnUncheckedCreateNestedManyWithoutReservationInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutCheckInsInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutCheckInsInput, ReservationUncheckedCreateWithoutCheckInsInput>
  }

  export type ActivityCreateWithoutCheckInInput = {
    id?: string
    activityType: string
    notes?: string | null
    timestamp?: Date | string
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUncheckedCreateWithoutCheckInInput = {
    id?: string
    activityType: string
    notes?: string | null
    timestamp?: Date | string
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutCheckInInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutCheckInInput, ActivityUncheckedCreateWithoutCheckInInput>
  }

  export type ActivityCreateManyCheckInInputEnvelope = {
    data: Enumerable<ActivityCreateManyCheckInInput>
    skipDuplicates?: boolean
  }

  export type PetUpsertWithoutCheckInsInput = {
    update: XOR<PetUpdateWithoutCheckInsInput, PetUncheckedUpdateWithoutCheckInsInput>
    create: XOR<PetCreateWithoutCheckInsInput, PetUncheckedCreateWithoutCheckInsInput>
  }

  export type PetUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: CustomerUpdateOneRequiredWithoutPetsNestedInput
    reservations?: ReservationUpdateManyWithoutPetNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    reservations?: ReservationUncheckedUpdateManyWithoutPetNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type ReservationUpsertWithoutCheckInsInput = {
    update: XOR<ReservationUpdateWithoutCheckInsInput, ReservationUncheckedUpdateWithoutCheckInsInput>
    create: XOR<ReservationCreateWithoutCheckInsInput, ReservationUncheckedCreateWithoutCheckInsInput>
  }

  export type ReservationUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutReservationsNestedInput
    pet?: PetUpdateOneRequiredWithoutReservationsNestedInput
    service?: ServiceUpdateOneRequiredWithoutReservationsNestedInput
    resource?: ResourceUpdateOneWithoutReservationsNestedInput
    staffAssigned?: StaffUpdateOneWithoutAssignedReservationsNestedInput
    addOnServices?: ReservationAddOnUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUpdateOneWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    staffAssignedId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnServices?: ReservationAddOnUncheckedUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutReservationNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutCheckInInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutCheckInInput, ActivityUncheckedUpdateWithoutCheckInInput>
    create: XOR<ActivityCreateWithoutCheckInInput, ActivityUncheckedCreateWithoutCheckInInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutCheckInInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutCheckInInput, ActivityUncheckedUpdateWithoutCheckInInput>
  }

  export type ActivityUpdateManyWithWhereWithoutCheckInInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutActivitiesInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: Enumerable<ActivityScalarWhereInput>
    OR?: Enumerable<ActivityScalarWhereInput>
    NOT?: Enumerable<ActivityScalarWhereInput>
    id?: StringFilter | string
    checkInId?: StringFilter | string
    activityType?: StringFilter | string
    notes?: StringNullableFilter | string | null
    timestamp?: DateTimeFilter | Date | string
    recordedBy?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CheckInCreateWithoutActivitiesInput = {
    id?: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    checkInNotes?: string | null
    checkOutNotes?: string | null
    checkInBy?: string | null
    checkOutBy?: string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: string | null
    behaviorDuringStay?: string | null
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pet: PetCreateNestedOneWithoutCheckInsInput
    reservation?: ReservationCreateNestedOneWithoutCheckInsInput
  }

  export type CheckInUncheckedCreateWithoutActivitiesInput = {
    id?: string
    petId: string
    reservationId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    checkInNotes?: string | null
    checkOutNotes?: string | null
    checkInBy?: string | null
    checkOutBy?: string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: string | null
    behaviorDuringStay?: string | null
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheckInCreateOrConnectWithoutActivitiesInput = {
    where: CheckInWhereUniqueInput
    create: XOR<CheckInCreateWithoutActivitiesInput, CheckInUncheckedCreateWithoutActivitiesInput>
  }

  export type CheckInUpsertWithoutActivitiesInput = {
    update: XOR<CheckInUpdateWithoutActivitiesInput, CheckInUncheckedUpdateWithoutActivitiesInput>
    create: XOR<CheckInCreateWithoutActivitiesInput, CheckInUncheckedCreateWithoutActivitiesInput>
  }

  export type CheckInUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutBy?: NullableStringFieldUpdateOperationsInput | string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: BoolFieldUpdateOperationsInput | boolean
    medicationGiven?: BoolFieldUpdateOperationsInput | boolean
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorDuringStay?: NullableStringFieldUpdateOperationsInput | string | null
    photosTaken?: BoolFieldUpdateOperationsInput | boolean
    photosShared?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneRequiredWithoutCheckInsNestedInput
    reservation?: ReservationUpdateOneWithoutCheckInsNestedInput
  }

  export type CheckInUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutBy?: NullableStringFieldUpdateOperationsInput | string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: BoolFieldUpdateOperationsInput | boolean
    medicationGiven?: BoolFieldUpdateOperationsInput | boolean
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorDuringStay?: NullableStringFieldUpdateOperationsInput | string | null
    photosTaken?: BoolFieldUpdateOperationsInput | boolean
    photosShared?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetCreateWithoutMedicalRecordsInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: CustomerCreateNestedOneWithoutPetsInput
    reservations?: ReservationCreateNestedManyWithoutPetInput
    checkIns?: CheckInCreateNestedManyWithoutPetInput
  }

  export type PetUncheckedCreateWithoutMedicalRecordsInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    reservations?: ReservationUncheckedCreateNestedManyWithoutPetInput
    checkIns?: CheckInUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetCreateOrConnectWithoutMedicalRecordsInput = {
    where: PetWhereUniqueInput
    create: XOR<PetCreateWithoutMedicalRecordsInput, PetUncheckedCreateWithoutMedicalRecordsInput>
  }

  export type PetUpsertWithoutMedicalRecordsInput = {
    update: XOR<PetUpdateWithoutMedicalRecordsInput, PetUncheckedUpdateWithoutMedicalRecordsInput>
    create: XOR<PetCreateWithoutMedicalRecordsInput, PetUncheckedCreateWithoutMedicalRecordsInput>
  }

  export type PetUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: CustomerUpdateOneRequiredWithoutPetsNestedInput
    reservations?: ReservationUpdateManyWithoutPetNestedInput
    checkIns?: CheckInUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    reservations?: ReservationUncheckedUpdateManyWithoutPetNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetCreateManyOwnerInput = {
    id?: string
    name: string
    type: PetType
    breed?: string | null
    color?: string | null
    birthdate?: Date | string | null
    weight?: number | null
    gender?: Gender | null
    isNeutered?: boolean
    microchipNumber?: string | null
    rabiesTagNumber?: string | null
    specialNeeds?: string | null
    foodNotes?: string | null
    medicationNotes?: string | null
    behaviorNotes?: string | null
    allergies?: string | null
    idealPlayGroup?: PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: string | null
    vetPhone?: string | null
    profilePhoto?: string | null
    isActive?: boolean
    lastCheckIn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateManyCustomerInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    petId: string
    serviceId: string
    resourceId?: string | null
    staffAssignedId?: string | null
  }

  export type PaymentCreateManyCustomerInput = {
    id?: string
    invoiceId: string
    amount: number
    method: PaymentMethod
    status?: PaymentStatus
    transactionId?: string | null
    paymentDate?: Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: number
    refundReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyCustomerInput = {
    id?: string
    invoiceNumber: string
    reservationId?: string | null
    issueDate?: Date | string
    dueDate: Date | string
    status?: InvoiceStatus
    subtotal: number
    taxRate?: number
    taxAmount?: number
    discount?: number
    total: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyCustomerInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType: string
    fileSize: number
    tags?: DocumentCreatetagsInput | Enumerable<string>
    uploaded?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PetUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutPetNestedInput
    checkIns?: CheckInUpdateManyWithoutPetNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutPetNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutPetNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetUncheckedUpdateManyWithoutPetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPetTypeFieldUpdateOperationsInput | PetType
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    isNeutered?: BoolFieldUpdateOperationsInput | boolean
    microchipNumber?: NullableStringFieldUpdateOperationsInput | string | null
    rabiesTagNumber?: NullableStringFieldUpdateOperationsInput | string | null
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    foodNotes?: NullableStringFieldUpdateOperationsInput | string | null
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorNotes?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    idealPlayGroup?: NullableEnumPlayGroupTypeFieldUpdateOperationsInput | PlayGroupType | null
    vaccinationStatus?: NullableJsonNullValueInput | InputJsonValue
    vaccineExpirations?: NullableJsonNullValueInput | InputJsonValue
    vetName?: NullableStringFieldUpdateOperationsInput | string | null
    vetPhone?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneRequiredWithoutReservationsNestedInput
    service?: ServiceUpdateOneRequiredWithoutReservationsNestedInput
    resource?: ResourceUpdateOneWithoutReservationsNestedInput
    staffAssigned?: StaffUpdateOneWithoutAssignedReservationsNestedInput
    addOnServices?: ReservationAddOnUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    petId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    staffAssignedId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnServices?: ReservationAddOnUncheckedUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    petId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    staffAssignedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: FloatFieldUpdateOperationsInput | number
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: FloatFieldUpdateOperationsInput | number
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: FloatFieldUpdateOperationsInput | number
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservation?: ReservationUpdateOneWithoutInvoiceNestedInput
    lineItems?: InvoiceLineItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: InvoiceLineItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    tags?: DocumentUpdatetagsInput | Enumerable<string>
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    tags?: DocumentUpdatetagsInput | Enumerable<string>
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    tags?: DocumentUpdatetagsInput | Enumerable<string>
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyPetInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    serviceId: string
    resourceId?: string | null
    staffAssignedId?: string | null
  }

  export type CheckInCreateManyPetInput = {
    id?: string
    reservationId?: string | null
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    checkInNotes?: string | null
    checkOutNotes?: string | null
    checkInBy?: string | null
    checkOutBy?: string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: string | null
    behaviorDuringStay?: string | null
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordCreateManyPetInput = {
    id?: string
    recordType: string
    recordDate: Date | string
    expirationDate?: Date | string | null
    description: string
    veterinarian?: string | null
    fileUrl?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutReservationsNestedInput
    service?: ServiceUpdateOneRequiredWithoutReservationsNestedInput
    resource?: ResourceUpdateOneWithoutReservationsNestedInput
    staffAssigned?: StaffUpdateOneWithoutAssignedReservationsNestedInput
    addOnServices?: ReservationAddOnUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    staffAssignedId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnServices?: ReservationAddOnUncheckedUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type CheckInUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutBy?: NullableStringFieldUpdateOperationsInput | string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: BoolFieldUpdateOperationsInput | boolean
    medicationGiven?: BoolFieldUpdateOperationsInput | boolean
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorDuringStay?: NullableStringFieldUpdateOperationsInput | string | null
    photosTaken?: BoolFieldUpdateOperationsInput | boolean
    photosShared?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservation?: ReservationUpdateOneWithoutCheckInsNestedInput
    activities?: ActivityUpdateManyWithoutCheckInNestedInput
  }

  export type CheckInUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutBy?: NullableStringFieldUpdateOperationsInput | string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: BoolFieldUpdateOperationsInput | boolean
    medicationGiven?: BoolFieldUpdateOperationsInput | boolean
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorDuringStay?: NullableStringFieldUpdateOperationsInput | string | null
    photosTaken?: BoolFieldUpdateOperationsInput | boolean
    photosShared?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutCheckInNestedInput
  }

  export type CheckInUncheckedUpdateManyWithoutCheckInsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutBy?: NullableStringFieldUpdateOperationsInput | string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: BoolFieldUpdateOperationsInput | boolean
    medicationGiven?: BoolFieldUpdateOperationsInput | boolean
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorDuringStay?: NullableStringFieldUpdateOperationsInput | string | null
    photosTaken?: BoolFieldUpdateOperationsInput | boolean
    photosShared?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    veterinarian?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    veterinarian?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUncheckedUpdateManyWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: StringFieldUpdateOperationsInput | string
    veterinarian?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationAddOnCreateManyReservationInput = {
    id?: string
    addOnId: string
    price: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheckInCreateManyReservationInput = {
    id?: string
    petId: string
    checkInTime?: Date | string
    checkOutTime?: Date | string | null
    checkInNotes?: string | null
    checkOutNotes?: string | null
    checkInBy?: string | null
    checkOutBy?: string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: boolean
    medicationGiven?: boolean
    medicationNotes?: string | null
    behaviorDuringStay?: string | null
    photosTaken?: boolean
    photosShared?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationAddOnUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOn?: AddOnServiceUpdateOneRequiredWithoutReservationAddOnsNestedInput
  }

  export type ReservationAddOnUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationAddOnUncheckedUpdateManyWithoutAddOnServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutBy?: NullableStringFieldUpdateOperationsInput | string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: BoolFieldUpdateOperationsInput | boolean
    medicationGiven?: BoolFieldUpdateOperationsInput | boolean
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorDuringStay?: NullableStringFieldUpdateOperationsInput | string | null
    photosTaken?: BoolFieldUpdateOperationsInput | boolean
    photosShared?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetUpdateOneRequiredWithoutCheckInsNestedInput
    activities?: ActivityUpdateManyWithoutCheckInNestedInput
  }

  export type CheckInUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    checkInTime?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutBy?: NullableStringFieldUpdateOperationsInput | string | null
    belongingsChecklist?: NullableJsonNullValueInput | InputJsonValue
    foodProvided?: BoolFieldUpdateOperationsInput | boolean
    medicationGiven?: BoolFieldUpdateOperationsInput | boolean
    medicationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorDuringStay?: NullableStringFieldUpdateOperationsInput | string | null
    photosTaken?: BoolFieldUpdateOperationsInput | boolean
    photosShared?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutCheckInNestedInput
  }

  export type ReservationCreateManyServiceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    petId: string
    resourceId?: string | null
    staffAssignedId?: string | null
  }

  export type AddOnServiceCreateManyServiceInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    duration?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutReservationsNestedInput
    pet?: PetUpdateOneRequiredWithoutReservationsNestedInput
    resource?: ResourceUpdateOneWithoutReservationsNestedInput
    staffAssigned?: StaffUpdateOneWithoutAssignedReservationsNestedInput
    addOnServices?: ReservationAddOnUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    staffAssignedId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnServices?: ReservationAddOnUncheckedUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type AddOnServiceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservationAddOns?: ReservationAddOnUpdateManyWithoutAddOnNestedInput
  }

  export type AddOnServiceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservationAddOns?: ReservationAddOnUncheckedUpdateManyWithoutAddOnNestedInput
  }

  export type AddOnServiceUncheckedUpdateManyWithoutAvailableAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationAddOnCreateManyAddOnInput = {
    id?: string
    reservationId: string
    price: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationAddOnUpdateWithoutAddOnInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservation?: ReservationUpdateOneRequiredWithoutAddOnServicesNestedInput
  }

  export type ReservationAddOnUncheckedUpdateWithoutAddOnInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationAddOnUncheckedUpdateManyWithoutReservationAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservationId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyResourceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    petId: string
    serviceId: string
    staffAssignedId?: string | null
  }

  export type ReservationUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutReservationsNestedInput
    pet?: PetUpdateOneRequiredWithoutReservationsNestedInput
    service?: ServiceUpdateOneRequiredWithoutReservationsNestedInput
    staffAssigned?: StaffUpdateOneWithoutAssignedReservationsNestedInput
    addOnServices?: ReservationAddOnUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    staffAssignedId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnServices?: ReservationAddOnUncheckedUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationCreateManyStaffAssignedInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: ReservationStatus
    notes?: string | null
    staffNotes?: string | null
    checkInWindow?: number | null
    isRecurring?: boolean
    recurringPattern?: string | null
    preChecked?: boolean
    checkInDate?: Date | string | null
    checkOutDate?: Date | string | null
    earlyDropOff?: boolean
    latePickup?: boolean
    customPickupPerson?: string | null
    confirmedBy?: string | null
    cancelReason?: string | null
    cancelDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    petId: string
    serviceId: string
    resourceId?: string | null
  }

  export type ReservationUpdateWithoutStaffAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutReservationsNestedInput
    pet?: PetUpdateOneRequiredWithoutReservationsNestedInput
    service?: ServiceUpdateOneRequiredWithoutReservationsNestedInput
    resource?: ResourceUpdateOneWithoutReservationsNestedInput
    addOnServices?: ReservationAddOnUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutStaffAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnServices?: ReservationAddOnUncheckedUpdateManyWithoutReservationNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutReservationNestedInput
    checkIns?: CheckInUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutAssignedReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staffNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInWindow?: NullableIntFieldUpdateOperationsInput | number | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPattern?: NullableStringFieldUpdateOperationsInput | string | null
    preChecked?: BoolFieldUpdateOperationsInput | boolean
    checkInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    earlyDropOff?: BoolFieldUpdateOperationsInput | boolean
    latePickup?: BoolFieldUpdateOperationsInput | boolean
    customPickupPerson?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceLineItemCreateManyInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: number
    amount: number
    taxable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    customerId: string
    amount: number
    method: PaymentMethod
    status?: PaymentStatus
    transactionId?: string | null
    paymentDate?: Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: number
    refundReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineItemUncheckedUpdateManyWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    taxable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: FloatFieldUpdateOperationsInput | number
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    refundedAmount?: FloatFieldUpdateOperationsInput | number
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyCheckInInput = {
    id?: string
    activityType: string
    notes?: string | null
    timestamp?: Date | string
    recordedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutCheckInInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateWithoutCheckInInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}